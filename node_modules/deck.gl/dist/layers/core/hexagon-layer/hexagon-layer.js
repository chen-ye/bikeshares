'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _lib = require('../../../lib');

var _hexagonCellLayer = require('../hexagon-cell-layer/hexagon-cell-layer');

var _hexagonCellLayer2 = _interopRequireDefault(_hexagonCellLayer);

var _utils = require('../../../lib/utils');

var _scaleUtils = require('../../../utils/scale-utils');

var _colorUtils = require('../../../utils/color-utils');

var _hexagonAggregator2 = require('./hexagon-aggregator');

var _binSorter = require('../../../utils/bin-sorter');

var _binSorter2 = _interopRequireDefault(_binSorter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

function nop() {}

var defaultProps = {
  // color
  colorDomain: null,
  colorRange: _colorUtils.defaultColorRange,
  getColorValue: function getColorValue(points) {
    return points.length;
  },
  lowerPercentile: 0,
  upperPercentile: 100,
  onSetColorDomain: nop,

  // elevation
  elevationDomain: null,
  elevationRange: [0, 1000],
  getElevationValue: function getElevationValue(points) {
    return points.length;
  },
  elevationLowerPercentile: 0,
  elevationUpperPercentile: 100,
  elevationScale: 1,
  onSetElevationDomain: nop,

  radius: 1000,
  coverage: 1,
  extruded: false,
  hexagonAggregator: _hexagonAggregator2.pointToHexbin,
  getPosition: function getPosition(x) {
    return x.position;
  },
  fp64: false,
  // Optional settings for 'lighting' shader module
  lightSettings: {
    lightsPosition: [-122.45, 37.75, 8000, -122.0, 38.00, 5000],
    ambientRatio: 0.05,
    diffuseRatio: 0.6,
    specularRatio: 0.8,
    lightsStrength: [2.0, 0.0, 0.0, 0.0],
    numberOfLights: 2
  }
};

var HexagonLayer = function (_CompositeLayer) {
  _inherits(HexagonLayer, _CompositeLayer);

  function HexagonLayer(props) {
    _classCallCheck(this, HexagonLayer);

    if (!props.hexagonAggregator && !props.radius) {
      _utils.log.once(0, 'HexagonLayer: Default hexagonAggregator requires radius prop to be set, ' + 'Now using 1000 meter as default');

      props.radius = defaultProps.radius;
    }

    if (Number.isFinite(props.upperPercentile) && (props.upperPercentile > 100 || props.upperPercentile < 0)) {
      _utils.log.once(0, 'HexagonLayer: upperPercentile should be between 0 and 100. ' + 'Assign to 100 by default');

      props.upperPercentile = defaultProps.upperPercentile;
    }

    if (Number.isFinite(props.lowerPercentile) && (props.lowerPercentile > 100 || props.lowerPercentile < 0)) {
      _utils.log.once(0, 'HexagonLayer: lowerPercentile should be between 0 and 100. ' + 'Assign to 0 by default');

      props.lowerPercentile = defaultProps.upperPercentile;
    }

    if (props.lowerPercentile >= props.upperPercentile) {
      _utils.log.once(0, 'HexagonLayer: lowerPercentile should not be bigger than ' + 'upperPercentile. Assign to 0 by default');

      props.lowerPercentile = defaultProps.lowerPercentile;
    }

    return _possibleConstructorReturn(this, (HexagonLayer.__proto__ || Object.getPrototypeOf(HexagonLayer)).call(this, props));
  }

  _createClass(HexagonLayer, [{
    key: 'initializeState',
    value: function initializeState() {
      this.state = {
        hexagons: [],
        hexagonVertices: null,
        sortedColorBins: null,
        sortedElevationBins: null,
        colorValueDomain: null,
        elevationValueDomain: null,
        colorScaleFunc: nop,
        elevationScaleFunc: nop,
        dimensionUpdaters: this.getDimensionUpdaters()
      };
    }
  }, {
    key: 'shouldUpdateState',
    value: function shouldUpdateState(_ref) {
      var changeFlags = _ref.changeFlags;

      return changeFlags.somethingChanged;
    }
  }, {
    key: 'updateState',
    value: function updateState(_ref2) {
      var _this2 = this;

      var oldProps = _ref2.oldProps,
          props = _ref2.props,
          changeFlags = _ref2.changeFlags;

      var dimensionChanges = this.getDimensionChanges(oldProps, props);

      if (changeFlags.dataChanged || this.needsReProjectPoints(oldProps, props)) {
        // project data into hexagons, and get sortedColorBins
        this.getHexagons();
      } else if (dimensionChanges) {
        dimensionChanges.forEach(function (f) {
          return typeof f === 'function' && f.apply(_this2);
        });
      }
    }
  }, {
    key: 'needsReProjectPoints',
    value: function needsReProjectPoints(oldProps, props) {
      return oldProps.radius !== props.radius || oldProps.hexagonAggregator !== props.hexagonAggregator;
    }
  }, {
    key: 'getDimensionUpdaters',
    value: function getDimensionUpdaters() {
      // dimension updaters are sequential,
      // if the first one needs to be called, the 2nd and 3rd one will automatically
      // be called. e.g. if ColorValue needs to be updated, getColorValueDomain and getColorScale
      // will automatically be called
      return {
        getColor: [{
          id: 'value',
          triggers: ['getColorValue'],
          updater: this.getSortedColorBins
        }, {
          id: 'domain',
          triggers: ['lowerPercentile', 'upperPercentile'],
          updater: this.getColorValueDomain
        }, {
          id: 'scaleFunc',
          triggers: ['colorDomain', 'colorRange'],
          updater: this.getColorScale
        }],
        getElevation: [{
          id: 'value',
          triggers: ['getElevationValue'],
          updater: this.getSortedElevationBins
        }, {
          id: 'domain',
          triggers: ['elevationLowerPercentile', 'elevationUpperPercentile'],
          updater: this.getElevationValueDomain
        }, {
          id: 'scaleFunc',
          triggers: ['elevationDomain', 'elevationRange'],
          updater: this.getElevationScale
        }]
      };
    }
  }, {
    key: 'getDimensionChanges',
    value: function getDimensionChanges(oldProps, props) {
      var dimensionUpdaters = this.state.dimensionUpdaters;

      var updaters = [];

      // get dimension to be updated
      for (var dimensionKey in dimensionUpdaters) {

        // return the first triggered updater for each dimension
        var needUpdate = dimensionUpdaters[dimensionKey].find(function (item) {
          return item.triggers.some(function (t) {
            return oldProps[t] !== props[t];
          });
        });

        if (needUpdate) {
          updaters.push(needUpdate.updater);
        }
      }

      return updaters.length ? updaters : null;
    }
  }, {
    key: 'getHexagons',
    value: function getHexagons() {
      var hexagonAggregator = this.props.hexagonAggregator;
      var viewport = this.context.viewport;

      var _hexagonAggregator = hexagonAggregator(this.props, viewport),
          hexagons = _hexagonAggregator.hexagons,
          hexagonVertices = _hexagonAggregator.hexagonVertices;

      this.setState({ hexagons: hexagons, hexagonVertices: hexagonVertices });
      this.getSortedBins();
    }
  }, {
    key: 'getPickingInfo',
    value: function getPickingInfo(_ref3) {
      var info = _ref3.info;
      var _state = this.state,
          sortedColorBins = _state.sortedColorBins,
          sortedElevationBins = _state.sortedElevationBins;

      var isPicked = info.picked && info.index > -1;

      var object = null;
      if (isPicked) {

        var cell = this.state.hexagons[info.index];

        var colorValue = sortedColorBins.binMap[cell.index] && sortedColorBins.binMap[cell.index].value;
        var elevationValue = sortedElevationBins.binMap[cell.index] && sortedElevationBins.binMap[cell.index].value;

        object = Object.assign({
          colorValue: colorValue,
          elevationValue: elevationValue
        }, cell);
      }

      // add bin colorValue and elevationValue to info
      return Object.assign(info, {
        picked: Boolean(object),
        // override object with picked cell
        object: object
      });
    }
  }, {
    key: 'getUpdateTriggers',
    value: function getUpdateTriggers() {
      var _this3 = this;

      var dimensionUpdaters = this.state.dimensionUpdaters;

      // merge all dimension triggers

      var updateTriggers = {};

      var _loop = function _loop(dimensionKey) {

        updateTriggers[dimensionKey] = {};

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = dimensionUpdaters[dimensionKey][Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var step = _step.value;


            step.triggers.forEach(function (prop) {
              updateTriggers[dimensionKey][prop] = _this3.props[prop];
            });
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      };

      for (var dimensionKey in dimensionUpdaters) {
        _loop(dimensionKey);
      }

      return updateTriggers;
    }
  }, {
    key: 'getValueDomain',
    value: function getValueDomain() {
      this.getColorValueDomain();
      this.getElevationValueDomain();
    }
  }, {
    key: 'getSortedBins',
    value: function getSortedBins() {
      this.getSortedColorBins();
      this.getSortedElevationBins();
    }
  }, {
    key: 'getSortedColorBins',
    value: function getSortedColorBins() {
      var getColorValue = this.props.getColorValue;

      var sortedColorBins = new _binSorter2.default(this.state.hexagons || [], getColorValue);

      this.setState({ sortedColorBins: sortedColorBins });
      this.getColorValueDomain();
    }
  }, {
    key: 'getSortedElevationBins',
    value: function getSortedElevationBins() {
      var getElevationValue = this.props.getElevationValue;

      var sortedElevationBins = new _binSorter2.default(this.state.hexagons || [], getElevationValue);
      this.setState({ sortedElevationBins: sortedElevationBins });
      this.getElevationValueDomain();
    }
  }, {
    key: 'getColorValueDomain',
    value: function getColorValueDomain() {
      var _props = this.props,
          lowerPercentile = _props.lowerPercentile,
          upperPercentile = _props.upperPercentile,
          onSetColorDomain = _props.onSetColorDomain;


      this.state.colorValueDomain = this.state.sortedColorBins.getValueRange([lowerPercentile, upperPercentile]);

      if (typeof onSetColorDomain === 'function') {
        onSetColorDomain(this.state.colorValueDomain);
      }

      this.getColorScale();
    }
  }, {
    key: 'getElevationValueDomain',
    value: function getElevationValueDomain() {
      var _props2 = this.props,
          elevationLowerPercentile = _props2.elevationLowerPercentile,
          elevationUpperPercentile = _props2.elevationUpperPercentile,
          onSetElevationDomain = _props2.onSetElevationDomain;


      this.state.elevationValueDomain = this.state.sortedElevationBins.getValueRange([elevationLowerPercentile, elevationUpperPercentile]);

      if (typeof onSetElevationDomain === 'function') {
        onSetElevationDomain(this.state.elevationValueDomain);
      }

      this.getElevationScale();
    }
  }, {
    key: 'getColorScale',
    value: function getColorScale() {
      var colorRange = this.props.colorRange;

      var colorDomain = this.props.colorDomain || this.state.colorValueDomain;

      this.state.colorScaleFunc = (0, _scaleUtils.getQuantizeScale)(colorDomain, colorRange);
    }
  }, {
    key: 'getElevationScale',
    value: function getElevationScale() {
      var elevationRange = this.props.elevationRange;

      var elevationDomain = this.props.elevationDomain || this.state.elevationValueDomain;

      this.state.elevationScaleFunc = (0, _scaleUtils.getLinearScale)(elevationDomain, elevationRange);
    }
  }, {
    key: '_onGetSublayerColor',
    value: function _onGetSublayerColor(cell) {
      var _state2 = this.state,
          sortedColorBins = _state2.sortedColorBins,
          colorScaleFunc = _state2.colorScaleFunc,
          colorValueDomain = _state2.colorValueDomain;


      var cv = sortedColorBins.binMap[cell.index] && sortedColorBins.binMap[cell.index].value;
      var colorDomain = this.props.colorDomain || colorValueDomain;

      var isColorValueInDomain = cv >= colorDomain[0] && cv <= colorDomain[colorDomain.length - 1];

      // if cell value is outside domain, set alpha to 0
      var color = isColorValueInDomain ? colorScaleFunc(cv) : [0, 0, 0, 0];

      // add alpha to color if not defined in colorRange
      color[3] = Number.isFinite(color[3]) ? color[3] : 255;

      return color;
    }
  }, {
    key: '_onGetSublayerElevation',
    value: function _onGetSublayerElevation(cell) {
      var _state3 = this.state,
          sortedElevationBins = _state3.sortedElevationBins,
          elevationScaleFunc = _state3.elevationScaleFunc,
          elevationValueDomain = _state3.elevationValueDomain;

      var ev = sortedElevationBins.binMap[cell.index] && sortedElevationBins.binMap[cell.index].value;

      var elevationDomain = this.props.elevationDomain || elevationValueDomain;

      var isElevationValueInDomain = ev >= elevationDomain[0] && ev <= elevationDomain[elevationDomain.length - 1];

      // if cell value is outside domain, set elevation to -1
      return isElevationValueInDomain ? elevationScaleFunc(ev) : -1;
    }
  }, {
    key: 'getSubLayerProps',
    value: function getSubLayerProps() {
      // for subclassing, override this method to return
      // customized sub layer props
      var _props3 = this.props,
          id = _props3.id,
          radius = _props3.radius,
          elevationScale = _props3.elevationScale,
          extruded = _props3.extruded,
          coverage = _props3.coverage,
          lightSettings = _props3.lightSettings,
          fp64 = _props3.fp64;

      // base layer props

      var _props4 = this.props,
          opacity = _props4.opacity,
          pickable = _props4.pickable,
          visible = _props4.visible,
          getPolygonOffset = _props4.getPolygonOffset;

      // viewport props

      var _props5 = this.props,
          positionOrigin = _props5.positionOrigin,
          projectionMode = _props5.projectionMode,
          modelMatrix = _props5.modelMatrix;

      // return props to the sublayer constructor

      return {
        id: id + '-hexagon-cell',
        data: this.state.hexagons,
        hexagonVertices: this.state.hexagonVertices,
        radius: radius,
        elevationScale: elevationScale,
        angle: Math.PI,
        extruded: extruded,
        coverage: coverage,
        lightSettings: lightSettings,
        fp64: fp64,
        opacity: opacity,
        pickable: pickable,
        visible: visible,
        getPolygonOffset: getPolygonOffset,
        projectionMode: projectionMode,
        positionOrigin: positionOrigin,
        modelMatrix: modelMatrix,
        getColor: this._onGetSublayerColor.bind(this),
        getElevation: this._onGetSublayerElevation.bind(this),
        updateTriggers: this.getUpdateTriggers()
      };
    }
  }, {
    key: 'getSubLayerClass',
    value: function getSubLayerClass() {
      // for subclassing, override this method to return
      // customized sub layer class
      return _hexagonCellLayer2.default;
    }
  }, {
    key: 'renderLayers',
    value: function renderLayers() {
      var SubLayerClass = this.getSubLayerClass();

      return new SubLayerClass(this.getSubLayerProps());
    }
  }]);

  return HexagonLayer;
}(_lib.CompositeLayer);

exports.default = HexagonLayer;


HexagonLayer.layerName = 'HexagonLayer';
HexagonLayer.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9oZXhhZ29uLWxheWVyL2hleGFnb24tbGF5ZXIuanMiXSwibmFtZXMiOlsibm9wIiwiZGVmYXVsdFByb3BzIiwiY29sb3JEb21haW4iLCJjb2xvclJhbmdlIiwiZ2V0Q29sb3JWYWx1ZSIsInBvaW50cyIsImxlbmd0aCIsImxvd2VyUGVyY2VudGlsZSIsInVwcGVyUGVyY2VudGlsZSIsIm9uU2V0Q29sb3JEb21haW4iLCJlbGV2YXRpb25Eb21haW4iLCJlbGV2YXRpb25SYW5nZSIsImdldEVsZXZhdGlvblZhbHVlIiwiZWxldmF0aW9uTG93ZXJQZXJjZW50aWxlIiwiZWxldmF0aW9uVXBwZXJQZXJjZW50aWxlIiwiZWxldmF0aW9uU2NhbGUiLCJvblNldEVsZXZhdGlvbkRvbWFpbiIsInJhZGl1cyIsImNvdmVyYWdlIiwiZXh0cnVkZWQiLCJoZXhhZ29uQWdncmVnYXRvciIsImdldFBvc2l0aW9uIiwieCIsInBvc2l0aW9uIiwiZnA2NCIsImxpZ2h0U2V0dGluZ3MiLCJsaWdodHNQb3NpdGlvbiIsImFtYmllbnRSYXRpbyIsImRpZmZ1c2VSYXRpbyIsInNwZWN1bGFyUmF0aW8iLCJsaWdodHNTdHJlbmd0aCIsIm51bWJlck9mTGlnaHRzIiwiSGV4YWdvbkxheWVyIiwicHJvcHMiLCJvbmNlIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJzdGF0ZSIsImhleGFnb25zIiwiaGV4YWdvblZlcnRpY2VzIiwic29ydGVkQ29sb3JCaW5zIiwic29ydGVkRWxldmF0aW9uQmlucyIsImNvbG9yVmFsdWVEb21haW4iLCJlbGV2YXRpb25WYWx1ZURvbWFpbiIsImNvbG9yU2NhbGVGdW5jIiwiZWxldmF0aW9uU2NhbGVGdW5jIiwiZGltZW5zaW9uVXBkYXRlcnMiLCJnZXREaW1lbnNpb25VcGRhdGVycyIsImNoYW5nZUZsYWdzIiwic29tZXRoaW5nQ2hhbmdlZCIsIm9sZFByb3BzIiwiZGltZW5zaW9uQ2hhbmdlcyIsImdldERpbWVuc2lvbkNoYW5nZXMiLCJkYXRhQ2hhbmdlZCIsIm5lZWRzUmVQcm9qZWN0UG9pbnRzIiwiZ2V0SGV4YWdvbnMiLCJmb3JFYWNoIiwiZiIsImFwcGx5IiwiZ2V0Q29sb3IiLCJpZCIsInRyaWdnZXJzIiwidXBkYXRlciIsImdldFNvcnRlZENvbG9yQmlucyIsImdldENvbG9yVmFsdWVEb21haW4iLCJnZXRDb2xvclNjYWxlIiwiZ2V0RWxldmF0aW9uIiwiZ2V0U29ydGVkRWxldmF0aW9uQmlucyIsImdldEVsZXZhdGlvblZhbHVlRG9tYWluIiwiZ2V0RWxldmF0aW9uU2NhbGUiLCJ1cGRhdGVycyIsImRpbWVuc2lvbktleSIsIm5lZWRVcGRhdGUiLCJmaW5kIiwiaXRlbSIsInNvbWUiLCJ0IiwicHVzaCIsInZpZXdwb3J0IiwiY29udGV4dCIsInNldFN0YXRlIiwiZ2V0U29ydGVkQmlucyIsImluZm8iLCJpc1BpY2tlZCIsInBpY2tlZCIsImluZGV4Iiwib2JqZWN0IiwiY2VsbCIsImNvbG9yVmFsdWUiLCJiaW5NYXAiLCJ2YWx1ZSIsImVsZXZhdGlvblZhbHVlIiwiT2JqZWN0IiwiYXNzaWduIiwiQm9vbGVhbiIsInVwZGF0ZVRyaWdnZXJzIiwic3RlcCIsInByb3AiLCJnZXRWYWx1ZVJhbmdlIiwiY3YiLCJpc0NvbG9yVmFsdWVJbkRvbWFpbiIsImNvbG9yIiwiZXYiLCJpc0VsZXZhdGlvblZhbHVlSW5Eb21haW4iLCJvcGFjaXR5IiwicGlja2FibGUiLCJ2aXNpYmxlIiwiZ2V0UG9seWdvbk9mZnNldCIsInBvc2l0aW9uT3JpZ2luIiwicHJvamVjdGlvbk1vZGUiLCJtb2RlbE1hdHJpeCIsImRhdGEiLCJhbmdsZSIsIk1hdGgiLCJQSSIsIl9vbkdldFN1YmxheWVyQ29sb3IiLCJiaW5kIiwiX29uR2V0U3VibGF5ZXJFbGV2YXRpb24iLCJnZXRVcGRhdGVUcmlnZ2VycyIsIlN1YkxheWVyQ2xhc3MiLCJnZXRTdWJMYXllckNsYXNzIiwiZ2V0U3ViTGF5ZXJQcm9wcyIsImxheWVyTmFtZSJdLCJt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LCJmaWxlIjoiaGV4YWdvbi1sYXllci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQge0NvbXBvc2l0ZUxheWVyfSBmcm9tICcuLi8uLi8uLi9saWInO1xuaW1wb3J0IEhleGFnb25DZWxsTGF5ZXIgZnJvbSAnLi4vaGV4YWdvbi1jZWxsLWxheWVyL2hleGFnb24tY2VsbC1sYXllcic7XG5pbXBvcnQge2xvZ30gZnJvbSAnLi4vLi4vLi4vbGliL3V0aWxzJztcblxuaW1wb3J0IHtnZXRRdWFudGl6ZVNjYWxlLCBnZXRMaW5lYXJTY2FsZX0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvc2NhbGUtdXRpbHMnO1xuaW1wb3J0IHtkZWZhdWx0Q29sb3JSYW5nZX0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvY29sb3ItdXRpbHMnO1xuaW1wb3J0IHtwb2ludFRvSGV4YmlufSBmcm9tICcuL2hleGFnb24tYWdncmVnYXRvcic7XG5cbmltcG9ydCBCaW5Tb3J0ZXIgZnJvbSAnLi4vLi4vLi4vdXRpbHMvYmluLXNvcnRlcic7XG5cbmZ1bmN0aW9uIG5vcCgpIHt9XG5cbmNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcbiAgLy8gY29sb3JcbiAgY29sb3JEb21haW46IG51bGwsXG4gIGNvbG9yUmFuZ2U6IGRlZmF1bHRDb2xvclJhbmdlLFxuICBnZXRDb2xvclZhbHVlOiBwb2ludHMgPT4gcG9pbnRzLmxlbmd0aCxcbiAgbG93ZXJQZXJjZW50aWxlOiAwLFxuICB1cHBlclBlcmNlbnRpbGU6IDEwMCxcbiAgb25TZXRDb2xvckRvbWFpbjogbm9wLFxuXG4gIC8vIGVsZXZhdGlvblxuICBlbGV2YXRpb25Eb21haW46IG51bGwsXG4gIGVsZXZhdGlvblJhbmdlOiBbMCwgMTAwMF0sXG4gIGdldEVsZXZhdGlvblZhbHVlOiBwb2ludHMgPT4gcG9pbnRzLmxlbmd0aCxcbiAgZWxldmF0aW9uTG93ZXJQZXJjZW50aWxlOiAwLFxuICBlbGV2YXRpb25VcHBlclBlcmNlbnRpbGU6IDEwMCxcbiAgZWxldmF0aW9uU2NhbGU6IDEsXG4gIG9uU2V0RWxldmF0aW9uRG9tYWluOiBub3AsXG5cbiAgcmFkaXVzOiAxMDAwLFxuICBjb3ZlcmFnZTogMSxcbiAgZXh0cnVkZWQ6IGZhbHNlLFxuICBoZXhhZ29uQWdncmVnYXRvcjogcG9pbnRUb0hleGJpbixcbiAgZ2V0UG9zaXRpb246IHggPT4geC5wb3NpdGlvbixcbiAgZnA2NDogZmFsc2UsXG4gIC8vIE9wdGlvbmFsIHNldHRpbmdzIGZvciAnbGlnaHRpbmcnIHNoYWRlciBtb2R1bGVcbiAgbGlnaHRTZXR0aW5nczoge1xuICAgIGxpZ2h0c1Bvc2l0aW9uOiBbLTEyMi40NSwgMzcuNzUsIDgwMDAsIC0xMjIuMCwgMzguMDAsIDUwMDBdLFxuICAgIGFtYmllbnRSYXRpbzogMC4wNSxcbiAgICBkaWZmdXNlUmF0aW86IDAuNixcbiAgICBzcGVjdWxhclJhdGlvOiAwLjgsXG4gICAgbGlnaHRzU3RyZW5ndGg6IFsyLjAsIDAuMCwgMC4wLCAwLjBdLFxuICAgIG51bWJlck9mTGlnaHRzOiAyXG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEhleGFnb25MYXllciBleHRlbmRzIENvbXBvc2l0ZUxheWVyIHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBpZiAoIXByb3BzLmhleGFnb25BZ2dyZWdhdG9yICYmICFwcm9wcy5yYWRpdXMpIHtcbiAgICAgIGxvZy5vbmNlKDAsICdIZXhhZ29uTGF5ZXI6IERlZmF1bHQgaGV4YWdvbkFnZ3JlZ2F0b3IgcmVxdWlyZXMgcmFkaXVzIHByb3AgdG8gYmUgc2V0LCAnICtcbiAgICAgICAgJ05vdyB1c2luZyAxMDAwIG1ldGVyIGFzIGRlZmF1bHQnKTtcblxuICAgICAgcHJvcHMucmFkaXVzID0gZGVmYXVsdFByb3BzLnJhZGl1cztcbiAgICB9XG5cbiAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHByb3BzLnVwcGVyUGVyY2VudGlsZSkgJiZcbiAgICAgIChwcm9wcy51cHBlclBlcmNlbnRpbGUgPiAxMDAgfHwgcHJvcHMudXBwZXJQZXJjZW50aWxlIDwgMCkpIHtcbiAgICAgIGxvZy5vbmNlKDAsICdIZXhhZ29uTGF5ZXI6IHVwcGVyUGVyY2VudGlsZSBzaG91bGQgYmUgYmV0d2VlbiAwIGFuZCAxMDAuICcgK1xuICAgICAgICAnQXNzaWduIHRvIDEwMCBieSBkZWZhdWx0Jyk7XG5cbiAgICAgIHByb3BzLnVwcGVyUGVyY2VudGlsZSA9IGRlZmF1bHRQcm9wcy51cHBlclBlcmNlbnRpbGU7XG4gICAgfVxuXG4gICAgaWYgKE51bWJlci5pc0Zpbml0ZShwcm9wcy5sb3dlclBlcmNlbnRpbGUpICYmXG4gICAgICAocHJvcHMubG93ZXJQZXJjZW50aWxlID4gMTAwIHx8IHByb3BzLmxvd2VyUGVyY2VudGlsZSA8IDApKSB7XG4gICAgICBsb2cub25jZSgwLCAnSGV4YWdvbkxheWVyOiBsb3dlclBlcmNlbnRpbGUgc2hvdWxkIGJlIGJldHdlZW4gMCBhbmQgMTAwLiAnICtcbiAgICAgICAgJ0Fzc2lnbiB0byAwIGJ5IGRlZmF1bHQnKTtcblxuICAgICAgcHJvcHMubG93ZXJQZXJjZW50aWxlID0gZGVmYXVsdFByb3BzLnVwcGVyUGVyY2VudGlsZTtcbiAgICB9XG5cbiAgICBpZiAocHJvcHMubG93ZXJQZXJjZW50aWxlID49IHByb3BzLnVwcGVyUGVyY2VudGlsZSkge1xuICAgICAgbG9nLm9uY2UoMCwgJ0hleGFnb25MYXllcjogbG93ZXJQZXJjZW50aWxlIHNob3VsZCBub3QgYmUgYmlnZ2VyIHRoYW4gJyArXG4gICAgICAgICd1cHBlclBlcmNlbnRpbGUuIEFzc2lnbiB0byAwIGJ5IGRlZmF1bHQnKTtcblxuICAgICAgcHJvcHMubG93ZXJQZXJjZW50aWxlID0gZGVmYXVsdFByb3BzLmxvd2VyUGVyY2VudGlsZTtcbiAgICB9XG5cbiAgICBzdXBlcihwcm9wcyk7XG4gIH1cblxuICBpbml0aWFsaXplU3RhdGUoKSB7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGhleGFnb25zOiBbXSxcbiAgICAgIGhleGFnb25WZXJ0aWNlczogbnVsbCxcbiAgICAgIHNvcnRlZENvbG9yQmluczogbnVsbCxcbiAgICAgIHNvcnRlZEVsZXZhdGlvbkJpbnM6IG51bGwsXG4gICAgICBjb2xvclZhbHVlRG9tYWluOiBudWxsLFxuICAgICAgZWxldmF0aW9uVmFsdWVEb21haW46IG51bGwsXG4gICAgICBjb2xvclNjYWxlRnVuYzogbm9wLFxuICAgICAgZWxldmF0aW9uU2NhbGVGdW5jOiBub3AsXG4gICAgICBkaW1lbnNpb25VcGRhdGVyczogdGhpcy5nZXREaW1lbnNpb25VcGRhdGVycygpXG4gICAgfTtcbiAgfVxuXG4gIHNob3VsZFVwZGF0ZVN0YXRlKHtjaGFuZ2VGbGFnc30pIHtcbiAgICByZXR1cm4gY2hhbmdlRmxhZ3Muc29tZXRoaW5nQ2hhbmdlZDtcbiAgfVxuXG4gIHVwZGF0ZVN0YXRlKHtvbGRQcm9wcywgcHJvcHMsIGNoYW5nZUZsYWdzfSkge1xuICAgIGNvbnN0IGRpbWVuc2lvbkNoYW5nZXMgPSB0aGlzLmdldERpbWVuc2lvbkNoYW5nZXMob2xkUHJvcHMsIHByb3BzKTtcblxuICAgIGlmIChjaGFuZ2VGbGFncy5kYXRhQ2hhbmdlZCB8fCB0aGlzLm5lZWRzUmVQcm9qZWN0UG9pbnRzKG9sZFByb3BzLCBwcm9wcykpIHtcbiAgICAgIC8vIHByb2plY3QgZGF0YSBpbnRvIGhleGFnb25zLCBhbmQgZ2V0IHNvcnRlZENvbG9yQmluc1xuICAgICAgdGhpcy5nZXRIZXhhZ29ucygpO1xuXG4gICAgfSBlbHNlIGlmIChkaW1lbnNpb25DaGFuZ2VzKSB7XG4gICAgICBkaW1lbnNpb25DaGFuZ2VzLmZvckVhY2goZiA9PiB0eXBlb2YgZiA9PT0gJ2Z1bmN0aW9uJyAmJiBmLmFwcGx5KHRoaXMpKTtcbiAgICB9XG4gIH1cblxuICBuZWVkc1JlUHJvamVjdFBvaW50cyhvbGRQcm9wcywgcHJvcHMpIHtcbiAgICByZXR1cm4gb2xkUHJvcHMucmFkaXVzICE9PSBwcm9wcy5yYWRpdXMgfHxcbiAgICAgIG9sZFByb3BzLmhleGFnb25BZ2dyZWdhdG9yICE9PSBwcm9wcy5oZXhhZ29uQWdncmVnYXRvcjtcbiAgfVxuXG4gIGdldERpbWVuc2lvblVwZGF0ZXJzKCkge1xuICAgIC8vIGRpbWVuc2lvbiB1cGRhdGVycyBhcmUgc2VxdWVudGlhbCxcbiAgICAvLyBpZiB0aGUgZmlyc3Qgb25lIG5lZWRzIHRvIGJlIGNhbGxlZCwgdGhlIDJuZCBhbmQgM3JkIG9uZSB3aWxsIGF1dG9tYXRpY2FsbHlcbiAgICAvLyBiZSBjYWxsZWQuIGUuZy4gaWYgQ29sb3JWYWx1ZSBuZWVkcyB0byBiZSB1cGRhdGVkLCBnZXRDb2xvclZhbHVlRG9tYWluIGFuZCBnZXRDb2xvclNjYWxlXG4gICAgLy8gd2lsbCBhdXRvbWF0aWNhbGx5IGJlIGNhbGxlZFxuICAgIHJldHVybiB7XG4gICAgICBnZXRDb2xvcjogW1xuICAgICAgICB7XG4gICAgICAgICAgaWQ6ICd2YWx1ZScsXG4gICAgICAgICAgdHJpZ2dlcnM6IFsnZ2V0Q29sb3JWYWx1ZSddLFxuICAgICAgICAgIHVwZGF0ZXI6IHRoaXMuZ2V0U29ydGVkQ29sb3JCaW5zXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBpZDogJ2RvbWFpbicsXG4gICAgICAgICAgdHJpZ2dlcnM6IFsnbG93ZXJQZXJjZW50aWxlJywgJ3VwcGVyUGVyY2VudGlsZSddLFxuICAgICAgICAgIHVwZGF0ZXI6IHRoaXMuZ2V0Q29sb3JWYWx1ZURvbWFpblxuICAgICAgICB9LCB7XG4gICAgICAgICAgaWQ6ICdzY2FsZUZ1bmMnLFxuICAgICAgICAgIHRyaWdnZXJzOiBbJ2NvbG9yRG9tYWluJywgJ2NvbG9yUmFuZ2UnXSxcbiAgICAgICAgICB1cGRhdGVyOiB0aGlzLmdldENvbG9yU2NhbGVcbiAgICAgICAgfVxuICAgICAgXSxcbiAgICAgIGdldEVsZXZhdGlvbjogW1xuICAgICAgICB7XG4gICAgICAgICAgaWQ6ICd2YWx1ZScsXG4gICAgICAgICAgdHJpZ2dlcnM6IFsnZ2V0RWxldmF0aW9uVmFsdWUnXSxcbiAgICAgICAgICB1cGRhdGVyOiB0aGlzLmdldFNvcnRlZEVsZXZhdGlvbkJpbnNcbiAgICAgICAgfSwge1xuICAgICAgICAgIGlkOiAnZG9tYWluJyxcbiAgICAgICAgICB0cmlnZ2VyczogWydlbGV2YXRpb25Mb3dlclBlcmNlbnRpbGUnLCAnZWxldmF0aW9uVXBwZXJQZXJjZW50aWxlJ10sXG4gICAgICAgICAgdXBkYXRlcjogdGhpcy5nZXRFbGV2YXRpb25WYWx1ZURvbWFpblxuICAgICAgICB9LCB7XG4gICAgICAgICAgaWQ6ICdzY2FsZUZ1bmMnLFxuICAgICAgICAgIHRyaWdnZXJzOiBbJ2VsZXZhdGlvbkRvbWFpbicsICdlbGV2YXRpb25SYW5nZSddLFxuICAgICAgICAgIHVwZGF0ZXI6IHRoaXMuZ2V0RWxldmF0aW9uU2NhbGVcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH07XG4gIH1cblxuICBnZXREaW1lbnNpb25DaGFuZ2VzKG9sZFByb3BzLCBwcm9wcykge1xuICAgIGNvbnN0IHtkaW1lbnNpb25VcGRhdGVyc30gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHVwZGF0ZXJzID0gW107XG5cbiAgICAvLyBnZXQgZGltZW5zaW9uIHRvIGJlIHVwZGF0ZWRcbiAgICBmb3IgKGNvbnN0IGRpbWVuc2lvbktleSBpbiBkaW1lbnNpb25VcGRhdGVycykge1xuXG4gICAgICAvLyByZXR1cm4gdGhlIGZpcnN0IHRyaWdnZXJlZCB1cGRhdGVyIGZvciBlYWNoIGRpbWVuc2lvblxuICAgICAgY29uc3QgbmVlZFVwZGF0ZSA9IGRpbWVuc2lvblVwZGF0ZXJzW2RpbWVuc2lvbktleV1cbiAgICAgICAgLmZpbmQoaXRlbSA9PiBpdGVtLnRyaWdnZXJzLnNvbWUodCA9PiBvbGRQcm9wc1t0XSAhPT0gcHJvcHNbdF0pKTtcblxuICAgICAgaWYgKG5lZWRVcGRhdGUpIHtcbiAgICAgICAgdXBkYXRlcnMucHVzaChuZWVkVXBkYXRlLnVwZGF0ZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB1cGRhdGVycy5sZW5ndGggPyB1cGRhdGVycyA6IG51bGw7XG4gIH1cblxuICBnZXRIZXhhZ29ucygpIHtcbiAgICBjb25zdCB7aGV4YWdvbkFnZ3JlZ2F0b3J9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7dmlld3BvcnR9ID0gdGhpcy5jb250ZXh0O1xuICAgIGNvbnN0IHtoZXhhZ29ucywgaGV4YWdvblZlcnRpY2VzfSA9IGhleGFnb25BZ2dyZWdhdG9yKHRoaXMucHJvcHMsIHZpZXdwb3J0KTtcbiAgICB0aGlzLnNldFN0YXRlKHtoZXhhZ29ucywgaGV4YWdvblZlcnRpY2VzfSk7XG4gICAgdGhpcy5nZXRTb3J0ZWRCaW5zKCk7XG4gIH1cblxuICBnZXRQaWNraW5nSW5mbyh7aW5mb30pIHtcbiAgICBjb25zdCB7c29ydGVkQ29sb3JCaW5zLCBzb3J0ZWRFbGV2YXRpb25CaW5zfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgaXNQaWNrZWQgPSBpbmZvLnBpY2tlZCAmJiBpbmZvLmluZGV4ID4gLTE7XG5cbiAgICBsZXQgb2JqZWN0ID0gbnVsbDtcbiAgICBpZiAoaXNQaWNrZWQpIHtcblxuICAgICAgY29uc3QgY2VsbCA9IHRoaXMuc3RhdGUuaGV4YWdvbnNbaW5mby5pbmRleF07XG5cbiAgICAgIGNvbnN0IGNvbG9yVmFsdWUgPSBzb3J0ZWRDb2xvckJpbnMuYmluTWFwW2NlbGwuaW5kZXhdICYmXG4gICAgICAgIHNvcnRlZENvbG9yQmlucy5iaW5NYXBbY2VsbC5pbmRleF0udmFsdWU7XG4gICAgICBjb25zdCBlbGV2YXRpb25WYWx1ZSA9IHNvcnRlZEVsZXZhdGlvbkJpbnMuYmluTWFwW2NlbGwuaW5kZXhdICYmXG4gICAgICAgIHNvcnRlZEVsZXZhdGlvbkJpbnMuYmluTWFwW2NlbGwuaW5kZXhdLnZhbHVlO1xuXG4gICAgICBvYmplY3QgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgY29sb3JWYWx1ZSxcbiAgICAgICAgZWxldmF0aW9uVmFsdWVcbiAgICAgIH0sIGNlbGwpO1xuICAgIH1cblxuICAgIC8vIGFkZCBiaW4gY29sb3JWYWx1ZSBhbmQgZWxldmF0aW9uVmFsdWUgdG8gaW5mb1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGluZm8sIHtcbiAgICAgIHBpY2tlZDogQm9vbGVhbihvYmplY3QpLFxuICAgICAgLy8gb3ZlcnJpZGUgb2JqZWN0IHdpdGggcGlja2VkIGNlbGxcbiAgICAgIG9iamVjdFxuICAgIH0pO1xuICB9XG5cbiAgZ2V0VXBkYXRlVHJpZ2dlcnMoKSB7XG4gICAgY29uc3Qge2RpbWVuc2lvblVwZGF0ZXJzfSA9IHRoaXMuc3RhdGU7XG5cbiAgICAvLyBtZXJnZSBhbGwgZGltZW5zaW9uIHRyaWdnZXJzXG4gICAgY29uc3QgdXBkYXRlVHJpZ2dlcnMgPSB7fTtcblxuICAgIGZvciAoY29uc3QgZGltZW5zaW9uS2V5IGluIGRpbWVuc2lvblVwZGF0ZXJzKSB7XG5cbiAgICAgIHVwZGF0ZVRyaWdnZXJzW2RpbWVuc2lvbktleV0gPSB7fTtcblxuICAgICAgZm9yIChjb25zdCBzdGVwIG9mIGRpbWVuc2lvblVwZGF0ZXJzW2RpbWVuc2lvbktleV0pIHtcblxuICAgICAgICBzdGVwLnRyaWdnZXJzLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICAgICAgdXBkYXRlVHJpZ2dlcnNbZGltZW5zaW9uS2V5XVtwcm9wXSA9IHRoaXMucHJvcHNbcHJvcF07XG4gICAgICAgIH0pO1xuXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHVwZGF0ZVRyaWdnZXJzO1xuICB9XG5cbiAgZ2V0VmFsdWVEb21haW4oKSB7XG4gICAgdGhpcy5nZXRDb2xvclZhbHVlRG9tYWluKCk7XG4gICAgdGhpcy5nZXRFbGV2YXRpb25WYWx1ZURvbWFpbigpO1xuICB9XG5cbiAgZ2V0U29ydGVkQmlucygpIHtcbiAgICB0aGlzLmdldFNvcnRlZENvbG9yQmlucygpO1xuICAgIHRoaXMuZ2V0U29ydGVkRWxldmF0aW9uQmlucygpO1xuICB9XG5cbiAgZ2V0U29ydGVkQ29sb3JCaW5zKCkge1xuICAgIGNvbnN0IHtnZXRDb2xvclZhbHVlfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qgc29ydGVkQ29sb3JCaW5zID0gbmV3IEJpblNvcnRlcih0aGlzLnN0YXRlLmhleGFnb25zIHx8IFtdLCBnZXRDb2xvclZhbHVlKTtcblxuICAgIHRoaXMuc2V0U3RhdGUoe3NvcnRlZENvbG9yQmluc30pO1xuICAgIHRoaXMuZ2V0Q29sb3JWYWx1ZURvbWFpbigpO1xuICB9XG5cbiAgZ2V0U29ydGVkRWxldmF0aW9uQmlucygpIHtcbiAgICBjb25zdCB7Z2V0RWxldmF0aW9uVmFsdWV9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCBzb3J0ZWRFbGV2YXRpb25CaW5zID0gbmV3IEJpblNvcnRlcih0aGlzLnN0YXRlLmhleGFnb25zIHx8IFtdLCBnZXRFbGV2YXRpb25WYWx1ZSk7XG4gICAgdGhpcy5zZXRTdGF0ZSh7c29ydGVkRWxldmF0aW9uQmluc30pO1xuICAgIHRoaXMuZ2V0RWxldmF0aW9uVmFsdWVEb21haW4oKTtcbiAgfVxuXG4gIGdldENvbG9yVmFsdWVEb21haW4oKSB7XG4gICAgY29uc3Qge2xvd2VyUGVyY2VudGlsZSwgdXBwZXJQZXJjZW50aWxlLCBvblNldENvbG9yRG9tYWlufSA9IHRoaXMucHJvcHM7XG5cbiAgICB0aGlzLnN0YXRlLmNvbG9yVmFsdWVEb21haW4gPSB0aGlzLnN0YXRlLnNvcnRlZENvbG9yQmluc1xuICAgICAgLmdldFZhbHVlUmFuZ2UoW2xvd2VyUGVyY2VudGlsZSwgdXBwZXJQZXJjZW50aWxlXSk7XG5cbiAgICBpZiAodHlwZW9mIG9uU2V0Q29sb3JEb21haW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG9uU2V0Q29sb3JEb21haW4odGhpcy5zdGF0ZS5jb2xvclZhbHVlRG9tYWluKTtcbiAgICB9XG5cbiAgICB0aGlzLmdldENvbG9yU2NhbGUoKTtcbiAgfVxuXG4gIGdldEVsZXZhdGlvblZhbHVlRG9tYWluKCkge1xuICAgIGNvbnN0IHtlbGV2YXRpb25Mb3dlclBlcmNlbnRpbGUsIGVsZXZhdGlvblVwcGVyUGVyY2VudGlsZSwgb25TZXRFbGV2YXRpb25Eb21haW59ID0gdGhpcy5wcm9wcztcblxuICAgIHRoaXMuc3RhdGUuZWxldmF0aW9uVmFsdWVEb21haW4gPSB0aGlzLnN0YXRlLnNvcnRlZEVsZXZhdGlvbkJpbnNcbiAgICAgIC5nZXRWYWx1ZVJhbmdlKFtlbGV2YXRpb25Mb3dlclBlcmNlbnRpbGUsIGVsZXZhdGlvblVwcGVyUGVyY2VudGlsZV0pO1xuXG4gICAgaWYgKHR5cGVvZiBvblNldEVsZXZhdGlvbkRvbWFpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb25TZXRFbGV2YXRpb25Eb21haW4odGhpcy5zdGF0ZS5lbGV2YXRpb25WYWx1ZURvbWFpbik7XG4gICAgfVxuXG4gICAgdGhpcy5nZXRFbGV2YXRpb25TY2FsZSgpO1xuICB9XG5cbiAgZ2V0Q29sb3JTY2FsZSgpIHtcbiAgICBjb25zdCB7Y29sb3JSYW5nZX0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IGNvbG9yRG9tYWluID0gdGhpcy5wcm9wcy5jb2xvckRvbWFpbiB8fCB0aGlzLnN0YXRlLmNvbG9yVmFsdWVEb21haW47XG5cbiAgICB0aGlzLnN0YXRlLmNvbG9yU2NhbGVGdW5jID0gZ2V0UXVhbnRpemVTY2FsZShjb2xvckRvbWFpbiwgY29sb3JSYW5nZSk7XG4gIH1cblxuICBnZXRFbGV2YXRpb25TY2FsZSgpIHtcbiAgICBjb25zdCB7ZWxldmF0aW9uUmFuZ2V9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCBlbGV2YXRpb25Eb21haW4gPSB0aGlzLnByb3BzLmVsZXZhdGlvbkRvbWFpbiB8fCB0aGlzLnN0YXRlLmVsZXZhdGlvblZhbHVlRG9tYWluO1xuXG4gICAgdGhpcy5zdGF0ZS5lbGV2YXRpb25TY2FsZUZ1bmMgPSBnZXRMaW5lYXJTY2FsZShlbGV2YXRpb25Eb21haW4sIGVsZXZhdGlvblJhbmdlKTtcbiAgfVxuXG4gIF9vbkdldFN1YmxheWVyQ29sb3IoY2VsbCkge1xuICAgIGNvbnN0IHtzb3J0ZWRDb2xvckJpbnMsIGNvbG9yU2NhbGVGdW5jLCBjb2xvclZhbHVlRG9tYWlufSA9IHRoaXMuc3RhdGU7XG5cbiAgICBjb25zdCBjdiA9IHNvcnRlZENvbG9yQmlucy5iaW5NYXBbY2VsbC5pbmRleF0gJiYgc29ydGVkQ29sb3JCaW5zLmJpbk1hcFtjZWxsLmluZGV4XS52YWx1ZTtcbiAgICBjb25zdCBjb2xvckRvbWFpbiA9IHRoaXMucHJvcHMuY29sb3JEb21haW4gfHwgY29sb3JWYWx1ZURvbWFpbjtcblxuICAgIGNvbnN0IGlzQ29sb3JWYWx1ZUluRG9tYWluID0gY3YgPj0gY29sb3JEb21haW5bMF0gJiYgY3YgPD0gY29sb3JEb21haW5bY29sb3JEb21haW4ubGVuZ3RoIC0gMV07XG5cbiAgICAvLyBpZiBjZWxsIHZhbHVlIGlzIG91dHNpZGUgZG9tYWluLCBzZXQgYWxwaGEgdG8gMFxuICAgIGNvbnN0IGNvbG9yID0gaXNDb2xvclZhbHVlSW5Eb21haW4gPyBjb2xvclNjYWxlRnVuYyhjdikgOiBbMCwgMCwgMCwgMF07XG5cbiAgICAvLyBhZGQgYWxwaGEgdG8gY29sb3IgaWYgbm90IGRlZmluZWQgaW4gY29sb3JSYW5nZVxuICAgIGNvbG9yWzNdID0gTnVtYmVyLmlzRmluaXRlKGNvbG9yWzNdKSA/IGNvbG9yWzNdIDogMjU1O1xuXG4gICAgcmV0dXJuIGNvbG9yO1xuICB9XG5cbiAgX29uR2V0U3VibGF5ZXJFbGV2YXRpb24oY2VsbCkge1xuICAgIGNvbnN0IHtzb3J0ZWRFbGV2YXRpb25CaW5zLCBlbGV2YXRpb25TY2FsZUZ1bmMsIGVsZXZhdGlvblZhbHVlRG9tYWlufSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgZXYgPSBzb3J0ZWRFbGV2YXRpb25CaW5zLmJpbk1hcFtjZWxsLmluZGV4XSAmJlxuICAgICAgc29ydGVkRWxldmF0aW9uQmlucy5iaW5NYXBbY2VsbC5pbmRleF0udmFsdWU7XG5cbiAgICBjb25zdCBlbGV2YXRpb25Eb21haW4gPSB0aGlzLnByb3BzLmVsZXZhdGlvbkRvbWFpbiB8fCBlbGV2YXRpb25WYWx1ZURvbWFpbjtcblxuICAgIGNvbnN0IGlzRWxldmF0aW9uVmFsdWVJbkRvbWFpbiA9IGV2ID49IGVsZXZhdGlvbkRvbWFpblswXSAmJlxuICAgICAgZXYgPD0gZWxldmF0aW9uRG9tYWluW2VsZXZhdGlvbkRvbWFpbi5sZW5ndGggLSAxXTtcblxuICAgIC8vIGlmIGNlbGwgdmFsdWUgaXMgb3V0c2lkZSBkb21haW4sIHNldCBlbGV2YXRpb24gdG8gLTFcbiAgICByZXR1cm4gaXNFbGV2YXRpb25WYWx1ZUluRG9tYWluID8gZWxldmF0aW9uU2NhbGVGdW5jKGV2KSA6IC0xO1xuICB9XG5cbiAgZ2V0U3ViTGF5ZXJQcm9wcygpIHtcbiAgICAvLyBmb3Igc3ViY2xhc3NpbmcsIG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIHJldHVyblxuICAgIC8vIGN1c3RvbWl6ZWQgc3ViIGxheWVyIHByb3BzXG4gICAgY29uc3Qge2lkLCByYWRpdXMsIGVsZXZhdGlvblNjYWxlLCBleHRydWRlZCwgY292ZXJhZ2UsIGxpZ2h0U2V0dGluZ3MsIGZwNjR9ID0gdGhpcy5wcm9wcztcblxuICAgIC8vIGJhc2UgbGF5ZXIgcHJvcHNcbiAgICBjb25zdCB7b3BhY2l0eSwgcGlja2FibGUsIHZpc2libGUsIGdldFBvbHlnb25PZmZzZXR9ID0gdGhpcy5wcm9wcztcblxuICAgIC8vIHZpZXdwb3J0IHByb3BzXG4gICAgY29uc3Qge3Bvc2l0aW9uT3JpZ2luLCBwcm9qZWN0aW9uTW9kZSwgbW9kZWxNYXRyaXh9ID0gdGhpcy5wcm9wcztcblxuICAgIC8vIHJldHVybiBwcm9wcyB0byB0aGUgc3VibGF5ZXIgY29uc3RydWN0b3JcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IGAke2lkfS1oZXhhZ29uLWNlbGxgLFxuICAgICAgZGF0YTogdGhpcy5zdGF0ZS5oZXhhZ29ucyxcbiAgICAgIGhleGFnb25WZXJ0aWNlczogdGhpcy5zdGF0ZS5oZXhhZ29uVmVydGljZXMsXG4gICAgICByYWRpdXMsXG4gICAgICBlbGV2YXRpb25TY2FsZSxcbiAgICAgIGFuZ2xlOiBNYXRoLlBJLFxuICAgICAgZXh0cnVkZWQsXG4gICAgICBjb3ZlcmFnZSxcbiAgICAgIGxpZ2h0U2V0dGluZ3MsXG4gICAgICBmcDY0LFxuICAgICAgb3BhY2l0eSxcbiAgICAgIHBpY2thYmxlLFxuICAgICAgdmlzaWJsZSxcbiAgICAgIGdldFBvbHlnb25PZmZzZXQsXG4gICAgICBwcm9qZWN0aW9uTW9kZSxcbiAgICAgIHBvc2l0aW9uT3JpZ2luLFxuICAgICAgbW9kZWxNYXRyaXgsXG4gICAgICBnZXRDb2xvcjogdGhpcy5fb25HZXRTdWJsYXllckNvbG9yLmJpbmQodGhpcyksXG4gICAgICBnZXRFbGV2YXRpb246IHRoaXMuX29uR2V0U3VibGF5ZXJFbGV2YXRpb24uYmluZCh0aGlzKSxcbiAgICAgIHVwZGF0ZVRyaWdnZXJzOiB0aGlzLmdldFVwZGF0ZVRyaWdnZXJzKClcbiAgICB9O1xuICB9XG5cbiAgZ2V0U3ViTGF5ZXJDbGFzcygpIHtcbiAgICAvLyBmb3Igc3ViY2xhc3NpbmcsIG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIHJldHVyblxuICAgIC8vIGN1c3RvbWl6ZWQgc3ViIGxheWVyIGNsYXNzXG4gICAgcmV0dXJuIEhleGFnb25DZWxsTGF5ZXI7XG4gIH1cblxuICByZW5kZXJMYXllcnMoKSB7XG4gICAgY29uc3QgU3ViTGF5ZXJDbGFzcyA9IHRoaXMuZ2V0U3ViTGF5ZXJDbGFzcygpO1xuXG4gICAgcmV0dXJuIG5ldyBTdWJMYXllckNsYXNzKFxuICAgICAgdGhpcy5nZXRTdWJMYXllclByb3BzKClcbiAgICApO1xuICB9XG59XG5cbkhleGFnb25MYXllci5sYXllck5hbWUgPSAnSGV4YWdvbkxheWVyJztcbkhleGFnb25MYXllci5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG4iXX0=