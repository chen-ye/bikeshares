'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _autobind = require('./autobind');

var _autobind2 = _interopRequireDefault(_autobind);

var _webglRenderer = require('./webgl-renderer');

var _webglRenderer2 = _interopRequireDefault(_webglRenderer);

var _lib = require('../lib');

var _experimental = require('../experimental');

var _luma = require('luma.gl');

var _viewports = require('../lib/viewports');

var _eventManager = require('../utils/events/event-manager');

var _eventManager2 = _interopRequireDefault(_eventManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

function noop() {}

var propTypes = {
  id: _propTypes2.default.string,
  width: _propTypes2.default.number.isRequired,
  height: _propTypes2.default.number.isRequired,
  layers: _propTypes2.default.arrayOf(_propTypes2.default.instanceOf(_lib.Layer)).isRequired,
  effects: _propTypes2.default.arrayOf(_propTypes2.default.instanceOf(_experimental.Effect)),
  gl: _propTypes2.default.object,
  debug: _propTypes2.default.bool,
  pickingRadius: _propTypes2.default.number,
  viewport: _propTypes2.default.instanceOf(_viewports.Viewport),
  onWebGLInitialized: _propTypes2.default.func,
  initWebGLParameters: _propTypes2.default.bool,
  onAfterRender: _propTypes2.default.func,
  onLayerClick: _propTypes2.default.func,
  onLayerHover: _propTypes2.default.func
};

var defaultProps = {
  id: 'deckgl-overlay',
  debug: false,
  pickingRadius: 0,
  gl: null,
  effects: [],
  onWebGLInitialized: noop,
  initWebGLParameters: false,
  onAfterRender: noop,
  onLayerClick: null,
  onLayerHover: null
};

var DeckGL = function (_React$Component) {
  _inherits(DeckGL, _React$Component);

  function DeckGL(props) {
    _classCallCheck(this, DeckGL);

    var _this = _possibleConstructorReturn(this, (DeckGL.__proto__ || Object.getPrototypeOf(DeckGL)).call(this, props));

    _this.state = {};
    _this.needsRedraw = true;
    _this.layerManager = null;
    _this.effectManager = null;
    (0, _autobind2.default)(_this);
    return _this;
  }

  _createClass(DeckGL, [{
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      this._updateLayers(nextProps);
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      if (this.layerManager) {
        this.layerManager.finalize();
      }
    }

    /* Public API */

  }, {
    key: 'queryObject',
    value: function queryObject(_ref) {
      var x = _ref.x,
          y = _ref.y,
          _ref$radius = _ref.radius,
          radius = _ref$radius === undefined ? 0 : _ref$radius,
          _ref$layerIds = _ref.layerIds,
          layerIds = _ref$layerIds === undefined ? null : _ref$layerIds;

      var selectedInfos = this.layerManager.pickLayer({ x: x, y: y, radius: radius, layerIds: layerIds, mode: 'query' });
      return selectedInfos.length ? selectedInfos[0] : null;
    }
  }, {
    key: 'queryVisibleObjects',
    value: function queryVisibleObjects(_ref2) {
      var x = _ref2.x,
          y = _ref2.y,
          _ref2$width = _ref2.width,
          width = _ref2$width === undefined ? 1 : _ref2$width,
          _ref2$height = _ref2.height,
          height = _ref2$height === undefined ? 1 : _ref2$height,
          _ref2$layerIds = _ref2.layerIds,
          layerIds = _ref2$layerIds === undefined ? null : _ref2$layerIds;

      return this.layerManager.queryLayer({ x: x, y: y, width: width, height: height, layerIds: layerIds });
    }
  }, {
    key: '_updateLayers',
    value: function _updateLayers(nextProps) {
      var width = nextProps.width,
          height = nextProps.height,
          latitude = nextProps.latitude,
          longitude = nextProps.longitude,
          zoom = nextProps.zoom,
          pitch = nextProps.pitch,
          bearing = nextProps.bearing,
          altitude = nextProps.altitude,
          pickingRadius = nextProps.pickingRadius,
          onLayerClick = nextProps.onLayerClick,
          onLayerHover = nextProps.onLayerHover;


      this.layerManager.setEventHandlingParameters({
        pickingRadius: pickingRadius,
        onLayerClick: onLayerClick,
        onLayerHover: onLayerHover
      });

      // If Viewport is not supplied, create one from mercator props
      var viewport = nextProps.viewport;

      viewport = viewport || new _viewports.WebMercatorViewport({
        width: width, height: height, latitude: latitude, longitude: longitude, zoom: zoom, pitch: pitch, bearing: bearing, altitude: altitude
      });

      if (this.layerManager) {
        this.layerManager.setViewport(viewport).updateLayers({ newLayers: nextProps.layers });
      }
    }
  }, {
    key: '_onRendererInitialized',
    value: function _onRendererInitialized(_ref3) {
      var gl = _ref3.gl,
          canvas = _ref3.canvas;

      (0, _luma.setParameters)(gl, {
        blend: true,
        blendFunc: [_luma.GL.SRC_ALPHA, _luma.GL.ONE_MINUS_SRC_ALPHA],
        polygonOffsetFill: true
      });

      // TODO - these will be set by default starting from next major release
      if (this.props.initWebGLParameters) {
        (0, _luma.setParameters)(gl, {
          depthTest: true,
          depthFunc: _luma.GL.LEQUAL
        });
      }

      var props = this.props;

      props.onWebGLInitialized(gl);

      // Note: avoid React setState due GL animation loop / setState timing issue
      this.layerManager = new _lib.LayerManager({ gl: gl });
      this.layerManager.initEventHandling(new _eventManager2.default(canvas));
      this.effectManager = new _experimental.EffectManager({ gl: gl, layerManager: this.layerManager });

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = props.effects[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var effect = _step.value;

          this.effectManager.addEffect(effect);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this._updateLayers(props);
    }
  }, {
    key: '_onRenderFrame',
    value: function _onRenderFrame(_ref4) {
      var gl = _ref4.gl;

      var redraw = this.layerManager.needsRedraw({ clearRedrawFlags: true });
      if (!redraw) {
        return;
      }

      // clear depth and color buffers
      gl.clear(_luma.GL.COLOR_BUFFER_BIT | _luma.GL.DEPTH_BUFFER_BIT);

      this.effectManager.preDraw();
      this.layerManager.drawLayers({ pass: 'to screen' });
      this.effectManager.draw();
    }
  }, {
    key: 'render',
    value: function render() {
      var _props = this.props,
          width = _props.width,
          height = _props.height,
          gl = _props.gl,
          debug = _props.debug;


      return (0, _react.createElement)(_webglRenderer2.default, Object.assign({}, this.props, {
        width: width,
        height: height,
        // NOTE: Add 'useDevicePixelRatio' to 'this.props' and also pass it down to
        // to modules where window.devicePixelRatio is used.
        useDevicePixelRatio: true,
        gl: gl,
        debug: debug,
        onRendererInitialized: this._onRendererInitialized,
        onNeedRedraw: this._onNeedRedraw,
        onRenderFrame: this._onRenderFrame
      }));
    }
  }]);

  return DeckGL;
}(_react2.default.Component);

exports.default = DeckGL;


DeckGL.propTypes = propTypes;
DeckGL.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9yZWFjdC9kZWNrZ2wuanMiXSwibmFtZXMiOlsibm9vcCIsInByb3BUeXBlcyIsImlkIiwic3RyaW5nIiwid2lkdGgiLCJudW1iZXIiLCJpc1JlcXVpcmVkIiwiaGVpZ2h0IiwibGF5ZXJzIiwiYXJyYXlPZiIsImluc3RhbmNlT2YiLCJlZmZlY3RzIiwiZ2wiLCJvYmplY3QiLCJkZWJ1ZyIsImJvb2wiLCJwaWNraW5nUmFkaXVzIiwidmlld3BvcnQiLCJvbldlYkdMSW5pdGlhbGl6ZWQiLCJmdW5jIiwiaW5pdFdlYkdMUGFyYW1ldGVycyIsIm9uQWZ0ZXJSZW5kZXIiLCJvbkxheWVyQ2xpY2siLCJvbkxheWVySG92ZXIiLCJkZWZhdWx0UHJvcHMiLCJEZWNrR0wiLCJwcm9wcyIsInN0YXRlIiwibmVlZHNSZWRyYXciLCJsYXllck1hbmFnZXIiLCJlZmZlY3RNYW5hZ2VyIiwibmV4dFByb3BzIiwiX3VwZGF0ZUxheWVycyIsImZpbmFsaXplIiwieCIsInkiLCJyYWRpdXMiLCJsYXllcklkcyIsInNlbGVjdGVkSW5mb3MiLCJwaWNrTGF5ZXIiLCJtb2RlIiwibGVuZ3RoIiwicXVlcnlMYXllciIsImxhdGl0dWRlIiwibG9uZ2l0dWRlIiwiem9vbSIsInBpdGNoIiwiYmVhcmluZyIsImFsdGl0dWRlIiwic2V0RXZlbnRIYW5kbGluZ1BhcmFtZXRlcnMiLCJzZXRWaWV3cG9ydCIsInVwZGF0ZUxheWVycyIsIm5ld0xheWVycyIsImNhbnZhcyIsImJsZW5kIiwiYmxlbmRGdW5jIiwiU1JDX0FMUEhBIiwiT05FX01JTlVTX1NSQ19BTFBIQSIsInBvbHlnb25PZmZzZXRGaWxsIiwiZGVwdGhUZXN0IiwiZGVwdGhGdW5jIiwiTEVRVUFMIiwiaW5pdEV2ZW50SGFuZGxpbmciLCJlZmZlY3QiLCJhZGRFZmZlY3QiLCJyZWRyYXciLCJjbGVhclJlZHJhd0ZsYWdzIiwiY2xlYXIiLCJDT0xPUl9CVUZGRVJfQklUIiwiREVQVEhfQlVGRkVSX0JJVCIsInByZURyYXciLCJkcmF3TGF5ZXJzIiwicGFzcyIsImRyYXciLCJPYmplY3QiLCJhc3NpZ24iLCJ1c2VEZXZpY2VQaXhlbFJhdGlvIiwib25SZW5kZXJlckluaXRpYWxpemVkIiwiX29uUmVuZGVyZXJJbml0aWFsaXplZCIsIm9uTmVlZFJlZHJhdyIsIl9vbk5lZWRSZWRyYXciLCJvblJlbmRlckZyYW1lIiwiX29uUmVuZGVyRnJhbWUiLCJDb21wb25lbnQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBb0JBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7K2VBNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQVlBLFNBQVNBLElBQVQsR0FBZ0IsQ0FBRTs7QUFFbEIsSUFBTUMsWUFBWTtBQUNoQkMsTUFBSSxvQkFBVUMsTUFERTtBQUVoQkMsU0FBTyxvQkFBVUMsTUFBVixDQUFpQkMsVUFGUjtBQUdoQkMsVUFBUSxvQkFBVUYsTUFBVixDQUFpQkMsVUFIVDtBQUloQkUsVUFBUSxvQkFBVUMsT0FBVixDQUFrQixvQkFBVUMsVUFBVixZQUFsQixFQUErQ0osVUFKdkM7QUFLaEJLLFdBQVMsb0JBQVVGLE9BQVYsQ0FBa0Isb0JBQVVDLFVBQVYsc0JBQWxCLENBTE87QUFNaEJFLE1BQUksb0JBQVVDLE1BTkU7QUFPaEJDLFNBQU8sb0JBQVVDLElBUEQ7QUFRaEJDLGlCQUFlLG9CQUFVWCxNQVJUO0FBU2hCWSxZQUFVLG9CQUFVUCxVQUFWLHFCQVRNO0FBVWhCUSxzQkFBb0Isb0JBQVVDLElBVmQ7QUFXaEJDLHVCQUFxQixvQkFBVUwsSUFYZjtBQVloQk0saUJBQWUsb0JBQVVGLElBWlQ7QUFhaEJHLGdCQUFjLG9CQUFVSCxJQWJSO0FBY2hCSSxnQkFBYyxvQkFBVUo7QUFkUixDQUFsQjs7QUFpQkEsSUFBTUssZUFBZTtB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RTtBQVFoRStELCtCQUF1QixLQUFLQyxzQkFSb0M7QUFTaEVDLHNCQUFjLEtBQUtDLGFBVDZDO0FBVWhFQyx1QkFBZSxLQUFLQztBQVY0QyxPQUE5QixDQUE3QixDQUFQO0FBWUQ7Ozs7RUEzSGlDLGdCQUFNQyxTOztrQkFBckIxRCxNOzs7QUE4SHJCQSxPQUFPeEIsU0FBUCxHQUFtQkEsU0FBbkI7QUFDQXdCLE9BQU9ELFlBQVAsR0FBc0JBLFlBQXRCIiwiZmlsZSI6ImRlY2tnbC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQgUmVhY3QsIHtjcmVhdGVFbGVtZW50fSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGF1dG9iaW5kIGZyb20gJy4vYXV0b2JpbmQnO1xuaW1wb3J0IFdlYkdMUmVuZGVyZXIgZnJvbSAnLi93ZWJnbC1yZW5kZXJlcic7XG5pbXBvcnQge0xheWVyTWFuYWdlciwgTGF5ZXJ9IGZyb20gJy4uL2xpYic7XG5pbXBvcnQge0VmZmVjdE1hbmFnZXIsIEVmZmVjdH0gZnJvbSAnLi4vZXhwZXJpbWVudGFsJztcbmltcG9ydCB7R0wsIHNldFBhcmFtZXRlcnN9IGZyb20gJ2x1bWEuZ2wnO1xuaW1wb3J0IHtWaWV3cG9ydCwgV2ViTWVyY2F0b3JWaWV3cG9ydH0gZnJvbSAnLi4vbGliL3ZpZXdwb3J0cyc7XG5pbXBvcnQgRXZlbnRNYW5hZ2VyIGZyb20gJy4uL3V0aWxzL2V2ZW50cy9ldmVudC1tYW5hZ2VyJztcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmNvbnN0IHByb3BUeXBlcyA9IHtcbiAgaWQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHdpZHRoOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIGhlaWdodDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICBsYXllcnM6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5pbnN0YW5jZU9mKExheWVyKSkuaXNSZXF1aXJlZCxcbiAgZWZmZWN0czogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLmluc3RhbmNlT2YoRWZmZWN0KSksXG4gIGdsOiBQcm9wVHlwZXMub2JqZWN0LFxuICBkZWJ1ZzogUHJvcFR5cGVzLmJvb2wsXG4gIHBpY2tpbmdSYWRpdXM6IFByb3BUeXBlcy5udW1iZXIsXG4gIHZpZXdwb3J0OiBQcm9wVHlwZXMuaW5zdGFuY2VPZihWaWV3cG9ydCksXG4gIG9uV2ViR0xJbml0aWFsaXplZDogUHJvcFR5cGVzLmZ1bmMsXG4gIGluaXRXZWJHTFBhcmFtZXRlcnM6IFByb3BUeXBlcy5ib29sLFxuICBvbkFmdGVyUmVuZGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25MYXllckNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25MYXllckhvdmVyOiBQcm9wVHlwZXMuZnVuY1xufTtcblxuY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICBpZDogJ2RlY2tnbC1vdmVybGF5JyxcbiAgZGVidWc6IGZhbHNlLFxuICBwaWNraW5nUmFkaXVzOiAwLFxuICBnbDogbnVsbCxcbiAgZWZmZWN0czogW10sXG4gIG9uV2ViR0xJbml0aWFsaXplZDogbm9vcCxcbiAgaW5pdFdlYkdMUGFyYW1ldGVyczogZmFsc2UsXG4gIG9uQWZ0ZXJSZW5kZXI6IG5vb3AsXG4gIG9uTGF5ZXJDbGljazogbnVsbCxcbiAgb25MYXllckhvdmVyOiBudWxsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEZWNrR0wgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLnN0YXRlID0ge307XG4gICAgdGhpcy5uZWVkc1JlZHJhdyA9IHRydWU7XG4gICAgdGhpcy5sYXllck1hbmFnZXIgPSBudWxsO1xuICAgIHRoaXMuZWZmZWN0TWFuYWdlciA9IG51bGw7XG4gICAgYXV0b2JpbmQodGhpcyk7XG4gIH1cblxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgIHRoaXMuX3VwZGF0ZUxheWVycyhuZXh0UHJvcHMpO1xuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgaWYgKHRoaXMubGF5ZXJNYW5hZ2VyKSB7XG4gICAgICB0aGlzLmxheWVyTWFuYWdlci5maW5hbGl6ZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qIFB1YmxpYyBBUEkgKi9cbiAgcXVlcnlPYmplY3Qoe3gsIHksIHJhZGl1cyA9IDAsIGxheWVySWRzID0gbnVsbH0pIHtcbiAgICBjb25zdCBzZWxlY3RlZEluZm9zID0gdGhpcy5sYXllck1hbmFnZXIucGlja0xheWVyKHt4LCB5LCByYWRpdXMsIGxheWVySWRzLCBtb2RlOiAncXVlcnknfSk7XG4gICAgcmV0dXJuIHNlbGVjdGVkSW5mb3MubGVuZ3RoID8gc2VsZWN0ZWRJbmZvc1swXSA6IG51bGw7XG4gIH1cblxuICBxdWVyeVZpc2libGVPYmplY3RzKHt4LCB5LCB3aWR0aCA9IDEsIGhlaWdodCA9IDEsIGxheWVySWRzID0gbnVsbH0pIHtcbiAgICByZXR1cm4gdGhpcy5sYXllck1hbmFnZXIucXVlcnlMYXllcih7eCwgeSwgd2lkdGgsIGhlaWdodCwgbGF5ZXJJZHN9KTtcbiAgfVxuXG4gIF91cGRhdGVMYXllcnMobmV4dFByb3BzKSB7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBsYXRpdHVkZSxcbiAgICAgIGxvbmdpdHVkZSxcbiAgICAgIHpvb20sXG4gICAgICBwaXRjaCxcbiAgICAgIGJlYXJpbmcsXG4gICAgICBhbHRpdHVkZSxcbiAgICAgIHBpY2tpbmdSYWRpdXMsXG4gICAgICBvbkxheWVyQ2xpY2ssXG4gICAgICBvbkxheWVySG92ZXJcbiAgICB9ID0gbmV4dFByb3BzO1xuXG4gICAgdGhpcy5sYXllck1hbmFnZXIuc2V0RXZlbnRIYW5kbGluZ1BhcmFtZXRlcnMoe1xuICAgICAgcGlja2luZ1JhZGl1cyxcbiAgICAgIG9uTGF5ZXJDbGljayxcbiAgICAgIG9uTGF5ZXJIb3ZlclxuICAgIH0pO1xuXG4gICAgLy8gSWYgVmlld3BvcnQgaXMgbm90IHN1cHBsaWVkLCBjcmVhdGUgb25lIGZyb20gbWVyY2F0b3IgcHJvcHNcbiAgICBsZXQge3ZpZXdwb3J0fSA9IG5leHRQcm9wcztcbiAgICB2aWV3cG9ydCA9IHZpZXdwb3J0IHx8IG5ldyBXZWJNZXJjYXRvclZpZXdwb3J0KHtcbiAgICAgIHdpZHRoLCBoZWlnaHQsIGxhdGl0dWRlLCBsb25naXR1ZGUsIHpvb20sIHBpdGNoLCBiZWFyaW5nLCBhbHRpdHVkZVxuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMubGF5ZXJNYW5hZ2VyKSB7XG4gICAgICB0aGlzLmxheWVyTWFuYWdlclxuICAgICAgICAuc2V0Vmlld3BvcnQodmlld3BvcnQpXG4gICAgICAgIC51cGRhdGVMYXllcnMoe25ld0xheWVyczogbmV4dFByb3BzLmxheWVyc30pO1xuICAgIH1cbiAgfVxuXG4gIF9vblJlbmRlcmVySW5pdGlhbGl6ZWQoe2dsLCBjYW52YXN9KSB7XG4gICAgc2V0UGFyYW1ldGVycyhnbCwge1xuICAgICAgYmxlbmQ6IHRydWUsXG4gICAgICBibGVuZEZ1bmM6IFtHTC5TUkNfQUxQSEEsIEdMLk9ORV9NSU5VU19TUkNfQUxQSEFdLFxuICAgICAgcG9seWdvbk9mZnNldEZpbGw6IHRydWVcbiAgICB9KTtcblxuICAgIC8vIFRPRE8gLSB0aGVzZSB3aWxsIGJlIHNldCBieSBkZWZhdWx0IHN0YXJ0aW5nIGZyb20gbmV4dCBtYWpvciByZWxlYXNlXG4gICAgaWYgKHRoaXMucHJvcHMuaW5pdFdlYkdMUGFyYW1ldGVycykge1xuICAgICAgc2V0UGFyYW1ldGVycyhnbCwge1xuICAgICAgICBkZXB0aFRlc3Q6IHRydWUsXG4gICAgICAgIGRlcHRoRnVuYzogR0wuTEVRVUFMXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCB7cHJvcHN9ID0gdGhpcztcbiAgICBwcm9wcy5vbldlYkdMSW5pdGlhbGl6ZWQoZ2wpO1xuXG4gICAgLy8gTm90ZTogYXZvaWQgUmVhY3Qgc2V0U3RhdGUgZHVlIEdMIGFuaW1hdGlvbiBsb29wIC8gc2V0U3RhdGUgdGltaW5nIGlzc3VlXG4gICAgdGhpcy5sYXllck1hbmFnZXIgPSBuZXcgTGF5ZXJNYW5hZ2VyKHtnbH0pO1xuICAgIHRoaXMubGF5ZXJNYW5hZ2VyLmluaXRFdmVudEhhbmRsaW5nKG5ldyBFdmVudE1hbmFnZXIoY2FudmFzKSk7XG4gICAgdGhpcy5lZmZlY3RNYW5hZ2VyID0gbmV3IEVmZmVjdE1hbmFnZXIoe2dsLCBsYXllck1hbmFnZXI6IHRoaXMubGF5ZXJNYW5hZ2VyfSk7XG5cbiAgICBmb3IgKGNvbnN0IGVmZmVjdCBvZiBwcm9wcy5lZmZlY3RzKSB7XG4gICAgICB0aGlzLmVmZmVjdE1hbmFnZXIuYWRkRWZmZWN0KGVmZmVjdCk7XG4gICAgfVxuXG4gICAgdGhpcy5fdXBkYXRlTGF5ZXJzKHByb3BzKTtcbiAgfVxuXG4gIF9vblJlbmRlckZyYW1lKHtnbH0pIHtcbiAgICBjb25zdCByZWRyYXcgPSB0aGlzLmxheWVyTWFuYWdlci5uZWVkc1JlZHJhdyh7Y2xlYXJSZWRyYXdGbGFnczogdHJ1ZX0pO1xuICAgIGlmICghcmVkcmF3KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gY2xlYXIgZGVwdGggYW5kIGNvbG9yIGJ1ZmZlcnNcbiAgICBnbC5jbGVhcihHTC5DT0xPUl9CVUZGRVJfQklUIHwgR0wuREVQVEhfQlVGRkVSX0JJVCk7XG5cbiAgICB0aGlzLmVmZmVjdE1hbmFnZXIucHJlRHJhdygpO1xuICAgIHRoaXMubGF5ZXJNYW5hZ2VyLmRyYXdMYXllcnMoe3Bhc3M6ICd0byBzY3JlZW4nfSk7XG4gICAgdGhpcy5lZmZlY3RNYW5hZ2VyLmRyYXcoKTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7d2lkdGgsIGhlaWdodCwgZ2wsIGRlYnVnfSA9IHRoaXMucHJvcHM7XG5cbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudChXZWJHTFJlbmRlcmVyLCBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnByb3BzLCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIC8vIE5PVEU6IEFkZCAndXNlRGV2aWNlUGl4ZWxSYXRpbycgdG8gJ3RoaXMucHJvcHMnIGFuZCBhbHNvIHBhc3MgaXQgZG93biB0b1xuICAgICAgLy8gdG8gbW9kdWxlcyB3aGVyZSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyBpcyB1c2VkLlxuICAgICAgdXNlRGV2aWNlUGl4ZWxSYXRpbzogdHJ1ZSxcbiAgICAgIGdsLFxuICAgICAgZGVidWcsXG4gICAgICBvblJlbmRlcmVySW5pdGlhbGl6ZWQ6IHRoaXMuX29uUmVuZGVyZXJJbml0aWFsaXplZCxcbiAgICAgIG9uTmVlZFJlZHJhdzogdGhpcy5fb25OZWVkUmVkcmF3LFxuICAgICAgb25SZW5kZXJGcmFtZTogdGhpcy5fb25SZW5kZXJGcmFtZVxuICAgIH0pKTtcbiAgfVxufVxuXG5EZWNrR0wucHJvcFR5cGVzID0gcHJvcFR5cGVzO1xuRGVja0dMLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcbiJdfQ==