'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

var _luma = require('luma.gl');

var _seer = require('seer');

var _seer2 = _interopRequireDefault(_seer);

var _layer = require('./layer');

var _layer2 = _interopRequireDefault(_layer);

var _utils = require('./utils');

var _flatten = require('./utils/flatten');

var _drawAndPick = require('./draw-and-pick');

var _constants = require('./constants');

var _viewports = require('./viewports');

var _seerIntegration = require('../debug/seer-integration');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var LOG_PRIORITY_LIFECYCLE = 2;
var LOG_PRIORITY_LIFECYCLE_MINOR = 4;

var layerName = function layerName(layer) {
  return layer instanceof _layer2.default ? '' + layer : !layer ? 'null layer' : 'invalid layer';
};

var LayerManager = function () {
  function LayerManager(_ref) {
    var gl = _ref.gl;

    _classCallCheck(this, LayerManager);

    /* Currently deck.gl expects the DeckGL.layers to be different
     whenever React rerenders. If the same layers array is used, the
     LayerManager's diffing algorithm will generate a fatal error and
     break the rendering.
      `this.lastRenderedLayers` stores the UNFILTERED layers sent
     down to LayerManager, so that `layers` reference can be compared.
     If it's the same across two React render calls, the diffing logic
     will be skipped.
    */

    this.lastRenderedLayers = [];

    this.prevLayers = [];
    this.layers = [];
    this.oldContext = {};
    this.screenCleared = false;
    this._needsRedraw = true;

    this._eventManager = null;
    this._pickingRadius = 0;
    this._onLayerClick = null;
    this._onLayerHover = null;
    this._onClick = this._onClick.bind(this);
    this._onPointerMove = this._onPointerMove.bind(this);

    this._initSeer = this._initSeer.bind(this);
    this._editSeer = this._editSeer.bind(this);

    this.context = {
      gl: gl,
      uniforms: {},
      viewport: null,
      viewportChanged: true,
      pickingFBO: null,
      lastPickedInfo: {
        index: -1,
        layerId: null
      },
      shaderCache: new _luma.ShaderCache({ gl: gl })
    };

    (0, _seerIntegration.seerInitListener)(this._initSeer);
    (0, _seerIntegration.layerEditListener)(this._editSeer);

    Object.seal(this.context);
    Object.seal(this);
  }

  // Gets an (optionally) filtered list of layers


  _createClass(LayerManager, [{
    key: 'getLayers',
    value: function getLayers() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$layerIds = _ref2.layerIds,
          layerIds = _ref2$layerIds === undefined ? null : _ref2$layerIds;

      // Filtering by layerId compares beginning of strings, so that sublayers will be included
      // Dependes on the convention of adding suffixes to the parent's layer name
      return layerIds ? this.layers.filter(function (layer) {
        return layerIds.find(function (layerId) {
          return layer.id.indexOf(layerId) === 0;
        });
      }) : this.layers;
    }

    /**
     * Method to call when the layer manager is not needed anymore.
     *
     * Currently used in the <DeckGL> componentWillUnmount lifecycle to unbind Seer listeners.
     */

  }, {
    key: 'finalize',
    value: function finalize() {
      _seer2.default.removeListener(this._initSeer);
      _seer2.default.removeListener(this._editSeer);
    }
  }, {
    key: 'setViewport',
    value: function setViewport(viewport) {
      (0, _assert2.default)(viewport instanceof _viewports.Viewport, 'Invalid viewport');

      // TODO - viewport change detection breaks METER_OFFSETS mode
      // const oldViewport = this.context.viewport;
      // const viewportChanged = !oldViewport || !viewport.equals(oldViewport);

      this._needsRedraw = true;

      var viewportChanged = true;

      if (viewportChanged) {
        Object.assign(this.oldContext, this.context);
        this.context.viewport = viewport;
        this.context.viewportChanged = true;
        this.context.uniforms = {};
        (0, _utils.log)(4, viewport);
      }

      return this;
    }

    /**
     * @param {Object} eventManager   A source of DOM input events
     */

  }, {
    key: 'initEventHandling',
    value: function initEventHandling(eventManager) {
      this._eventManager = eventManager;

      // TODO: add/remove handlers on demand at runtime, not all at once on init.
      // Consider both top-level handlers like onLayerClick/Hover
      // and per-layer handlers attached to individual layers.
      // https://github.com/uber/deck.gl/issues/634
      this._eventManager.on({
        click: this._onClick,
        pointermove: this._onPointerMove
      });
    }

    // Set parameters for input event handling.

  }, {
    key: 'setEventHandlingParameters',
    value: function setEventHandlingParameters(_ref3) {
      var pickingRadius = _ref3.pickingRadius,
          onLayerClick = _ref3.onLayerClick,
          onLayerHover = _ref3.onLayerHover;

      if (!isNaN(pickingRadius)) {
        this._pickingRadius = pickingRadius;
      }
      if (typeof onLayerClick !== 'undefined') {
        this._onLayerClick = onLayerClick;
      }
      if (typeof onLayerHover !== 'undefined') {
        this._onLayerHover = onLayerHover;
      }
      this._validateEventHandling();
    }
  }, {
    key: 'updateLayers',
    value: function updateLayers(_ref4) {
      var newLayers = _ref4.newLayers;

      // TODO - something is generating state updates that cause rerender of the same
      if (newLayers === this.lastRenderedLayers) {
        _utils.log.log(3, 'Ignoring layer update due to layer array not changed');
        return this;
      }
      this.lastRenderedLayers = newLayers;

      (0, _assert2.default)(this.context.viewport, 'LayerManager.updateLayers: viewport not set');

      // Filter out any null layers
      newLayers = newLayers.filter(function (newLayer) {
        return newLayer !== null;
      });

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = newLayers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var layer = _step.value;

          layer.context = this.context;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this.prevLayers = this.layers;

      var _updateLayers2 = this._updateLayers({
        oldLayers: this.prevLayers,
        newLayers: newLayers
      }),
          error = _updateLayers2.error,
          generatedLayers = _updateLayers2.generatedLayers;

      this.layers = generatedLayers;
      // Throw first error found, if any
      if (error) {
        throw error;
      }
      return this;
    }
  }, {
    key: 'drawLayers',
    value: function drawLayers(_ref5) {
      var pass = _ref5.pass;

      (0, _assert2.default)(this.context.viewport, 'LayerManager.drawLayers: viewport not set');

      (0, _drawAndPick.drawLayers)({ layers: this.layers, pass: pass });

      return this;
    }

    // Pick the closest info at given coordinate

  }, {
    key: 'pickLayer',
    value: function pickLayer(_ref6) {
      var x = _ref6.x,
          y = _ref6.y,
          mode = _ref6.mode,
          _ref6$radius = _ref6.radius,
          radius = _ref6$radius === undefined ? 0 : _ref6$radius,
          layerIds = _ref6.layerIds;
      var gl = this.context.gl;


      var layers = this.getLayers({ layerIds: layerIds });

      return (0, _drawAndPick.pickLayers)(gl, {
        x: x,
        y: y,
        radius: radius,
        layers: layers,
        mode: mode,
        viewport: this.context.viewport,
        pickingFBO: this._getPickingBuffer(),
        lastPickedInfo: this.context.lastPickedInfo
      });
    }

    // Get all unique infos within a bounding box

  }, {
    key: 'queryLayer',
    value: function queryLayer(_ref7) {
      var x = _ref7.x,
          y = _ref7.y,
          width = _ref7.width,
          height = _ref7.height,
          layerIds = _ref7.layerIds;
      var gl = this.context.gl;

      var layers = layerIds ? this.layers.filter(function (layer) {
        return layerIds.indexOf(layer.id) >= 0;
      }) : this.layers;

      return (0, _drawAndPick.queryLayers)(gl, {
        x: x,
        y: y,
        width: width,
        height: height,
        layers: layers,
        mode: 'query',
        viewport: this.context.viewport,
        pickingFBO: this._getPickingBuffer()
      });
    }
  }, {
    key: 'needsRedraw',
    value: function needsRedraw() {
      var _ref8 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref8$clearRedrawFlag = _ref8.clearRedrawFlags,
          clearRedrawFlags = _ref8$clearRedrawFlag === undefined ? false : _ref8$clearRedrawFlag;

      if (!this.context.viewport) {
        return false;
      }

      var redraw = this._needsRedraw;
      if (clearRedrawFlags) {
        this._needsRedraw = false;
      }

      // Make sure that buffer is cleared once when layer list becomes empty
      if (this.layers.length === 0) {
        if (this.screenCleared === false) {
          redraw = true;
          this.screenCleared = true;
          return true;
        }
      } else if (this.screenCleared === true) {
        this.screenCleared = false;
      }

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this.layers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var layer = _step2.value;

          redraw = redraw || layer.getNeedsRedraw({ clearRedrawFlags: clearRedrawFlags });
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return redraw;
    }

    //
    // PRIVATE METHODS
    //

  }, {
    key: '_getPickingBuffer',
    value: function _getPickingBuffer() {
      var gl = this.context.gl;

      // Create a frame buffer if not already available

      this.context.pickingFBO = this.context.pickingFBO || new _luma.Framebuffer(gl, {
        width: gl.canvas.width,
        height: gl.canvas.height
      });

      // Resize it to current canvas size (this is a noop if size hasn't changed)
      this.context.pickingFBO.resize({
        width: gl.canvas.width,
        height: gl.canvas.height
      });

      return this.context.pickingFBO;
    }

    // Match all layers, checking for caught errors
    // To avoid having an exception in one layer disrupt other layers

  }, {
    key: '_updateLayers',
    value: function _updateLayers(_ref9) {
      var oldLayers = _ref9.oldLayers,
          newLayers = _ref9.newLayers;

      // Create old layer map
      var oldLayerMap = {};
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = oldLayers[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var oldLayer = _step3.value;

          if (oldLayerMap[oldLayer.id]) {
            _utils.log.once(0, 'Multiple old layers with same id ' + layerName(oldLayer));
          } else {
            oldLayerMap[oldLayer.id] = oldLayer;
            oldLayer.lifecycle = _constants.LIFECYCLE.AWAITING_FINALIZATION;
          }
        }

        // Allocate array for generated layers
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      var generatedLayers = [];

      // Match sublayers
      var error = this._matchSublayers({
        newLayers: newLayers, oldLayerMap: oldLayerMap, generatedLayers: generatedLayers
      });

      var error2 = this._finalizeOldLayers(oldLayers);
      var firstError = error || error2;
      return { error: firstError, generatedLayers: generatedLayers };
    }

    /* eslint-disable max-statements */

  }, {
    key: '_matchSublayers',
    value: function _matchSublayers(_ref10) {
      var _this = this;

      var newLayers = _ref10.newLayers,
          oldLayerMap = _ref10.oldLayerMap,
          generatedLayers = _ref10.generatedLayers;

      // Filter out any null layers
      newLayers = newLayers.filter(function (newLayer) {
        return newLayer !== null;
      });

      var error = null;
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        var _loop = function _loop() {
          var newLayer = _step4.value;

          newLayer.context = _this.context;

          try {
            // 1. given a new coming layer, find its matching layer
            var oldLayer = oldLayerMap[newLayer.id];
            oldLayerMap[newLayer.id] = null;

            if (oldLayer === null) {
              _utils.log.once(0, 'Multiple new layers with same id ' + layerName(newLayer));
            }

            // Only transfer state at this stage. We must not generate exceptions
            // until all layers' state have been transferred
            if (oldLayer) {
              _this._transferLayerState(oldLayer, newLayer);
              _this._updateLayer(newLayer);

              (0, _seerIntegration.updateLayerInSeer)(newLayer); // Initializes layer in seer chrome extension (if connected)
            } else {
              _this._initializeNewLayer(newLayer);

              (0, _seerIntegration.initLayerInSeer)(newLayer); // Initializes layer in seer chrome extension (if connected)
            }
            generatedLayers.push(newLayer);

            // Call layer lifecycle method: render sublayers
            var props = newLayer.props,
                oldProps = newLayer.oldProps;

            var sublayers = newLayer.isComposite ? newLayer._renderLayers({
              oldProps: oldProps,
              props: props,
              context: _this.context,
              oldContext: _this.oldContext,
              changeFlags: newLayer.diffProps(oldProps, props, _this.context)
            }) : null;
            // End layer lifecycle method: render sublayers

            if (sublayers) {
              // Flatten the returned array, removing any null, undefined or false
              // this allows layers to render sublayers conditionally
              // (see CompositeLayer.renderLayers docs)
              sublayers = (0, _flatten.flatten)(sublayers, { filter: Boolean });

              // populate reference to parent layer
              sublayers.forEach(function (layer) {
                layer.parentLayer = newLayer;
              });

              _this._matchSublayers({
                newLayers: sublayers,
                oldLayerMap: oldLayerMap,
                generatedLayers: generatedLayers
              });
            }
          } catch (err) {
            _utils.log.once(0, 'deck.gl error during matching of ' + layerName(newLayer) + ' ' + err, err);
            // Save first error
            error = error || err;
          }
        };

        for (var _iterator4 = newLayers[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          _loop();
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      return error;
    }
  }, {
    key: '_transferLayerState',
    value: function _transferLayerState(oldLayer, newLayer) {
      var state = oldLayer.state,
          props = oldLayer.props;

      // sanity check

      (0, _assert2.default)(state, 'deck.gl sanity check - Matching layer has no state');
      if (newLayer !== oldLayer) {
        (0, _utils.log)(LOG_PRIORITY_LIFECYCLE_MINOR, 'matched ' + layerName(newLayer), oldLayer, '->', newLayer);

        // Move state
        state.layer = newLayer;
        newLayer.state = state;

        // Update model layer reference
        if (state.model) {
          state.model.userData.layer = newLayer;
        }
        // Keep a temporary ref to the old props, for prop comparison
        newLayer.oldProps = props;
        // oldLayer.state = null;

        newLayer.lifecycle = _constants.LIFECYCLE.MATCHED;
        oldLayer.lifecycle = _constants.LIFECYCLE.AWAITING_GC;
      } else {
        _utils.log.log(LOG_PRIORITY_LIFECYCLE_MINOR, 'Matching layer is unchanged ' + newLayer.id);
        newLayer.lifecycle = _constants.LIFECYCLE.MATCHED;
        newLayer.oldProps = newLayer.props;
        // TODO - we could avoid prop comparisons in this case
      }
    }

    // Update the old layers that were not matched

  }, {
    key: '_finalizeOldLayers',
    value: function _finalizeOldLayers(oldLayers) {
      var error = null;
      // Matched layers have lifecycle state "outdated"
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = oldLayers[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var layer = _step5.value;

          if (layer.lifecycle === _constants.LIFECYCLE.AWAITING_FINALIZATION) {
            error = error || this._finalizeLayer(layer);
          }
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      return error;
    }

    // Initializes a single layer, calling layer methods

  }, {
    key: '_initializeNewLayer',
    value: function _initializeNewLayer(layer) {
      var error = null;
      // Check if new layer, and initialize it's state
      if (!layer.state) {
        (0, _utils.log)(LOG_PRIORITY_LIFECYCLE, 'initializing ' + layerName(layer));
        try {

          layer.initializeLayer({
            oldProps: {},
            props: layer.props,
            oldContext: this.oldContext,
            context: this.context,
            changeFlags: layer.diffProps({}, layer.props, this.context)
          });

          layer.lifecycle = _constants.LIFECYCLE.INITIALIZED;
        } catch (err) {
          _utils.log.once(0, 'deck.gl error during initialization of ' + layerName(layer) + ' ' + err, err);
          // Save first error
          error = error || err;
        }
        // Set back pointer (used in picking)
        if (layer.state) {
          layer.state.layer = layer;
          // Save layer on model for picking purposes
          // TODO - store on model.userData rather than directly on model
        }
        if (layer.state && layer.state.model) {
          layer.state.model.userData.layer = layer;
        }
      }
      return error;
    }

    // Updates a single layer, calling layer methods

  }, {
    key: '_updateLayer',
    value: function _updateLayer(layer) {
      var oldProps = layer.oldProps,
          props = layer.props;

      var error = null;
      if (oldProps) {
        try {
          layer.updateLayer({
            oldProps: oldProps,
            props: props,
            context: this.context,
            oldContext: this.oldContext,
            changeFlags: layer.diffProps(oldProps, layer.props, this.context)
          });
        } catch (err) {
          _utils.log.once(0, 'deck.gl error during update of ' + layerName(layer), err);
          // Save first error
          error = err;
        }
        (0, _utils.log)(LOG_PRIORITY_LIFECYCLE_MINOR, 'updating ' + layerName(layer));
      }
      return error;
    }

    // Finalizes a single layer

  }, {
    key: '_finalizeLayer',
    value: function _finalizeLayer(layer) {
      var error = null;
      var state = layer.state;

      if (state) {
        try {
          layer.finalizeLayer();
        } catch (err) {
          _utils.log.once(0, 'deck.gl error during finalization of ' + layerName(layer), err);
          // Save first error
          error = err;
        }
        // layer.state = null;
        layer.lifecycle = _constants.LIFECYCLE.FINALIZED;
        (0, _utils.log)(LOG_PRIORITY_LIFECYCLE, 'finalizing ' + layerName(layer));
      }
      return error;
    }

    /**
     * Warn if a deck-level mouse event has been specified,
     * but no layers are `pickable`.
     */

  }, {
    key: '_validateEventHandling',
    value: function _validateEventHandling() {
      if (this.onLayerClick || this.onLayerHover) {
        if (this.layers.length && !this.layers.some(function (layer) {
          return layer.props.pickable;
        })) {
          _utils.log.once(1, 'You have supplied a top-level input event handler (e.g. `onLayerClick`), ' + 'but none of your layers have set the `pickable` flag.');
        }
      }
    }

    /**
     * Route click events to layers.
     * `pickLayer` will call the `onClick` prop of any picked layer,
     * and `onLayerClick` is called directly from here
     * with any picking info generated by `pickLayer`.
     * @param {Object} event  An object encapsulating an input event,
     *                        with the following shape:
     *                        {Object: {x, y}} offsetCenter: center of the event
     *                        {Object} srcEvent:             native JS Event object
     */

  }, {
    key: '_onClick',
    value: function _onClick(event) {
      var pos = event.offsetCenter;
      if (!pos) {
        return;
      }
      var selectedInfos = this.pickLayer({
        x: pos.x,
        y: pos.y,
        radius: this._pickingRadius,
        mode: 'click'
      });
      if (selectedInfos.length) {
        var firstInfo = selectedInfos.find(function (info) {
          return info.index >= 0;
        });
        if (this._onLayerClick) {
          this._onLayerClick(firstInfo, selectedInfos, event.srcEvent);
        }
      }
    }

    /**
     * Route click events to layers.
     * `pickLayer` will call the `onHover` prop of any picked layer,
     * and `onLayerHover` is called directly from here
     * with any picking info generated by `pickLayer`.
     * @param {Object} event  An object encapsulating an input event,
     *                        with the following shape:
     *                        {Object: {x, y}} offsetCenter: center of the event
     *                        {Object} srcEvent:             native JS Event object
     */

  }, {
    key: '_onPointerMove',
    value: function _onPointerMove(event) {
      if (event.isDown) {
        // Do not trigger onHover callbacks if mouse button is down
        return;
      }
      var pos = event.offsetCenter;
      // TODO: consider using this.eventManager.element size instead of layerManager.context
      // but do so in a way that doesn't cause reflow (e.g. `offsetWidth/Height`).
      // maybe the event object offers offsetCenter as a 0<>1 value as well?
      // since it's already doing size calculations...
      var _context$viewport = this.context.viewport,
          width = _context$viewport.width,
          height = _context$viewport.height;

      if (!pos || pos.x < 0 || pos.y < 0 || pos.x > width || pos.y > height) {
        // Check if pointer is inside the canvas
        return;
      }
      var selectedInfos = this.pickLayer({
        x: pos.x,
        y: pos.y,
        radius: this._pickingRadius,
        mode: 'hover'
      });
      if (selectedInfos.length) {
        var firstInfo = selectedInfos.find(function (info) {
          return info.index >= 0;
        });
        if (this._onLayerHover) {
          this._onLayerHover(firstInfo, selectedInfos, event.srcEvent);
        }
      }
    }

    // SEER INTEGRATION

    /**
     * Called upon Seer initialization, manually sends layers data.
     */

  }, {
    key: '_initSeer',
    value: function _initSeer() {
      this.layers.forEach(function (layer) {
        (0, _seerIntegration.initLayerInSeer)(layer);
        (0, _seerIntegration.updateLayerInSeer)(layer);
      });
    }

    /**
     * On Seer property edition, set override and update layers.
     */

  }, {
    key: '_editSeer',
    value: function _editSeer(payload) {
      if (payload.type !== 'edit' || payload.valuePath[0] !== 'props') {
        return;
      }

      (0, _seerIntegration.setPropOverrides)(payload.itemKey, payload.valuePath.slice(1), payload.value);
      var newLayers = this.layers.map(function (layer) {
        return new layer.constructor(layer.props);
      });
      this.updateLayers({ newLayers: newLayers });
    }
  }]);

  return LayerManager;
}();

exports.default = LayerManager;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvbGF5ZXItbWFuYWdlci5qcyJdLCJuYW1lcyI6WyJMT0dfUFJJT1JJVFlfTElGRUNZQ0xFIiwiTE9HX1BSSU9SSVRZX0xJRkVDWUNMRV9NSU5PUiIsImxheWVyTmFtZSIsImxheWVyIiwiTGF5ZXJNYW5hZ2VyIiwiZ2wiLCJsYXN0UmVuZGVyZWRMYXllcnMiLCJwcmV2TGF5ZXJzIiwibGF5ZXJzIiwib2xkQ29udGV4dCIsInNjcmVlbkNsZWFyZWQiLCJfbmVlZHNSZWRyYXciLCJfZXZlbnRNYW5hZ2VyIiwiX3BpY2tpbmdSYWRpdXMiLCJfb25MYXllckNsaWNrIiwiX29uTGF5ZXJIb3ZlciIsIl9vbkNsaWNrIiwiYmluZCIsIl9vblBvaW50ZXJNb3ZlIiwiX2luaXRTZWVyIiwiX2VkaXRTZWVyIiwiY29udGV4dCIsInVuaWZvcm1zIiwidmlld3BvcnQiLCJ2aWV3cG9ydENoYW5nZWQiLCJwaWNraW5nRkJPIiwibGFzdFBpY2tlZEluZm8iLCJpbmRleCIsImxheWVySWQiLCJzaGFkZXJDYWNoZSIsIk9iamVjdCIsInNlYWwiLCJsYXllcklkcyIsImZpbHRlciIsImZpbmQiLCJpZCIsImluZGV4T2YiLCJyZW1vdmVMaXN0ZW5lciIsImFzc2lnbiIsImV2ZW50TWFuYWdlciIsIm9uIiwiY2xpY2siLCJwb2ludGVybW92ZSIsInBpY2tpbmdSYWRpdXMiLCJvbkxheWVyQ2xpY2siLCJvbkxheWVySG92ZXIiLCJpc05hTiIsIl92YWxpZGF0ZUV2ZW50SGFuZGxpbmciLCJuZXdMYXllcnMiLCJsb2ciLCJuZXdMYXllciIsIl91cGRhdGVMYXllcnMiLCJvbGRMYXllcnMiLCJlcnJvciIsImdlbmVyYXRlZExheWVycyIsInBhc3MiLCJ4IiwieSIsIm1vZGUiLCJyYWRpdXMiLCJnZXRMYXllcnMiLCJfZ2V0UGlja2luZ0J1ZmZlciIsIndpZHRoIiwiaGVpZ2h0IiwiY2xlYXJSZWRyYXdGbGFncyIsInJlZHJhdyIsImxlbmd0aCIsImdldE5lZWRzUmVkcmF3IiwiY2FudmFzIiwicmVzaXplIiwib2xkTGF5ZXJNYXAiLCJvbGRMYXllciIsIm9uY2UiLCJsaWZlY3ljbGUiLCJBV0FJVElOR19GSU5BTElaQVRJT04iLCJfbWF0Y2hTdWJsYXllcnMiLCJlcnJvcjIiLCJfZmluYWxpemVPbGRMYXllcnMiLCJmaXJzdEVycm9yIiwiX3RyYW5zZmVyTGF5ZXJTdGF0ZSIsIl91cGRhdGVMYXllciIsIl9pbml0aWFsaXplTmV3TGF5ZXIiLCJwdXNoIiwicHJvcHMiLCJvbGRQcm9wcyIsInN1YmxheWVycyIsImlzQ29tcG9zaXRlIiwiX3JlbmRlckxheWVycyIsImNoYW5nZUZsYWdzIiwiZGlmZlByb3BzIiwiQm9vbGVhbiIsImZvckVhY2giLCJwYXJlbnRMYXllciIsImVyciIsInN0YXRlIiwibW9kZWwiLCJ1c2VyRGF0YSIsIk1BVENIRUQiLCJBV0FJVElOR19HQyIsIl9maW5hbGl6ZUxheWVyIiwiaW5pdGlhbGl6ZUxheWVyIiwiSU5JVElBTElaRUQiLCJ1cGRhdGVMYXllciIsImZpbmFsaXplTGF5ZXIiLCJGSU5BTElaRUQiLCJzb21lIiwicGlja2FibGUiLCJldmVudCIsInBvcyIsIm9mZnNldENlbnRlciIsInNlbGVjdGVkSW5mb3MiLCJwaWNrTGF5ZXIiLCJmaXJzdEluZm8iLCJpbmZvIiwic3JjRXZlbnQiLCJpc0Rvd24iLCJwYXlsb2FkIiwidHlwZSIsInZhbHVlUGF0aCIsIml0ZW1LZXkiLCJzbGljZSIsInZhbHVlIiwibWFwIiwiY29uc3RydWN0b3IiLCJ1cGRhdGVMYXllcnMiXSwibWFwcGluZ3MiOiI7Ozs7OztxakJBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFDQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7OztBQVFBLElBQU1BLHlCQUF5QixD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LFdBQUt5QyxZQUFMLENBQWtCLEVBQUM1RSxvQkFBRCxFQUFsQjtBQUNEOzs7Ozs7a0JBcmtCa0I1QyxZIiwiZmlsZSI6ImxheWVyLW1hbmFnZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuaW1wb3J0IHtGcmFtZWJ1ZmZlciwgU2hhZGVyQ2FjaGV9IGZyb20gJ2x1bWEuZ2wnO1xuaW1wb3J0IHNlZXIgZnJvbSAnc2Vlcic7XG5pbXBvcnQgTGF5ZXIgZnJvbSAnLi9sYXllcic7XG5pbXBvcnQge2xvZ30gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQge2ZsYXR0ZW59IGZyb20gJy4vdXRpbHMvZmxhdHRlbic7XG5pbXBvcnQge2RyYXdMYXllcnMsIHBpY2tMYXllcnMsIHF1ZXJ5TGF5ZXJzfSBmcm9tICcuL2RyYXctYW5kLXBpY2snO1xuaW1wb3J0IHtMSUZFQ1lDTEV9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7Vmlld3BvcnR9IGZyb20gJy4vdmlld3BvcnRzJztcbmltcG9ydCB7XG4gIHNldFByb3BPdmVycmlkZXMsXG4gIGxheWVyRWRpdExpc3RlbmVyLFxuICBzZWVySW5pdExpc3RlbmVyLFxuICBpbml0TGF5ZXJJblNlZXIsXG4gIHVwZGF0ZUxheWVySW5TZWVyXG59IGZyb20gJy4uL2RlYnVnL3NlZXItaW50ZWdyYXRpb24nO1xuXG5jb25zdCBMT0dfUFJJT1JJVFlfTElGRUNZQ0xFID0gMjtcbmNvbnN0IExPR19QUklPUklUWV9MSUZFQ1lDTEVfTUlOT1IgPSA0O1xuXG5jb25zdCBsYXllck5hbWUgPSBsYXllciA9PiBsYXllciBpbnN0YW5jZW9mIExheWVyID9cbiAgYCR7bGF5ZXJ9YCA6XG4gICghbGF5ZXIgPyAnbnVsbCBsYXllcicgOiAnaW52YWxpZCBsYXllcicpO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMYXllck1hbmFnZXIge1xuICBjb25zdHJ1Y3Rvcih7Z2x9KSB7XG4gICAgLyogQ3VycmVudGx5IGRlY2suZ2wgZXhwZWN0cyB0aGUgRGVja0dMLmxheWVycyB0byBiZSBkaWZmZXJlbnRcbiAgICAgd2hlbmV2ZXIgUmVhY3QgcmVyZW5kZXJzLiBJZiB0aGUgc2FtZSBsYXllcnMgYXJyYXkgaXMgdXNlZCwgdGhlXG4gICAgIExheWVyTWFuYWdlcidzIGRpZmZpbmcgYWxnb3JpdGhtIHdpbGwgZ2VuZXJhdGUgYSBmYXRhbCBlcnJvciBhbmRcbiAgICAgYnJlYWsgdGhlIHJlbmRlcmluZy5cblxuICAgICBgdGhpcy5sYXN0UmVuZGVyZWRMYXllcnNgIHN0b3JlcyB0aGUgVU5GSUxURVJFRCBsYXllcnMgc2VudFxuICAgICBkb3duIHRvIExheWVyTWFuYWdlciwgc28gdGhhdCBgbGF5ZXJzYCByZWZlcmVuY2UgY2FuIGJlIGNvbXBhcmVkLlxuICAgICBJZiBpdCdzIHRoZSBzYW1lIGFjcm9zcyB0d28gUmVhY3QgcmVuZGVyIGNhbGxzLCB0aGUgZGlmZmluZyBsb2dpY1xuICAgICB3aWxsIGJlIHNraXBwZWQuXG4gICAgKi9cblxuICAgIHRoaXMubGFzdFJlbmRlcmVkTGF5ZXJzID0gW107XG5cbiAgICB0aGlzLnByZXZMYXllcnMgPSBbXTtcbiAgICB0aGlzLmxheWVycyA9IFtdO1xuICAgIHRoaXMub2xkQ29udGV4dCA9IHt9O1xuICAgIHRoaXMuc2NyZWVuQ2xlYXJlZCA9IGZhbHNlO1xuICAgIHRoaXMuX25lZWRzUmVkcmF3ID0gdHJ1ZTtcblxuICAgIHRoaXMuX2V2ZW50TWFuYWdlciA9IG51bGw7XG4gICAgdGhpcy5fcGlja2luZ1JhZGl1cyA9IDA7XG4gICAgdGhpcy5fb25MYXllckNsaWNrID0gbnVsbDtcbiAgICB0aGlzLl9vbkxheWVySG92ZXIgPSBudWxsO1xuICAgIHRoaXMuX29uQ2xpY2sgPSB0aGlzLl9vbkNsaWNrLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25Qb2ludGVyTW92ZSA9IHRoaXMuX29uUG9pbnRlck1vdmUuYmluZCh0aGlzKTtcblxuICAgIHRoaXMuX2luaXRTZWVyID0gdGhpcy5faW5pdFNlZXIuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9lZGl0U2VlciA9IHRoaXMuX2VkaXRTZWVyLmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLmNvbnRleHQgPSB7XG4gICAgICBnbCxcbiAgICAgIHVuaWZvcm1zOiB7fSxcbiAgICAgIHZpZXdwb3J0OiBudWxsLFxuICAgICAgdmlld3BvcnRDaGFuZ2VkOiB0cnVlLFxuICAgICAgcGlja2luZ0ZCTzogbnVsbCxcbiAgICAgIGxhc3RQaWNrZWRJbmZvOiB7XG4gICAgICAgIGluZGV4OiAtMSxcbiAgICAgICAgbGF5ZXJJZDogbnVsbFxuICAgICAgfSxcbiAgICAgIHNoYWRlckNhY2hlOiBuZXcgU2hhZGVyQ2FjaGUoe2dsfSlcbiAgICB9O1xuXG4gICAgc2VlckluaXRMaXN0ZW5lcih0aGlzLl9pbml0U2Vlcik7XG4gICAgbGF5ZXJFZGl0TGlzdGVuZXIodGhpcy5fZWRpdFNlZXIpO1xuXG4gICAgT2JqZWN0LnNlYWwodGhpcy5jb250ZXh0KTtcbiAgICBPYmplY3Quc2VhbCh0aGlzKTtcbiAgfVxuXG4gIC8vIEdldHMgYW4gKG9wdGlvbmFsbHkpIGZpbHRlcmVkIGxpc3Qgb2YgbGF5ZXJzXG4gIGdldExheWVycyh7bGF5ZXJJZHMgPSBudWxsfSA9IHt9KSB7XG4gICAgLy8gRmlsdGVyaW5nIGJ5IGxheWVySWQgY29tcGFyZXMgYmVnaW5uaW5nIG9mIHN0cmluZ3MsIHNvIHRoYXQgc3VibGF5ZXJzIHdpbGwgYmUgaW5jbHVkZWRcbiAgICAvLyBEZXBlbmRlcyBvbiB0aGUgY29udmVudGlvbiBvZiBhZGRpbmcgc3VmZml4ZXMgdG8gdGhlIHBhcmVudCdzIGxheWVyIG5hbWVcbiAgICByZXR1cm4gbGF5ZXJJZHMgP1xuICAgICAgdGhpcy5sYXllcnMuZmlsdGVyKGxheWVyID0+IGxheWVySWRzLmZpbmQobGF5ZXJJZCA9PiBsYXllci5pZC5pbmRleE9mKGxheWVySWQpID09PSAwKSkgOlxuICAgICAgdGhpcy5sYXllcnM7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHRvIGNhbGwgd2hlbiB0aGUgbGF5ZXIgbWFuYWdlciBpcyBub3QgbmVlZGVkIGFueW1vcmUuXG4gICAqXG4gICAqIEN1cnJlbnRseSB1c2VkIGluIHRoZSA8RGVja0dMPiBjb21wb25lbnRXaWxsVW5tb3VudCBsaWZlY3ljbGUgdG8gdW5iaW5kIFNlZXIgbGlzdGVuZXJzLlxuICAgKi9cbiAgZmluYWxpemUoKSB7XG4gICAgc2Vlci5yZW1vdmVMaXN0ZW5lcih0aGlzLl9pbml0U2Vlcik7XG4gICAgc2Vlci5yZW1vdmVMaXN0ZW5lcih0aGlzLl9lZGl0U2Vlcik7XG4gIH1cblxuICBzZXRWaWV3cG9ydCh2aWV3cG9ydCkge1xuICAgIGFzc2VydCh2aWV3cG9ydCBpbnN0YW5jZW9mIFZpZXdwb3J0LCAnSW52YWxpZCB2aWV3cG9ydCcpO1xuXG4gICAgLy8gVE9ETyAtIHZpZXdwb3J0IGNoYW5nZSBkZXRlY3Rpb24gYnJlYWtzIE1FVEVSX09GRlNFVFMgbW9kZVxuICAgIC8vIGNvbnN0IG9sZFZpZXdwb3J0ID0gdGhpcy5jb250ZXh0LnZpZXdwb3J0O1xuICAgIC8vIGNvbnN0IHZpZXdwb3J0Q2hhbmdlZCA9ICFvbGRWaWV3cG9ydCB8fCAhdmlld3BvcnQuZXF1YWxzKG9sZFZpZXdwb3J0KTtcblxuICAgIHRoaXMuX25lZWRzUmVkcmF3ID0gdHJ1ZTtcblxuICAgIGNvbnN0IHZpZXdwb3J0Q2hhbmdlZCA9IHRydWU7XG5cbiAgICBpZiAodmlld3BvcnRDaGFuZ2VkKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMub2xkQ29udGV4dCwgdGhpcy5jb250ZXh0KTtcbiAgICAgIHRoaXMuY29udGV4dC52aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgICAgdGhpcy5jb250ZXh0LnZpZXdwb3J0Q2hhbmdlZCA9IHRydWU7XG4gICAgICB0aGlzLmNvbnRleHQudW5pZm9ybXMgPSB7fTtcbiAgICAgIGxvZyg0LCB2aWV3cG9ydCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50TWFuYWdlciAgIEEgc291cmNlIG9mIERPTSBpbnB1dCBldmVudHNcbiAgICovXG4gIGluaXRFdmVudEhhbmRsaW5nKGV2ZW50TWFuYWdlcikge1xuICAgIHRoaXMuX2V2ZW50TWFuYWdlciA9IGV2ZW50TWFuYWdlcjtcblxuICAgIC8vIFRPRE86IGFkZC9yZW1vdmUgaGFuZGxlcnMgb24gZGVtYW5kIGF0IHJ1bnRpbWUsIG5vdCBhbGwgYXQgb25jZSBvbiBpbml0LlxuICAgIC8vIENvbnNpZGVyIGJvdGggdG9wLWxldmVsIGhhbmRsZXJzIGxpa2Ugb25MYXllckNsaWNrL0hvdmVyXG4gICAgLy8gYW5kIHBlci1sYXllciBoYW5kbGVycyBhdHRhY2hlZCB0byBpbmRpdmlkdWFsIGxheWVycy5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdWJlci9kZWNrLmdsL2lzc3Vlcy82MzRcbiAgICB0aGlzLl9ldmVudE1hbmFnZXIub24oe1xuICAgICAgY2xpY2s6IHRoaXMuX29uQ2xpY2ssXG4gICAgICBwb2ludGVybW92ZTogdGhpcy5fb25Qb2ludGVyTW92ZVxuICAgIH0pO1xuICB9XG5cbiAgLy8gU2V0IHBhcmFtZXRlcnMgZm9yIGlucHV0IGV2ZW50IGhhbmRsaW5nLlxuICBzZXRFdmVudEhhbmRsaW5nUGFyYW1ldGVycyh7XG4gICAgcGlja2luZ1JhZGl1cyxcbiAgICBvbkxheWVyQ2xpY2ssXG4gICAgb25MYXllckhvdmVyXG4gIH0pIHtcbiAgICBpZiAoIWlzTmFOKHBpY2tpbmdSYWRpdXMpKSB7XG4gICAgICB0aGlzLl9waWNraW5nUmFkaXVzID0gcGlja2luZ1JhZGl1cztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvbkxheWVyQ2xpY2sgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLl9vbkxheWVyQ2xpY2sgPSBvbkxheWVyQ2xpY2s7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb25MYXllckhvdmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5fb25MYXllckhvdmVyID0gb25MYXllckhvdmVyO1xuICAgIH1cbiAgICB0aGlzLl92YWxpZGF0ZUV2ZW50SGFuZGxpbmcoKTtcbiAgfVxuXG4gIHVwZGF0ZUxheWVycyh7bmV3TGF5ZXJzfSkge1xuICAgIC8vIFRPRE8gLSBzb21ldGhpbmcgaXMgZ2VuZXJhdGluZyBzdGF0ZSB1cGRhdGVzIHRoYXQgY2F1c2UgcmVyZW5kZXIgb2YgdGhlIHNhbWVcbiAgICBpZiAobmV3TGF5ZXJzID09PSB0aGlzLmxhc3RSZW5kZXJlZExheWVycykge1xuICAgICAgbG9nLmxvZygzLCAnSWdub3JpbmcgbGF5ZXIgdXBkYXRlIGR1ZSB0byBsYXllciBhcnJheSBub3QgY2hhbmdlZCcpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRoaXMubGFzdFJlbmRlcmVkTGF5ZXJzID0gbmV3TGF5ZXJzO1xuXG4gICAgYXNzZXJ0KHRoaXMuY29udGV4dC52aWV3cG9ydCwgJ0xheWVyTWFuYWdlci51cGRhdGVMYXllcnM6IHZpZXdwb3J0IG5vdCBzZXQnKTtcblxuICAgIC8vIEZpbHRlciBvdXQgYW55IG51bGwgbGF5ZXJzXG4gICAgbmV3TGF5ZXJzID0gbmV3TGF5ZXJzLmZpbHRlcihuZXdMYXllciA9PiBuZXdMYXllciAhPT0gbnVsbCk7XG5cbiAgICBmb3IgKGNvbnN0IGxheWVyIG9mIG5ld0xheWVycykge1xuICAgICAgbGF5ZXIuY29udGV4dCA9IHRoaXMuY29udGV4dDtcbiAgICB9XG5cbiAgICB0aGlzLnByZXZMYXllcnMgPSB0aGlzLmxheWVycztcbiAgICBjb25zdCB7ZXJyb3IsIGdlbmVyYXRlZExheWVyc30gPSB0aGlzLl91cGRhdGVMYXllcnMoe1xuICAgICAgb2xkTGF5ZXJzOiB0aGlzLnByZXZMYXllcnMsXG4gICAgICBuZXdMYXllcnNcbiAgICB9KTtcblxuICAgIHRoaXMubGF5ZXJzID0gZ2VuZXJhdGVkTGF5ZXJzO1xuICAgIC8vIFRocm93IGZpcnN0IGVycm9yIGZvdW5kLCBpZiBhbnlcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGRyYXdMYXllcnMoe3Bhc3N9KSB7XG4gICAgYXNzZXJ0KHRoaXMuY29udGV4dC52aWV3cG9ydCwgJ0xheWVyTWFuYWdlci5kcmF3TGF5ZXJzOiB2aWV3cG9ydCBub3Qgc2V0Jyk7XG5cbiAgICBkcmF3TGF5ZXJzKHtsYXllcnM6IHRoaXMubGF5ZXJzLCBwYXNzfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIFBpY2sgdGhlIGNsb3Nlc3QgaW5mbyBhdCBnaXZlbiBjb29yZGluYXRlXG4gIHBpY2tMYXllcih7eCwgeSwgbW9kZSwgcmFkaXVzID0gMCwgbGF5ZXJJZHN9KSB7XG4gICAgY29uc3Qge2dsfSA9IHRoaXMuY29udGV4dDtcblxuICAgIGNvbnN0IGxheWVycyA9IHRoaXMuZ2V0TGF5ZXJzKHtsYXllcklkc30pO1xuXG4gICAgcmV0dXJuIHBpY2tMYXllcnMoZ2wsIHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgcmFkaXVzLFxuICAgICAgbGF5ZXJzLFxuICAgICAgbW9kZSxcbiAgICAgIHZpZXdwb3J0OiB0aGlzLmNvbnRleHQudmlld3BvcnQsXG4gICAgICBwaWNraW5nRkJPOiB0aGlzLl9nZXRQaWNraW5nQnVmZmVyKCksXG4gICAgICBsYXN0UGlja2VkSW5mbzogdGhpcy5jb250ZXh0Lmxhc3RQaWNrZWRJbmZvXG4gICAgfSk7XG4gIH1cblxuICAvLyBHZXQgYWxsIHVuaXF1ZSBpbmZvcyB3aXRoaW4gYSBib3VuZGluZyBib3hcbiAgcXVlcnlMYXllcih7eCwgeSwgd2lkdGgsIGhlaWdodCwgbGF5ZXJJZHN9KSB7XG4gICAgY29uc3Qge2dsfSA9IHRoaXMuY29udGV4dDtcbiAgICBjb25zdCBsYXllcnMgPSBsYXllcklkcyA/XG4gICAgICB0aGlzLmxheWVycy5maWx0ZXIobGF5ZXIgPT4gbGF5ZXJJZHMuaW5kZXhPZihsYXllci5pZCkgPj0gMCkgOlxuICAgICAgdGhpcy5sYXllcnM7XG5cbiAgICByZXR1cm4gcXVlcnlMYXllcnMoZ2wsIHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBsYXllcnMsXG4gICAgICBtb2RlOiAncXVlcnknLFxuICAgICAgdmlld3BvcnQ6IHRoaXMuY29udGV4dC52aWV3cG9ydCxcbiAgICAgIHBpY2tpbmdGQk86IHRoaXMuX2dldFBpY2tpbmdCdWZmZXIoKVxuICAgIH0pO1xuICB9XG5cbiAgbmVlZHNSZWRyYXcoe2NsZWFyUmVkcmF3RmxhZ3MgPSBmYWxzZX0gPSB7fSkge1xuICAgIGlmICghdGhpcy5jb250ZXh0LnZpZXdwb3J0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IHJlZHJhdyA9IHRoaXMuX25lZWRzUmVkcmF3O1xuICAgIGlmIChjbGVhclJlZHJhd0ZsYWdzKSB7XG4gICAgICB0aGlzLl9uZWVkc1JlZHJhdyA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpcyBjbGVhcmVkIG9uY2Ugd2hlbiBsYXllciBsaXN0IGJlY29tZXMgZW1wdHlcbiAgICBpZiAodGhpcy5sYXllcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAodGhpcy5zY3JlZW5DbGVhcmVkID09PSBmYWxzZSkge1xuICAgICAgICByZWRyYXcgPSB0cnVlO1xuICAgICAgICB0aGlzLnNjcmVlbkNsZWFyZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuc2NyZWVuQ2xlYXJlZCA9PT0gdHJ1ZSkge1xuICAgICAgdGhpcy5zY3JlZW5DbGVhcmVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLmxheWVycykge1xuICAgICAgcmVkcmF3ID0gcmVkcmF3IHx8IGxheWVyLmdldE5lZWRzUmVkcmF3KHtjbGVhclJlZHJhd0ZsYWdzfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlZHJhdztcbiAgfVxuXG4gIC8vXG4gIC8vIFBSSVZBVEUgTUVUSE9EU1xuICAvL1xuXG4gIF9nZXRQaWNraW5nQnVmZmVyKCkge1xuICAgIGNvbnN0IHtnbH0gPSB0aGlzLmNvbnRleHQ7XG5cbiAgICAvLyBDcmVhdGUgYSBmcmFtZSBidWZmZXIgaWYgbm90IGFscmVhZHkgYXZhaWxhYmxlXG4gICAgdGhpcy5jb250ZXh0LnBpY2tpbmdGQk8gPSB0aGlzLmNvbnRleHQucGlja2luZ0ZCTyB8fCBuZXcgRnJhbWVidWZmZXIoZ2wsIHtcbiAgICAgIHdpZHRoOiBnbC5jYW52YXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IGdsLmNhbnZhcy5oZWlnaHRcbiAgICB9KTtcblxuICAgIC8vIFJlc2l6ZSBpdCB0byBjdXJyZW50IGNhbnZhcyBzaXplICh0aGlzIGlzIGEgbm9vcCBpZiBzaXplIGhhc24ndCBjaGFuZ2VkKVxuICAgIHRoaXMuY29udGV4dC5waWNraW5nRkJPLnJlc2l6ZSh7XG4gICAgICB3aWR0aDogZ2wuY2FudmFzLndpZHRoLFxuICAgICAgaGVpZ2h0OiBnbC5jYW52YXMuaGVpZ2h0XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcy5jb250ZXh0LnBpY2tpbmdGQk87XG4gIH1cblxuICAvLyBNYXRjaCBhbGwgbGF5ZXJzLCBjaGVja2luZyBmb3IgY2F1Z2h0IGVycm9yc1xuICAvLyBUbyBhdm9pZCBoYXZpbmcgYW4gZXhjZXB0aW9uIGluIG9uZSBsYXllciBkaXNydXB0IG90aGVyIGxheWVyc1xuICBfdXBkYXRlTGF5ZXJzKHtvbGRMYXllcnMsIG5ld0xheWVyc30pIHtcbiAgICAvLyBDcmVhdGUgb2xkIGxheWVyIG1hcFxuICAgIGNvbnN0IG9sZExheWVyTWFwID0ge307XG4gICAgZm9yIChjb25zdCBvbGRMYXllciBvZiBvbGRMYXllcnMpIHtcbiAgICAgIGlmIChvbGRMYXllck1hcFtvbGRMYXllci5pZF0pIHtcbiAgICAgICAgbG9nLm9uY2UoMCwgYE11bHRpcGxlIG9sZCBsYXllcnMgd2l0aCBzYW1lIGlkICR7bGF5ZXJOYW1lKG9sZExheWVyKX1gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9sZExheWVyTWFwW29sZExheWVyLmlkXSA9IG9sZExheWVyO1xuICAgICAgICBvbGRMYXllci5saWZlY3ljbGUgPSBMSUZFQ1lDTEUuQVdBSVRJTkdfRklOQUxJWkFUSU9OO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFsbG9jYXRlIGFycmF5IGZvciBnZW5lcmF0ZWQgbGF5ZXJzXG4gICAgY29uc3QgZ2VuZXJhdGVkTGF5ZXJzID0gW107XG5cbiAgICAvLyBNYXRjaCBzdWJsYXllcnNcbiAgICBjb25zdCBlcnJvciA9IHRoaXMuX21hdGNoU3VibGF5ZXJzKHtcbiAgICAgIG5ld0xheWVycywgb2xkTGF5ZXJNYXAsIGdlbmVyYXRlZExheWVyc1xuICAgIH0pO1xuXG4gICAgY29uc3QgZXJyb3IyID0gdGhpcy5fZmluYWxpemVPbGRMYXllcnMob2xkTGF5ZXJzKTtcbiAgICBjb25zdCBmaXJzdEVycm9yID0gZXJyb3IgfHwgZXJyb3IyO1xuICAgIHJldHVybiB7ZXJyb3I6IGZpcnN0RXJyb3IsIGdlbmVyYXRlZExheWVyc307XG4gIH1cblxuICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtc3RhdGVtZW50cyAqL1xuXG4gIF9tYXRjaFN1YmxheWVycyh7bmV3TGF5ZXJzLCBvbGRMYXllck1hcCwgZ2VuZXJhdGVkTGF5ZXJzfSkge1xuICAgIC8vIEZpbHRlciBvdXQgYW55IG51bGwgbGF5ZXJzXG4gICAgbmV3TGF5ZXJzID0gbmV3TGF5ZXJzLmZpbHRlcihuZXdMYXllciA9PiBuZXdMYXllciAhPT0gbnVsbCk7XG5cbiAgICBsZXQgZXJyb3IgPSBudWxsO1xuICAgIGZvciAoY29uc3QgbmV3TGF5ZXIgb2YgbmV3TGF5ZXJzKSB7XG4gICAgICBuZXdMYXllci5jb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuXG4gICAgICB0cnkge1xuICAgICAgICAvLyAxLiBnaXZlbiBhIG5ldyBjb21pbmcgbGF5ZXIsIGZpbmQgaXRzIG1hdGNoaW5nIGxheWVyXG4gICAgICAgIGNvbnN0IG9sZExheWVyID0gb2xkTGF5ZXJNYXBbbmV3TGF5ZXIuaWRdO1xuICAgICAgICBvbGRMYXllck1hcFtuZXdMYXllci5pZF0gPSBudWxsO1xuXG4gICAgICAgIGlmIChvbGRMYXllciA9PT0gbnVsbCkge1xuICAgICAgICAgIGxvZy5vbmNlKDAsIGBNdWx0aXBsZSBuZXcgbGF5ZXJzIHdpdGggc2FtZSBpZCAke2xheWVyTmFtZShuZXdMYXllcil9YCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPbmx5IHRyYW5zZmVyIHN0YXRlIGF0IHRoaXMgc3RhZ2UuIFdlIG11c3Qgbm90IGdlbmVyYXRlIGV4Y2VwdGlvbnNcbiAgICAgICAgLy8gdW50aWwgYWxsIGxheWVycycgc3RhdGUgaGF2ZSBiZWVuIHRyYW5zZmVycmVkXG4gICAgICAgIGlmIChvbGRMYXllcikge1xuICAgICAgICAgIHRoaXMuX3RyYW5zZmVyTGF5ZXJTdGF0ZShvbGRMYXllciwgbmV3TGF5ZXIpO1xuICAgICAgICAgIHRoaXMuX3VwZGF0ZUxheWVyKG5ld0xheWVyKTtcblxuICAgICAgICAgIHVwZGF0ZUxheWVySW5TZWVyKG5ld0xheWVyKTsgLy8gSW5pdGlhbGl6ZXMgbGF5ZXIgaW4gc2VlciBjaHJvbWUgZXh0ZW5zaW9uIChpZiBjb25uZWN0ZWQpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZU5ld0xheWVyKG5ld0xheWVyKTtcblxuICAgICAgICAgIGluaXRMYXllckluU2VlcihuZXdMYXllcik7IC8vIEluaXRpYWxpemVzIGxheWVyIGluIHNlZXIgY2hyb21lIGV4dGVuc2lvbiAoaWYgY29ubmVjdGVkKVxuICAgICAgICB9XG4gICAgICAgIGdlbmVyYXRlZExheWVycy5wdXNoKG5ld0xheWVyKTtcblxuICAgICAgICAvLyBDYWxsIGxheWVyIGxpZmVjeWNsZSBtZXRob2Q6IHJlbmRlciBzdWJsYXllcnNcbiAgICAgICAgY29uc3Qge3Byb3BzLCBvbGRQcm9wc30gPSBuZXdMYXllcjtcbiAgICAgICAgbGV0IHN1YmxheWVycyA9IG5ld0xheWVyLmlzQ29tcG9zaXRlID8gbmV3TGF5ZXIuX3JlbmRlckxheWVycyh7XG4gICAgICAgICAgb2xkUHJvcHMsXG4gICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgY29udGV4dDogdGhpcy5jb250ZXh0LFxuICAgICAgICAgIG9sZENvbnRleHQ6IHRoaXMub2xkQ29udGV4dCxcbiAgICAgICAgICBjaGFuZ2VGbGFnczogbmV3TGF5ZXIuZGlmZlByb3BzKG9sZFByb3BzLCBwcm9wcywgdGhpcy5jb250ZXh0KVxuICAgICAgICB9KSA6IG51bGw7XG4gICAgICAgIC8vIEVuZCBsYXllciBsaWZlY3ljbGUgbWV0aG9kOiByZW5kZXIgc3VibGF5ZXJzXG5cbiAgICAgICAgaWYgKHN1YmxheWVycykge1xuICAgICAgICAgIC8vIEZsYXR0ZW4gdGhlIHJldHVybmVkIGFycmF5LCByZW1vdmluZyBhbnkgbnVsbCwgdW5kZWZpbmVkIG9yIGZhbHNlXG4gICAgICAgICAgLy8gdGhpcyBhbGxvd3MgbGF5ZXJzIHRvIHJlbmRlciBzdWJsYXllcnMgY29uZGl0aW9uYWxseVxuICAgICAgICAgIC8vIChzZWUgQ29tcG9zaXRlTGF5ZXIucmVuZGVyTGF5ZXJzIGRvY3MpXG4gICAgICAgICAgc3VibGF5ZXJzID0gZmxhdHRlbihzdWJsYXllcnMsIHtmaWx0ZXI6IEJvb2xlYW59KTtcblxuICAgICAgICAgIC8vIHBvcHVsYXRlIHJlZmVyZW5jZSB0byBwYXJlbnQgbGF5ZXJcbiAgICAgICAgICBzdWJsYXllcnMuZm9yRWFjaChsYXllciA9PiB7XG4gICAgICAgICAgICBsYXllci5wYXJlbnRMYXllciA9IG5ld0xheWVyO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdGhpcy5fbWF0Y2hTdWJsYXllcnMoe1xuICAgICAgICAgICAgbmV3TGF5ZXJzOiBzdWJsYXllcnMsXG4gICAgICAgICAgICBvbGRMYXllck1hcCxcbiAgICAgICAgICAgIGdlbmVyYXRlZExheWVyc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgbG9nLm9uY2UoMCxcbiAgICAgICAgICBgZGVjay5nbCBlcnJvciBkdXJpbmcgbWF0Y2hpbmcgb2YgJHtsYXllck5hbWUobmV3TGF5ZXIpfSAke2Vycn1gLCBlcnIpO1xuICAgICAgICAvLyBTYXZlIGZpcnN0IGVycm9yXG4gICAgICAgIGVycm9yID0gZXJyb3IgfHwgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cblxuICBfdHJhbnNmZXJMYXllclN0YXRlKG9sZExheWVyLCBuZXdMYXllcikge1xuICAgIGNvbnN0IHtzdGF0ZSwgcHJvcHN9ID0gb2xkTGF5ZXI7XG5cbiAgICAvLyBzYW5pdHkgY2hlY2tcbiAgICBhc3NlcnQoc3RhdGUsICdkZWNrLmdsIHNhbml0eSBjaGVjayAtIE1hdGNoaW5nIGxheWVyIGhhcyBubyBzdGF0ZScpO1xuICAgIGlmIChuZXdMYXllciAhPT0gb2xkTGF5ZXIpIHtcbiAgICAgIGxvZyhMT0dfUFJJT1JJVFlfTElGRUNZQ0xFX01JTk9SLFxuICAgICAgICBgbWF0Y2hlZCAke2xheWVyTmFtZShuZXdMYXllcil9YCwgb2xkTGF5ZXIsICctPicsIG5ld0xheWVyKTtcblxuICAgICAgLy8gTW92ZSBzdGF0ZVxuICAgICAgc3RhdGUubGF5ZXIgPSBuZXdMYXllcjtcbiAgICAgIG5ld0xheWVyLnN0YXRlID0gc3RhdGU7XG5cbiAgICAgIC8vIFVwZGF0ZSBtb2RlbCBsYXllciByZWZlcmVuY2VcbiAgICAgIGlmIChzdGF0ZS5tb2RlbCkge1xuICAgICAgICBzdGF0ZS5tb2RlbC51c2VyRGF0YS5sYXllciA9IG5ld0xheWVyO1xuICAgICAgfVxuICAgICAgLy8gS2VlcCBhIHRlbXBvcmFyeSByZWYgdG8gdGhlIG9sZCBwcm9wcywgZm9yIHByb3AgY29tcGFyaXNvblxuICAgICAgbmV3TGF5ZXIub2xkUHJvcHMgPSBwcm9wcztcbiAgICAgIC8vIG9sZExheWVyLnN0YXRlID0gbnVsbDtcblxuICAgICAgbmV3TGF5ZXIubGlmZWN5Y2xlID0gTElGRUNZQ0xFLk1BVENIRUQ7XG4gICAgICBvbGRMYXllci5saWZlY3ljbGUgPSBMSUZFQ1lDTEUuQVdBSVRJTkdfR0M7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZy5sb2coTE9HX1BSSU9SSVRZX0xJRkVDWUNMRV9NSU5PUiwgYE1hdGNoaW5nIGxheWVyIGlzIHVuY2hhbmdlZCAke25ld0xheWVyLmlkfWApO1xuICAgICAgbmV3TGF5ZXIubGlmZWN5Y2xlID0gTElGRUNZQ0xFLk1BVENIRUQ7XG4gICAgICBuZXdMYXllci5vbGRQcm9wcyA9IG5ld0xheWVyLnByb3BzO1xuICAgICAgLy8gVE9ETyAtIHdlIGNvdWxkIGF2b2lkIHByb3AgY29tcGFyaXNvbnMgaW4gdGhpcyBjYXNlXG4gICAgfVxuICB9XG5cbiAgLy8gVXBkYXRlIHRoZSBvbGQgbGF5ZXJzIHRoYXQgd2VyZSBub3QgbWF0Y2hlZFxuICBfZmluYWxpemVPbGRMYXllcnMob2xkTGF5ZXJzKSB7XG4gICAgbGV0IGVycm9yID0gbnVsbDtcbiAgICAvLyBNYXRjaGVkIGxheWVycyBoYXZlIGxpZmVjeWNsZSBzdGF0ZSBcIm91dGRhdGVkXCJcbiAgICBmb3IgKGNvbnN0IGxheWVyIG9mIG9sZExheWVycykge1xuICAgICAgaWYgKGxheWVyLmxpZmVjeWNsZSA9PT0gTElGRUNZQ0xFLkFXQUlUSU5HX0ZJTkFMSVpBVElPTikge1xuICAgICAgICBlcnJvciA9IGVycm9yIHx8IHRoaXMuX2ZpbmFsaXplTGF5ZXIobGF5ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cblxuICAvLyBJbml0aWFsaXplcyBhIHNpbmdsZSBsYXllciwgY2FsbGluZyBsYXllciBtZXRob2RzXG4gIF9pbml0aWFsaXplTmV3TGF5ZXIobGF5ZXIpIHtcbiAgICBsZXQgZXJyb3IgPSBudWxsO1xuICAgIC8vIENoZWNrIGlmIG5ldyBsYXllciwgYW5kIGluaXRpYWxpemUgaXQncyBzdGF0ZVxuICAgIGlmICghbGF5ZXIuc3RhdGUpIHtcbiAgICAgIGxvZyhMT0dfUFJJT1JJVFlfTElGRUNZQ0xFLCBgaW5pdGlhbGl6aW5nICR7bGF5ZXJOYW1lKGxheWVyKX1gKTtcbiAgICAgIHRyeSB7XG5cbiAgICAgICAgbGF5ZXIuaW5pdGlhbGl6ZUxheWVyKHtcbiAgICAgICAgICBvbGRQcm9wczoge30sXG4gICAgICAgICAgcHJvcHM6IGxheWVyLnByb3BzLFxuICAgICAgICAgIG9sZENvbnRleHQ6IHRoaXMub2xkQ29udGV4dCxcbiAgICAgICAgICBjb250ZXh0OiB0aGlzLmNvbnRleHQsXG4gICAgICAgICAgY2hhbmdlRmxhZ3M6IGxheWVyLmRpZmZQcm9wcyh7fSwgbGF5ZXIucHJvcHMsIHRoaXMuY29udGV4dClcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGF5ZXIubGlmZWN5Y2xlID0gTElGRUNZQ0xFLklOSVRJQUxJWkVEO1xuXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgbG9nLm9uY2UoMCwgYGRlY2suZ2wgZXJyb3IgZHVyaW5nIGluaXRpYWxpemF0aW9uIG9mICR7bGF5ZXJOYW1lKGxheWVyKX0gJHtlcnJ9YCwgZXJyKTtcbiAgICAgICAgLy8gU2F2ZSBmaXJzdCBlcnJvclxuICAgICAgICBlcnJvciA9IGVycm9yIHx8IGVycjtcbiAgICAgIH1cbiAgICAgIC8vIFNldCBiYWNrIHBvaW50ZXIgKHVzZWQgaW4gcGlja2luZylcbiAgICAgIGlmIChsYXllci5zdGF0ZSkge1xuICAgICAgICBsYXllci5zdGF0ZS5sYXllciA9IGxheWVyO1xuICAgICAgICAvLyBTYXZlIGxheWVyIG9uIG1vZGVsIGZvciBwaWNraW5nIHB1cnBvc2VzXG4gICAgICAgIC8vIFRPRE8gLSBzdG9yZSBvbiBtb2RlbC51c2VyRGF0YSByYXRoZXIgdGhhbiBkaXJlY3RseSBvbiBtb2RlbFxuICAgICAgfVxuICAgICAgaWYgKGxheWVyLnN0YXRlICYmIGxheWVyLnN0YXRlLm1vZGVsKSB7XG4gICAgICAgIGxheWVyLnN0YXRlLm1vZGVsLnVzZXJEYXRhLmxheWVyID0gbGF5ZXI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuXG4gIC8vIFVwZGF0ZXMgYSBzaW5nbGUgbGF5ZXIsIGNhbGxpbmcgbGF5ZXIgbWV0aG9kc1xuICBfdXBkYXRlTGF5ZXIobGF5ZXIpIHtcbiAgICBjb25zdCB7b2xkUHJvcHMsIHByb3BzfSA9IGxheWVyO1xuICAgIGxldCBlcnJvciA9IG51bGw7XG4gICAgaWYgKG9sZFByb3BzKSB7XG4gICAgICB0cnkge1xuICAgICAgICBsYXllci51cGRhdGVMYXllcih7XG4gICAgICAgICAgb2xkUHJvcHMsXG4gICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgY29udGV4dDogdGhpcy5jb250ZXh0LFxuICAgICAgICAgIG9sZENvbnRleHQ6IHRoaXMub2xkQ29udGV4dCxcbiAgICAgICAgICBjaGFuZ2VGbGFnczogbGF5ZXIuZGlmZlByb3BzKG9sZFByb3BzLCBsYXllci5wcm9wcywgdGhpcy5jb250ZXh0KVxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBsb2cub25jZSgwLCBgZGVjay5nbCBlcnJvciBkdXJpbmcgdXBkYXRlIG9mICR7bGF5ZXJOYW1lKGxheWVyKX1gLCBlcnIpO1xuICAgICAgICAvLyBTYXZlIGZpcnN0IGVycm9yXG4gICAgICAgIGVycm9yID0gZXJyO1xuICAgICAgfVxuICAgICAgbG9nKExPR19QUklPUklUWV9MSUZFQ1lDTEVfTUlOT1IsIGB1cGRhdGluZyAke2xheWVyTmFtZShsYXllcil9YCk7XG4gICAgfVxuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuXG4gIC8vIEZpbmFsaXplcyBhIHNpbmdsZSBsYXllclxuICBfZmluYWxpemVMYXllcihsYXllcikge1xuICAgIGxldCBlcnJvciA9IG51bGw7XG4gICAgY29uc3Qge3N0YXRlfSA9IGxheWVyO1xuICAgIGlmIChzdGF0ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGF5ZXIuZmluYWxpemVMYXllcigpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZy5vbmNlKDAsXG4gICAgICAgICAgYGRlY2suZ2wgZXJyb3IgZHVyaW5nIGZpbmFsaXphdGlvbiBvZiAke2xheWVyTmFtZShsYXllcil9YCwgZXJyKTtcbiAgICAgICAgLy8gU2F2ZSBmaXJzdCBlcnJvclxuICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgIH1cbiAgICAgIC8vIGxheWVyLnN0YXRlID0gbnVsbDtcbiAgICAgIGxheWVyLmxpZmVjeWNsZSA9IExJRkVDWUNMRS5GSU5BTElaRUQ7XG4gICAgICBsb2coTE9HX1BSSU9SSVRZX0xJRkVDWUNMRSwgYGZpbmFsaXppbmcgJHtsYXllck5hbWUobGF5ZXIpfWApO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cblxuICAvKipcbiAgICogV2FybiBpZiBhIGRlY2stbGV2ZWwgbW91c2UgZXZlbnQgaGFzIGJlZW4gc3BlY2lmaWVkLFxuICAgKiBidXQgbm8gbGF5ZXJzIGFyZSBgcGlja2FibGVgLlxuICAgKi9cbiAgX3ZhbGlkYXRlRXZlbnRIYW5kbGluZygpIHtcbiAgICBpZiAoXG4gICAgICB0aGlzLm9uTGF5ZXJDbGljayB8fFxuICAgICAgdGhpcy5vbkxheWVySG92ZXJcbiAgICApIHtcbiAgICAgIGlmICh0aGlzLmxheWVycy5sZW5ndGggJiYgIXRoaXMubGF5ZXJzLnNvbWUobGF5ZXIgPT4gbGF5ZXIucHJvcHMucGlja2FibGUpKSB7XG4gICAgICAgIGxvZy5vbmNlKDEsXG4gICAgICAgICAgJ1lvdSBoYXZlIHN1cHBsaWVkIGEgdG9wLWxldmVsIGlucHV0IGV2ZW50IGhhbmRsZXIgKGUuZy4gYG9uTGF5ZXJDbGlja2ApLCAnICtcbiAgICAgICAgICAnYnV0IG5vbmUgb2YgeW91ciBsYXllcnMgaGF2ZSBzZXQgdGhlIGBwaWNrYWJsZWAgZmxhZy4nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJvdXRlIGNsaWNrIGV2ZW50cyB0byBsYXllcnMuXG4gICAqIGBwaWNrTGF5ZXJgIHdpbGwgY2FsbCB0aGUgYG9uQ2xpY2tgIHByb3Agb2YgYW55IHBpY2tlZCBsYXllcixcbiAgICogYW5kIGBvbkxheWVyQ2xpY2tgIGlzIGNhbGxlZCBkaXJlY3RseSBmcm9tIGhlcmVcbiAgICogd2l0aCBhbnkgcGlja2luZyBpbmZvIGdlbmVyYXRlZCBieSBgcGlja0xheWVyYC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50ICBBbiBvYmplY3QgZW5jYXBzdWxhdGluZyBhbiBpbnB1dCBldmVudCxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICB3aXRoIHRoZSBmb2xsb3dpbmcgc2hhcGU6XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAge09iamVjdDoge3gsIHl9fSBvZmZzZXRDZW50ZXI6IGNlbnRlciBvZiB0aGUgZXZlbnRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICB7T2JqZWN0fSBzcmNFdmVudDogICAgICAgICAgICAgbmF0aXZlIEpTIEV2ZW50IG9iamVjdFxuICAgKi9cbiAgX29uQ2xpY2soZXZlbnQpIHtcbiAgICBjb25zdCBwb3MgPSBldmVudC5vZmZzZXRDZW50ZXI7XG4gICAgaWYgKCFwb3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0ZWRJbmZvcyA9IHRoaXMucGlja0xheWVyKHtcbiAgICAgIHg6IHBvcy54LFxuICAgICAgeTogcG9zLnksXG4gICAgICByYWRpdXM6IHRoaXMuX3BpY2tpbmdSYWRpdXMsXG4gICAgICBtb2RlOiAnY2xpY2snXG4gICAgfSk7XG4gICAgaWYgKHNlbGVjdGVkSW5mb3MubGVuZ3RoKSB7XG4gICAgICBjb25zdCBmaXJzdEluZm8gPSBzZWxlY3RlZEluZm9zLmZpbmQoaW5mbyA9PiBpbmZvLmluZGV4ID49IDApO1xuICAgICAgaWYgKHRoaXMuX29uTGF5ZXJDbGljaykge1xuICAgICAgICB0aGlzLl9vbkxheWVyQ2xpY2soZmlyc3RJbmZvLCBzZWxlY3RlZEluZm9zLCBldmVudC5zcmNFdmVudCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJvdXRlIGNsaWNrIGV2ZW50cyB0byBsYXllcnMuXG4gICAqIGBwaWNrTGF5ZXJgIHdpbGwgY2FsbCB0aGUgYG9uSG92ZXJgIHByb3Agb2YgYW55IHBpY2tlZCBsYXllcixcbiAgICogYW5kIGBvbkxheWVySG92ZXJgIGlzIGNhbGxlZCBkaXJlY3RseSBmcm9tIGhlcmVcbiAgICogd2l0aCBhbnkgcGlja2luZyBpbmZvIGdlbmVyYXRlZCBieSBgcGlja0xheWVyYC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50ICBBbiBvYmplY3QgZW5jYXBzdWxhdGluZyBhbiBpbnB1dCBldmVudCxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICB3aXRoIHRoZSBmb2xsb3dpbmcgc2hhcGU6XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAge09iamVjdDoge3gsIHl9fSBvZmZzZXRDZW50ZXI6IGNlbnRlciBvZiB0aGUgZXZlbnRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICB7T2JqZWN0fSBzcmNFdmVudDogICAgICAgICAgICAgbmF0aXZlIEpTIEV2ZW50IG9iamVjdFxuICAgKi9cbiAgX29uUG9pbnRlck1vdmUoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuaXNEb3duKSB7XG4gICAgICAvLyBEbyBub3QgdHJpZ2dlciBvbkhvdmVyIGNhbGxiYWNrcyBpZiBtb3VzZSBidXR0b24gaXMgZG93blxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwb3MgPSBldmVudC5vZmZzZXRDZW50ZXI7XG4gICAgLy8gVE9ETzogY29uc2lkZXIgdXNpbmcgdGhpcy5ldmVudE1hbmFnZXIuZWxlbWVudCBzaXplIGluc3RlYWQgb2YgbGF5ZXJNYW5hZ2VyLmNvbnRleHRcbiAgICAvLyBidXQgZG8gc28gaW4gYSB3YXkgdGhhdCBkb2Vzbid0IGNhdXNlIHJlZmxvdyAoZS5nLiBgb2Zmc2V0V2lkdGgvSGVpZ2h0YCkuXG4gICAgLy8gbWF5YmUgdGhlIGV2ZW50IG9iamVjdCBvZmZlcnMgb2Zmc2V0Q2VudGVyIGFzIGEgMDw+MSB2YWx1ZSBhcyB3ZWxsP1xuICAgIC8vIHNpbmNlIGl0J3MgYWxyZWFkeSBkb2luZyBzaXplIGNhbGN1bGF0aW9ucy4uLlxuICAgIGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IHRoaXMuY29udGV4dC52aWV3cG9ydDtcbiAgICBpZiAoIXBvcyB8fCBwb3MueCA8IDAgfHwgcG9zLnkgPCAwIHx8IHBvcy54ID4gd2lkdGggfHwgcG9zLnkgPiBoZWlnaHQpIHtcbiAgICAgIC8vIENoZWNrIGlmIHBvaW50ZXIgaXMgaW5zaWRlIHRoZSBjYW52YXNcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0ZWRJbmZvcyA9IHRoaXMucGlja0xheWVyKHtcbiAgICAgIHg6IHBvcy54LFxuICAgICAgeTogcG9zLnksXG4gICAgICByYWRpdXM6IHRoaXMuX3BpY2tpbmdSYWRpdXMsXG4gICAgICBtb2RlOiAnaG92ZXInXG4gICAgfSk7XG4gICAgaWYgKHNlbGVjdGVkSW5mb3MubGVuZ3RoKSB7XG4gICAgICBjb25zdCBmaXJzdEluZm8gPSBzZWxlY3RlZEluZm9zLmZpbmQoaW5mbyA9PiBpbmZvLmluZGV4ID49IDApO1xuICAgICAgaWYgKHRoaXMuX29uTGF5ZXJIb3Zlcikge1xuICAgICAgICB0aGlzLl9vbkxheWVySG92ZXIoZmlyc3RJbmZvLCBzZWxlY3RlZEluZm9zLCBldmVudC5zcmNFdmVudCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gU0VFUiBJTlRFR1JBVElPTlxuXG4gIC8qKlxuICAgKiBDYWxsZWQgdXBvbiBTZWVyIGluaXRpYWxpemF0aW9uLCBtYW51YWxseSBzZW5kcyBsYXllcnMgZGF0YS5cbiAgICovXG4gIF9pbml0U2VlcigpIHtcbiAgICB0aGlzLmxheWVycy5mb3JFYWNoKGxheWVyID0+IHtcbiAgICAgIGluaXRMYXllckluU2VlcihsYXllcik7XG4gICAgICB1cGRhdGVMYXllckluU2VlcihsYXllcik7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogT24gU2VlciBwcm9wZXJ0eSBlZGl0aW9uLCBzZXQgb3ZlcnJpZGUgYW5kIHVwZGF0ZSBsYXllcnMuXG4gICAqL1xuICBfZWRpdFNlZXIocGF5bG9hZCkge1xuICAgIGlmIChwYXlsb2FkLnR5cGUgIT09ICdlZGl0JyB8fCBwYXlsb2FkLnZhbHVlUGF0aFswXSAhPT0gJ3Byb3BzJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNldFByb3BPdmVycmlkZXMocGF5bG9hZC5pdGVtS2V5LCBwYXlsb2FkLnZhbHVlUGF0aC5zbGljZSgxKSwgcGF5bG9hZC52YWx1ZSk7XG4gICAgY29uc3QgbmV3TGF5ZXJzID0gdGhpcy5sYXllcnMubWFwKGxheWVyID0+IG5ldyBsYXllci5jb25zdHJ1Y3RvcihsYXllci5wcm9wcykpO1xuICAgIHRoaXMudXBkYXRlTGF5ZXJzKHtuZXdMYXllcnN9KTtcbiAgfVxufVxuIl19