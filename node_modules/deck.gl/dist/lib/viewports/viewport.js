'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// TODO - replace with math.gl


exports.createMat4 = createMat4;

var _math = require('../math');

var _scale = require('gl-mat4/scale');

var _scale2 = _interopRequireDefault(_scale);

var _translate = require('gl-mat4/translate');

var _translate2 = _interopRequireDefault(_translate);

var _multiply = require('gl-mat4/multiply');

var _multiply2 = _interopRequireDefault(_multiply);

var _invert = require('gl-mat4/invert');

var _invert2 = _interopRequireDefault(_invert);

var _multiply3 = require('gl-vec4/multiply');

var _multiply4 = _interopRequireDefault(_multiply3);

var _transformMat = require('gl-vec4/transformMat4');

var _transformMat2 = _interopRequireDefault(_transformMat);

var _lerp = require('gl-vec2/lerp');

var _lerp2 = _interopRequireDefault(_lerp);

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var IDENTITY = createMat4();
var DEFAULT_DISTANCE_SCALES = {
  pixelsPerMeter: [1, 1, 1],
  metersPerPixel: [1, 1, 1],
  pixelsPerDegree: [1, 1, 1],
  degreesPerPixel: [1, 1, 1]
};

var ERR_ARGUMENT = 'Illegal argument to Viewport';

var Viewport = function () {
  /**
   * @classdesc
   * Manages coordinate system transformations for deck.gl.
   *
   * Note: The Viewport is immutable in the sense that it only has accessors.
   * A new viewport instance should be created if any parameters have changed.
   */
  function Viewport() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$width = _ref.width,
        width = _ref$width === undefined ? 1 : _ref$width,
        _ref$height = _ref.height,
        height = _ref$height === undefined ? 1 : _ref$height,
        _ref$viewMatrix = _ref.viewMatrix,
        viewMatrix = _ref$viewMatrix === undefined ? IDENTITY : _ref$viewMatrix,
        _ref$projectionMatrix = _ref.projectionMatrix,
        projectionMatrix = _ref$projectionMatrix === undefined ? IDENTITY : _ref$projectionMatrix,
        _ref$distanceScales = _ref.distanceScales,
        distanceScales = _ref$distanceScales === undefined ? DEFAULT_DISTANCE_SCALES : _ref$distanceScales;

    _classCallCheck(this, Viewport);

    // Silently allow apps to send in 0,0
    this.width = width || 1;
    this.height = height || 1;
    this.scale = 1;

    this.viewMatrix = viewMatrix;
    this.projectionMatrix = projectionMatrix;
    this.distanceScales = distanceScales;

    this._initMatrices();

    this.equals = this.equals.bind(this);
    this.project = this.project.bind(this);
    this.unproject = this.unproject.bind(this);
    this.projectFlat = this.projectFlat.bind(this);
    this.unprojectFlat = this.unprojectFlat.bind(this);
    this.getMatrices = this.getMatrices.bind(this);
  }

  // Two viewports are equal if width and height are identical, and if
  // their view and projection matrices are (approximately) equal.


  _createClass(Viewport, [{
    key: 'equals',
    value: function equals(viewport) {
      if (!(viewport instanceof Viewport)) {
        return false;
      }

      return viewport.width === this.width && viewport.height === this.height && (0, _math.equals)(viewport.projectionMatrix, this.projectionMatrix) && (0, _math.equals)(viewport.viewMatrix, this.viewMatrix);
      // TODO - check distance scales?
    }

    /**
     * Projects xyz (possibly latitude and longitude) to pixel coordinates in window
     * using viewport projection parameters
     * - [longitude, latitude] to [x, y]
     * - [longitude, latitude, Z] => [x, y, z]
     * Note: By default, returns top-left coordinates for canvas/SVG type render
     *
     * @param {Array} lngLatZ - [lng, lat] or [lng, lat, Z]
     * @param {Object} opts - options
     * @param {Object} opts.topLeft=true - Whether projected coords are top left
     * @return {Array} - [x, y] or [x, y, z] in top left coords
     */

  }, {
    key: 'project',
    value: function project(xyz) {
      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref2$topLeft = _ref2.topLeft,
          topLeft = _ref2$topLeft === undefined ? false : _ref2$topLeft;

      var _xyz = _slicedToArray(xyz, 3),
          x0 = _xyz[0],
          y0 = _xyz[1],
          _xyz$ = _xyz[2],
          z0 = _xyz$ === undefined ? 0 : _xyz$;

      (0, _assert2.default)(Number.isFinite(x0) && Number.isFinite(y0) && Number.isFinite(z0), ERR_ARGUMENT);

      var _projectFlat2 = this.projectFlat([x0, y0]),
          _projectFlat3 = _slicedToArray(_projectFlat2, 2),
          X = _projectFlat3[0],
          Y = _projectFlat3[1];

      var v = this.transformVector(this.pixelProjectionMatrix, [X, Y, z0, 1]);

      var _v = _slicedToArray(v, 2),
          x = _v[0],
          y = _v[1];

      var y2 = topLeft ? this.height - y : y;
      return xyz.length === 2 ? [x, y2] : [x, y2, 0];
    }

    /**
     * Unproject pixel coordinates on screen onto world coordinates,
     * (possibly [lon, lat]) on map.
     * - [x, y] => [lng, lat]
     * - [x, y, z] => [lng, lat, Z]
     * @param {Array} xyz -
     * @return {Array} - [lng, lat, Z] or [X, Y, Z]
     */

  }, {
    key: 'unproject',
    value: function unproject(xyz) {
      var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref3$topLeft = _ref3.topLeft,
          topLeft = _ref3$topLeft === undefined ? false : _ref3$topLeft;

      var _xyz2 = _slicedToArray(xyz, 3),
          x = _xyz2[0],
          y = _xyz2[1],
          _xyz2$ = _xyz2[2],
          targetZ = _xyz2$ === undefined ? 0 : _xyz2$;

      var y2 = topLeft ? this.height - y : y;

      // since we don't know the correct projected z value for the point,
      // unproject two points to get a line and then find the point on that line with z=0
      var coord0 = this.transformVector(this.pixelUnprojectionMatrix, [x, y2, 0, 1]);
      var coord1 = this.transformVector(this.pixelUnprojectionMatrix, [x, y2, 1, 1]);

      var z0 = coord0[2];
      var z1 = coord1[2];

      var t = z0 === z1 ? 0 : (targetZ - z0) / (z1 - z0);
      var v = (0, _lerp2.default)([], coord0, coord1, t);

      var vUnprojected = this.unprojectFlat(v);
      return xyz.length === 2 ? vUnprojected : [vUnprojected[0], vUnprojected[1], 0];
    }
  }, {
    key: 'transformVector',
    value: function transformVector(matrix, vector) {
      var result = (0, _transformMat2.default)([0, 0, 0, 0], vector, matrix);
      var scale = 1 / result[3];
      (0, _multiply4.default)(result, result, [scale, scale, scale, scale]);
      return result;
    }

    // NON_LINEAR PROJECTION HOOKS
    // Used for web meractor projection

    /**
     * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.
     * Performs the nonlinear part of the web mercator projection.
     * Remaining projection is done with 4x4 matrices which also handles
     * perspective.
     * @param {Array} lngLat - [lng, lat] coordinates
     *   Specifies a point on the sphere to project onto the map.
     * @return {Array} [x,y] coordinates.
     */

  }, {
    key: 'projectFlat',
    value: function projectFlat(_ref4) {
      var _ref5 = _slicedToArray(_ref4, 2),
          x = _ref5[0],
          y = _ref5[1];

      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      return this._projectFlat.apply(this, arguments);
    }

    /**
     * Unproject world point [x,y] on map onto {lat, lon} on sphere
     * @param {object|Vector} xy - object with {x,y} members
     *  representing point on projected map plane
     * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.
     *   Has toArray method if you need a GeoJSON Array.
     *   Per cartographic tradition, lat and lon are specified as degrees.
     */

  }, {
    key: 'unprojectFlat',
    value: function unprojectFlat(xyz) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      return this._unprojectFlat.apply(this, arguments);
    }
  }, {
    key: 'getMatrices',
    value: function getMatrices() {
      var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref6$modelMatrix = _ref6.modelMatrix,
          modelMatrix = _ref6$modelMatrix === undefined ? null : _ref6$modelMatrix;

      var modelViewProjectionMatrix = this.viewProjectionMatrix;
      var pixelProjectionMatrix = this.pixelProjectionMatrix;
      var pixelUnprojectionMatrix = this.pixelUnprojectionMatrix;

      if (modelMatrix) {
        modelViewProjectionMatrix = (0, _multiply2.default)([], this.viewProjectionMatrix, modelMatrix);
        pixelProjectionMatrix = (0, _multiply2.default)([], this.pixelProjectionMatrix, modelMatrix);
        pixelUnprojectionMatrix = (0, _invert2.default)([], pixelProjectionMatrix);
      }

      var matrices = Object.assign({
        modelViewProjectionMatrix: modelViewProjectionMatrix,
        viewProjectionMatrix: this.viewProjectionMatrix,
        viewMatrix: this.viewMatrix,
        projectionMatrix: this.projectionMatrix,

        // project/unproject between pixels and world
        pixelProjectionMatrix: pixelProjectionMatrix,
        pixelUnprojectionMatrix: pixelUnprojectionMatrix,

        width: this.width,
        height: this.height,
        scale: this.scale
      });

      return matrices;
    }
  }, {
    key: 'getDistanceScales',
    value: function getDistanceScales() {
      return this.distanceScales;
    }
  }, {
    key: 'getCameraPosition',
    value: function getCameraPosition() {
      return this.cameraPosition;
    }

    // INTERNAL METHODS

  }, {
    key: '_initMatrices',
    value: function _initMatrices() {
      // Note: As usual, matrix operations should be applied in "reverse" order
      // since vectors will be multiplied in from the right during transformation
      var vpm = createMat4();
      (0, _multiply2.default)(vpm, vpm, this.projectionMatrix);
      (0, _multiply2.default)(vpm, vpm, this.viewMatrix);
      this.viewProjectionMatrix = vpm;

      // Calculate inverse view matrix
      this.viewMatrixInverse = (0, _invert2.default)([], this.viewMatrix) || this.viewMatrix;

      // Read the translation from the inverse view matrix
      this.cameraPosition = [this.viewMatrixInverse[12], this.viewMatrixInverse[13], this.viewMatrixInverse[14]];

      this.cameraDirection = [this.viewMatrix[2], this.viewMatrix[6], this.viewMatrix[10]];

      this.cameraUp = [this.viewMatrix[1], this.viewMatrix[5], this.viewMatrix[9]];

      /*
       * Builds matrices that converts preprojected lngLats to screen pixels
       * and vice versa.
       * Note: Currently returns bottom-left coordinates!
       * Note: Starts with the GL projection matrix and adds steps to the
       *       scale and translate that matrix onto the window.
       * Note: WebGL controls clip space to screen projection with gl.viewport
       *       and does not need this step.
       */

      // matrix for conversion from location to screen coordinates
      var m = createMat4();
      (0, _scale2.default)(m, m, [this.width / 2, -this.height / 2, 1]);
      (0, _translate2.default)(m, m, [1, -1, 0]);
      (0, _multiply2.default)(m, m, this.viewProjectionMatrix);
      this.pixelProjectionMatrix = m;

      this.pixelUnprojectionMatrix = (0, _invert2.default)(createMat4(), this.pixelProjectionMatrix);
      if (!this.pixelUnprojectionMatrix) {
        throw new Error('Pixel project matrix not invertible');
      }
    }
  }, {
    key: '_projectFlat',
    value: function _projectFlat(xyz) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      return xyz;
    }
  }, {
    key: '_unprojectFlat',
    value: function _unprojectFlat(xyz) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      return xyz;
    }
  }]);

  return Viewport;
}();

// Helper, avoids low-precision 32 bit matrices from gl-matrix mat4.create()


exports.default = Viewport;
function createMat4() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIvdmlld3BvcnRzL3ZpZXdwb3J0LmpzIl0sIm5hbWVzIjpbImNyZWF0ZU1hdDQiLCJJREVOVElUWSIsIkRFRkFVTFRfRElTVEFOQ0VfU0NBTEVTIiwicGl4ZWxzUGVyTWV0ZXIiLCJtZXRlcnNQZXJQaXhlbCIsInBpeGVsc1BlckRlZ3JlZSIsImRlZ3JlZXNQZXJQaXhlbCIsIkVSUl9BUkdVTUVOVCIsIlZpZXdwb3J0Iiwid2lkdGgiLCJoZWlnaHQiLCJ2aWV3TWF0cml4IiwicHJvamVjdGlvbk1hdHJpeCIsImRpc3RhbmNlU2NhbGVzIiwic2NhbGUiLCJfaW5pdE1hdHJpY2VzIiwiZXF1YWxzIiwiYmluZCIsInByb2plY3QiLCJ1bnByb2plY3QiLCJwcm9qZWN0RmxhdCIsInVucHJvamVjdEZsYXQiLCJnZXRNYXRyaWNlcyIsInZpZXdwb3J0IiwieHl6IiwidG9wTGVmdCIsIngwIiwieTAiLCJ6MCIsIk51bWJlciIsImlzRmluaXRlIiwiWCIsIlkiLCJ2IiwidHJhbnNmb3JtVmVjdG9yIiwicGl4ZWxQcm9qZWN0aW9uTWF0cml4IiwieCIsInkiLCJ5MiIsImxlbmd0aCIsInRhcmdldFoiLCJjb29yZDAiLCJwaXhlbFVucHJvamVjdGlvbk1hdHJpeCIsImNvb3JkMSIsInoxIiwidCIsInZVbnByb2plY3RlZCIsIm1hdHJpeCIsInZlY3RvciIsInJlc3VsdCIsIl9wcm9qZWN0RmxhdCIsImFyZ3VtZW50cyIsIl91bnByb2plY3RGbGF0IiwibW9kZWxNYXRyaXgiLCJtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4Iiwidmlld1Byb2plY3Rpb25NYXRyaXgiLCJtYXRyaWNlcyIsIk9iamVjdCIsImFzc2lnbiIsImNhbWVyYVBvc2l0aW9uIiwidnBtIiwidmlld01hdHJpeEludmVyc2UiLCJjYW1lcmFEaXJlY3Rpb24iLCJjYW1lcmFVcCIsIm0iLCJFcnJvciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7cWpCQUFBO0FBQ0E7QUFDQTtBQUNB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QUFLVCxvQkFBekI7QUFDQSxXQUFLcEIscUJBQUwsR0FBNkI2QixDQUE3Qjs7QUFFQSxXQUFLdEIsdUJBQUwsR0FBK0Isc0JBQVkxQyxZQUFaLEVBQTBCLEtBQUttQyxxQkFBL0IsQ0FBL0I7QUFDQSxVQUFJLENBQUMsS0FBS08sdUJBQVYsRUFBbUM7QUFDakMsY0FBTSxJQUFJdUIsS0FBSixDQUFVLHFDQUFWLENBQU47QUFDRDtBQUNGOzs7aUNBRVl6QyxHLEVBQXlCO0FBQUEsVUFBcEJWLEtBQW9CLHVFQUFaLEtBQUtBLEtBQU87O0FBQ3BDLGFBQU9VLEdBQVA7QUFDRDs7O21DQUVjQSxHLEVBQXlCO0FBQUEsVUFBcEJWLEtBQW9CLHVFQUFaLEtBQUtBLEtBQU87O0FBQ3RDLGFBQU9VLEdBQVA7QUFDRDs7Ozs7O0FBR0g7OztrQkE5T3FCaEIsUTtBQStPZCxTQUFTUixVQUFULEdBQXNCO0FBQzNCLFNBQU8sQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixFQUFtQixDQUFuQixFQUFzQixDQUF0QixFQUF5QixDQUF6QixFQUE0QixDQUE1QixFQUErQixDQUEvQixFQUFrQyxDQUFsQyxFQUFxQyxDQUFyQyxFQUF3QyxDQUF4QyxFQUEyQyxDQUEzQyxFQUE4QyxDQUE5QyxDQUFQO0FBQ0QiLCJmaWxlIjoidmlld3BvcnQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuLy8gVE9ETyAtIHJlcGxhY2Ugd2l0aCBtYXRoLmdsXG5pbXBvcnQge2VxdWFsc30gZnJvbSAnLi4vbWF0aCc7XG5pbXBvcnQgbWF0NF9zY2FsZSBmcm9tICdnbC1tYXQ0L3NjYWxlJztcbmltcG9ydCBtYXQ0X3RyYW5zbGF0ZSBmcm9tICdnbC1tYXQ0L3RyYW5zbGF0ZSc7XG5pbXBvcnQgbWF0NF9tdWx0aXBseSBmcm9tICdnbC1tYXQ0L211bHRpcGx5JztcbmltcG9ydCBtYXQ0X2ludmVydCBmcm9tICdnbC1tYXQ0L2ludmVydCc7XG5pbXBvcnQgdmVjNF9tdWx0aXBseSBmcm9tICdnbC12ZWM0L211bHRpcGx5JztcbmltcG9ydCB2ZWM0X3RyYW5zZm9ybU1hdDQgZnJvbSAnZ2wtdmVjNC90cmFuc2Zvcm1NYXQ0JztcbmltcG9ydCB2ZWMyX2xlcnAgZnJvbSAnZ2wtdmVjMi9sZXJwJztcblxuaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuXG5jb25zdCBJREVOVElUWSA9IGNyZWF0ZU1hdDQoKTtcbmNvbnN0IERFRkFVTFRfRElTVEFOQ0VfU0NBTEVTID0ge1xuICBwaXhlbHNQZXJNZXRlcjogWzEsIDEsIDFdLFxuICBtZXRlcnNQZXJQaXhlbDogWzEsIDEsIDFdLFxuICBwaXhlbHNQZXJEZWdyZWU6IFsxLCAxLCAxXSxcbiAgZGVncmVlc1BlclBpeGVsOiBbMSwgMSwgMV1cbn07XG5cbmNvbnN0IEVSUl9BUkdVTUVOVCA9ICdJbGxlZ2FsIGFyZ3VtZW50IHRvIFZpZXdwb3J0JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmlld3BvcnQge1xuICAvKipcbiAgICogQGNsYXNzZGVzY1xuICAgKiBNYW5hZ2VzIGNvb3JkaW5hdGUgc3lzdGVtIHRyYW5zZm9ybWF0aW9ucyBmb3IgZGVjay5nbC5cbiAgICpcbiAgICogTm90ZTogVGhlIFZpZXdwb3J0IGlzIGltbXV0YWJsZSBpbiB0aGUgc2Vuc2UgdGhhdCBpdCBvbmx5IGhhcyBhY2Nlc3NvcnMuXG4gICAqIEEgbmV3IHZpZXdwb3J0IGluc3RhbmNlIHNob3VsZCBiZSBjcmVhdGVkIGlmIGFueSBwYXJhbWV0ZXJzIGhhdmUgY2hhbmdlZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICAvLyBXaW5kb3cgd2lkdGgvaGVpZ2h0IGluIHBpeGVscyAoZm9yIHBpeGVsIHByb2plY3Rpb24pXG4gICAgd2lkdGggPSAxLFxuICAgIGhlaWdodCA9IDEsXG4gICAgLy8gRGVzY3JpcHRpb25cbiAgICB2aWV3TWF0cml4ID0gSURFTlRJVFksXG4gICAgcHJvamVjdGlvbk1hdHJpeCA9IElERU5USVRZLFxuICAgIGRpc3RhbmNlU2NhbGVzID0gREVGQVVMVF9ESVNUQU5DRV9TQ0FMRVNcbiAgfSA9IHt9KSB7XG4gICAgLy8gU2lsZW50bHkgYWxsb3cgYXBwcyB0byBzZW5kIGluIDAsMFxuICAgIHRoaXMud2lkdGggPSB3aWR0aCB8fCAxO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0IHx8IDE7XG4gICAgdGhpcy5zY2FsZSA9IDE7XG5cbiAgICB0aGlzLnZpZXdNYXRyaXggPSB2aWV3TWF0cml4O1xuICAgIHRoaXMucHJvamVjdGlvbk1hdHJpeCA9IHByb2plY3Rpb25NYXRyaXg7XG4gICAgdGhpcy5kaXN0YW5jZVNjYWxlcyA9IGRpc3RhbmNlU2NhbGVzO1xuXG4gICAgdGhpcy5faW5pdE1hdHJpY2VzKCk7XG5cbiAgICB0aGlzLmVxdWFscyA9IHRoaXMuZXF1YWxzLmJpbmQodGhpcyk7XG4gICAgdGhpcy5wcm9qZWN0ID0gdGhpcy5wcm9qZWN0LmJpbmQodGhpcyk7XG4gICAgdGhpcy51bnByb2plY3QgPSB0aGlzLnVucHJvamVjdC5iaW5kKHRoaXMpO1xuICAgIHRoaXMucHJvamVjdEZsYXQgPSB0aGlzLnByb2plY3RGbGF0LmJpbmQodGhpcyk7XG4gICAgdGhpcy51bnByb2plY3RGbGF0ID0gdGhpcy51bnByb2plY3RGbGF0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5nZXRNYXRyaWNlcyA9IHRoaXMuZ2V0TWF0cmljZXMuYmluZCh0aGlzKTtcbiAgfVxuXG4gIC8vIFR3byB2aWV3cG9ydHMgYXJlIGVxdWFsIGlmIHdpZHRoIGFuZCBoZWlnaHQgYXJlIGlkZW50aWNhbCwgYW5kIGlmXG4gIC8vIHRoZWlyIHZpZXcgYW5kIHByb2plY3Rpb24gbWF0cmljZXMgYXJlIChhcHByb3hpbWF0ZWx5KSBlcXVhbC5cbiAgZXF1YWxzKHZpZXdwb3J0KSB7XG4gICAgaWYgKCEodmlld3BvcnQgaW5zdGFuY2VvZiBWaWV3cG9ydCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmlld3BvcnQud2lkdGggPT09IHRoaXMud2lkdGggJiZcbiAgICAgIHZpZXdwb3J0LmhlaWdodCA9PT0gdGhpcy5oZWlnaHQgJiZcbiAgICAgIGVxdWFscyh2aWV3cG9ydC5wcm9qZWN0aW9uTWF0cml4LCB0aGlzLnByb2plY3Rpb25NYXRyaXgpICYmXG4gICAgICBlcXVhbHModmlld3BvcnQudmlld01hdHJpeCwgdGhpcy52aWV3TWF0cml4KTtcbiAgICAgIC8vIFRPRE8gLSBjaGVjayBkaXN0YW5jZSBzY2FsZXM/XG4gIH1cblxuICAvKipcbiAgICogUHJvamVjdHMgeHl6IChwb3NzaWJseSBsYXRpdHVkZSBhbmQgbG9uZ2l0dWRlKSB0byBwaXhlbCBjb29yZGluYXRlcyBpbiB3aW5kb3dcbiAgICogdXNpbmcgdmlld3BvcnQgcHJvamVjdGlvbiBwYXJhbWV0ZXJzXG4gICAqIC0gW2xvbmdpdHVkZSwgbGF0aXR1ZGVdIHRvIFt4LCB5XVxuICAgKiAtIFtsb25naXR1ZGUsIGxhdGl0dWRlLCBaXSA9PiBbeCwgeSwgel1cbiAgICogTm90ZTogQnkgZGVmYXVsdCwgcmV0dXJucyB0b3AtbGVmdCBjb29yZGluYXRlcyBmb3IgY2FudmFzL1NWRyB0eXBlIHJlbmRlclxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBsbmdMYXRaIC0gW2xuZywgbGF0XSBvciBbbG5nLCBsYXQsIFpdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy50b3BMZWZ0PXRydWUgLSBXaGV0aGVyIHByb2plY3RlZCBjb29yZHMgYXJlIHRvcCBsZWZ0XG4gICAqIEByZXR1cm4ge0FycmF5fSAtIFt4LCB5XSBvciBbeCwgeSwgel0gaW4gdG9wIGxlZnQgY29vcmRzXG4gICAqL1xuICBwcm9qZWN0KHh5eiwge3RvcExlZnQgPSBmYWxzZX0gPSB7fSkge1xuICAgIGNvbnN0IFt4MCwgeTAsIHowID0gMF0gPSB4eXo7XG4gICAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZSh4MCkgJiYgTnVtYmVyLmlzRmluaXRlKHkwKSAmJiBOdW1iZXIuaXNGaW5pdGUoejApLCBFUlJfQVJHVU1FTlQpO1xuXG4gICAgY29uc3QgW1gsIFldID0gdGhpcy5wcm9qZWN0RmxhdChbeDAsIHkwXSk7XG4gICAgY29uc3QgdiA9IHRoaXMudHJhbnNmb3JtVmVjdG9yKHRoaXMucGl4ZWxQcm9qZWN0aW9uTWF0cml4LCBbWCwgWSwgejAsIDFdKTtcblxuICAgIGNvbnN0IFt4LCB5XSA9IHY7XG4gICAgY29uc3QgeTIgPSB0b3BMZWZ0ID8gdGhpcy5oZWlnaHQgLSB5IDogeTtcbiAgICByZXR1cm4geHl6Lmxlbmd0aCA9PT0gMiA/IFt4LCB5Ml0gOiBbeCwgeTIsIDBdO1xuICB9XG5cbiAgLyoqXG4gICAqIFVucHJvamVjdCBwaXhlbCBjb29yZGluYXRlcyBvbiBzY3JlZW4gb250byB3b3JsZCBjb29yZGluYXRlcyxcbiAgICogKHBvc3NpYmx5IFtsb24sIGxhdF0pIG9uIG1hcC5cbiAgICogLSBbeCwgeV0gPT4gW2xuZywgbGF0XVxuICAgKiAtIFt4LCB5LCB6XSA9PiBbbG5nLCBsYXQsIFpdXG4gICAqIEBwYXJhbSB7QXJyYXl9IHh5eiAtXG4gICAqIEByZXR1cm4ge0FycmF5fSAtIFtsbmcsIGxhdCwgWl0gb3IgW1gsIFksIFpdXG4gICAqL1xuICB1bnByb2plY3QoeHl6LCB7dG9wTGVmdCA9IGZhbHNlfSA9IHt9KSB7XG4gICAgY29uc3QgW3gsIHksIHRhcmdldFogPSAwXSA9IHh5ejtcblxuICAgIGNvbnN0IHkyID0gdG9wTGVmdCA/IHRoaXMuaGVpZ2h0IC0geSA6IHk7XG5cbiAgICAvLyBzaW5jZSB3ZSBkb24ndCBrbm93IHRoZSBjb3JyZWN0IHByb2plY3RlZCB6IHZhbHVlIGZvciB0aGUgcG9pbnQsXG4gICAgLy8gdW5wcm9qZWN0IHR3byBwb2ludHMgdG8gZ2V0IGEgbGluZSBhbmQgdGhlbiBmaW5kIHRoZSBwb2ludCBvbiB0aGF0IGxpbmUgd2l0aCB6PTBcbiAgICBjb25zdCBjb29yZDAgPSB0aGlzLnRyYW5zZm9ybVZlY3Rvcih0aGlzLnBpeGVsVW5wcm9qZWN0aW9uTWF0cml4LCBbeCwgeTIsIDAsIDFdKTtcbiAgICBjb25zdCBjb29yZDEgPSB0aGlzLnRyYW5zZm9ybVZlY3Rvcih0aGlzLnBpeGVsVW5wcm9qZWN0aW9uTWF0cml4LCBbeCwgeTIsIDEsIDFdKTtcblxuICAgIGNvbnN0IHowID0gY29vcmQwWzJdO1xuICAgIGNvbnN0IHoxID0gY29vcmQxWzJdO1xuXG4gICAgY29uc3QgdCA9IHowID09PSB6MSA/IDAgOiAodGFyZ2V0WiAtIHowKSAvICh6MSAtIHowKTtcbiAgICBjb25zdCB2ID0gdmVjMl9sZXJwKFtdLCBjb29yZDAsIGNvb3JkMSwgdCk7XG5cbiAgICBjb25zdCB2VW5wcm9qZWN0ZWQgPSB0aGlzLnVucHJvamVjdEZsYXQodik7XG4gICAgcmV0dXJuIHh5ei5sZW5ndGggPT09IDIgPyB2VW5wcm9qZWN0ZWQgOiBbdlVucHJvamVjdGVkWzBdLCB2VW5wcm9qZWN0ZWRbMV0sIDBdO1xuICB9XG5cbiAgdHJhbnNmb3JtVmVjdG9yKG1hdHJpeCwgdmVjdG9yKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdmVjNF90cmFuc2Zvcm1NYXQ0KFswLCAwLCAwLCAwXSwgdmVjdG9yLCBtYXRyaXgpO1xuICAgIGNvbnN0IHNjYWxlID0gMSAvIHJlc3VsdFszXTtcbiAgICB2ZWM0X211bHRpcGx5KHJlc3VsdCwgcmVzdWx0LCBbc2NhbGUsIHNjYWxlLCBzY2FsZSwgc2NhbGVdKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gTk9OX0xJTkVBUiBQUk9KRUNUSU9OIEhPT0tTXG4gIC8vIFVzZWQgZm9yIHdlYiBtZXJhY3RvciBwcm9qZWN0aW9uXG5cbiAgLyoqXG4gICAqIFByb2plY3QgW2xuZyxsYXRdIG9uIHNwaGVyZSBvbnRvIFt4LHldIG9uIDUxMio1MTIgTWVyY2F0b3IgWm9vbSAwIHRpbGUuXG4gICAqIFBlcmZvcm1zIHRoZSBub25saW5lYXIgcGFydCBvZiB0aGUgd2ViIG1lcmNhdG9yIHByb2plY3Rpb24uXG4gICAqIFJlbWFpbmluZyBwcm9qZWN0aW9uIGlzIGRvbmUgd2l0aCA0eDQgbWF0cmljZXMgd2hpY2ggYWxzbyBoYW5kbGVzXG4gICAqIHBlcnNwZWN0aXZlLlxuICAgKiBAcGFyYW0ge0FycmF5fSBsbmdMYXQgLSBbbG5nLCBsYXRdIGNvb3JkaW5hdGVzXG4gICAqICAgU3BlY2lmaWVzIGEgcG9pbnQgb24gdGhlIHNwaGVyZSB0byBwcm9qZWN0IG9udG8gdGhlIG1hcC5cbiAgICogQHJldHVybiB7QXJyYXl9IFt4LHldIGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgcHJvamVjdEZsYXQoW3gsIHldLCBzY2FsZSA9IHRoaXMuc2NhbGUpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvamVjdEZsYXQoLi4uYXJndW1lbnRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnByb2plY3Qgd29ybGQgcG9pbnQgW3gseV0gb24gbWFwIG9udG8ge2xhdCwgbG9ufSBvbiBzcGhlcmVcbiAgICogQHBhcmFtIHtvYmplY3R8VmVjdG9yfSB4eSAtIG9iamVjdCB3aXRoIHt4LHl9IG1lbWJlcnNcbiAgICogIHJlcHJlc2VudGluZyBwb2ludCBvbiBwcm9qZWN0ZWQgbWFwIHBsYW5lXG4gICAqIEByZXR1cm4ge0dlb0Nvb3JkaW5hdGVzfSAtIG9iamVjdCB3aXRoIHtsYXQsbG9ufSBvZiBwb2ludCBvbiBzcGhlcmUuXG4gICAqICAgSGFzIHRvQXJyYXkgbWV0aG9kIGlmIHlvdSBuZWVkIGEgR2VvSlNPTiBBcnJheS5cbiAgICogICBQZXIgY2FydG9ncmFwaGljIHRyYWRpdGlvbiwgbGF0IGFuZCBsb24gYXJlIHNwZWNpZmllZCBhcyBkZWdyZWVzLlxuICAgKi9cbiAgdW5wcm9qZWN0RmxhdCh4eXosIHNjYWxlID0gdGhpcy5zY2FsZSkge1xuICAgIHJldHVybiB0aGlzLl91bnByb2plY3RGbGF0KC4uLmFyZ3VtZW50cyk7XG4gIH1cblxuICBnZXRNYXRyaWNlcyh7bW9kZWxNYXRyaXggPSBudWxsfSA9IHt9KSB7XG4gICAgbGV0IG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXggPSB0aGlzLnZpZXdQcm9qZWN0aW9uTWF0cml4O1xuICAgIGxldCBwaXhlbFByb2plY3Rpb25NYXRyaXggPSB0aGlzLnBpeGVsUHJvamVjdGlvbk1hdHJpeDtcbiAgICBsZXQgcGl4ZWxVbnByb2plY3Rpb25NYXRyaXggPSB0aGlzLnBpeGVsVW5wcm9qZWN0aW9uTWF0cml4O1xuXG4gICAgaWYgKG1vZGVsTWF0cml4KSB7XG4gICAgICBtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4ID0gbWF0NF9tdWx0aXBseShbXSwgdGhpcy52aWV3UHJvamVjdGlvbk1hdHJpeCwgbW9kZWxNYXRyaXgpO1xuICAgICAgcGl4ZWxQcm9qZWN0aW9uTWF0cml4ID0gbWF0NF9tdWx0aXBseShbXSwgdGhpcy5waXhlbFByb2plY3Rpb25NYXRyaXgsIG1vZGVsTWF0cml4KTtcbiAgICAgIHBpeGVsVW5wcm9qZWN0aW9uTWF0cml4ID0gbWF0NF9pbnZlcnQoW10sIHBpeGVsUHJvamVjdGlvbk1hdHJpeCk7XG4gICAgfVxuXG4gICAgY29uc3QgbWF0cmljZXMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXgsXG4gICAgICB2aWV3UHJvamVjdGlvbk1hdHJpeDogdGhpcy52aWV3UHJvamVjdGlvbk1hdHJpeCxcbiAgICAgIHZpZXdNYXRyaXg6IHRoaXMudmlld01hdHJpeCxcbiAgICAgIHByb2plY3Rpb25NYXRyaXg6IHRoaXMucHJvamVjdGlvbk1hdHJpeCxcblxuICAgICAgLy8gcHJvamVjdC91bnByb2plY3QgYmV0d2VlbiBwaXhlbHMgYW5kIHdvcmxkXG4gICAgICBwaXhlbFByb2plY3Rpb25NYXRyaXgsXG4gICAgICBwaXhlbFVucHJvamVjdGlvbk1hdHJpeCxcblxuICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgc2NhbGU6IHRoaXMuc2NhbGVcbiAgICB9KTtcblxuICAgIHJldHVybiBtYXRyaWNlcztcbiAgfVxuXG4gIGdldERpc3RhbmNlU2NhbGVzKCkge1xuICAgIHJldHVybiB0aGlzLmRpc3RhbmNlU2NhbGVzO1xuICB9XG5cbiAgZ2V0Q2FtZXJhUG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FtZXJhUG9zaXRpb247XG4gIH1cblxuICAvLyBJTlRFUk5BTCBNRVRIT0RTXG5cbiAgX2luaXRNYXRyaWNlcygpIHtcbiAgICAvLyBOb3RlOiBBcyB1c3VhbCwgbWF0cml4IG9wZXJhdGlvbnMgc2hvdWxkIGJlIGFwcGxpZWQgaW4gXCJyZXZlcnNlXCIgb3JkZXJcbiAgICAvLyBzaW5jZSB2ZWN0b3JzIHdpbGwgYmUgbXVsdGlwbGllZCBpbiBmcm9tIHRoZSByaWdodCBkdXJpbmcgdHJhbnNmb3JtYXRpb25cbiAgICBjb25zdCB2cG0gPSBjcmVhdGVNYXQ0KCk7XG4gICAgbWF0NF9tdWx0aXBseSh2cG0sIHZwbSwgdGhpcy5wcm9qZWN0aW9uTWF0cml4KTtcbiAgICBtYXQ0X211bHRpcGx5KHZwbSwgdnBtLCB0aGlzLnZpZXdNYXRyaXgpO1xuICAgIHRoaXMudmlld1Byb2plY3Rpb25NYXRyaXggPSB2cG07XG5cbiAgICAvLyBDYWxjdWxhdGUgaW52ZXJzZSB2aWV3IG1hdHJpeFxuICAgIHRoaXMudmlld01hdHJpeEludmVyc2UgPSBtYXQ0X2ludmVydChbXSwgdGhpcy52aWV3TWF0cml4KSB8fCB0aGlzLnZpZXdNYXRyaXg7XG5cbiAgICAvLyBSZWFkIHRoZSB0cmFuc2xhdGlvbiBmcm9tIHRoZSBpbnZlcnNlIHZpZXcgbWF0cml4XG4gICAgdGhpcy5jYW1lcmFQb3NpdGlvbiA9IFtcbiAgICAgIHRoaXMudmlld01hdHJpeEludmVyc2VbMTJdLFxuICAgICAgdGhpcy52aWV3TWF0cml4SW52ZXJzZVsxM10sXG4gICAgICB0aGlzLnZpZXdNYXRyaXhJbnZlcnNlWzE0XVxuICAgIF07XG5cbiAgICB0aGlzLmNhbWVyYURpcmVjdGlvbiA9IFtcbiAgICAgIHRoaXMudmlld01hdHJpeFsyXSxcbiAgICAgIHRoaXMudmlld01hdHJpeFs2XSxcbiAgICAgIHRoaXMudmlld01hdHJpeFsxMF1cbiAgICBdO1xuXG4gICAgdGhpcy5jYW1lcmFVcCA9IFtcbiAgICAgIHRoaXMudmlld01hdHJpeFsxXSxcbiAgICAgIHRoaXMudmlld01hdHJpeFs1XSxcbiAgICAgIHRoaXMudmlld01hdHJpeFs5XVxuICAgIF07XG5cbiAgICAvKlxuICAgICAqIEJ1aWxkcyBtYXRyaWNlcyB0aGF0IGNvbnZlcnRzIHByZXByb2plY3RlZCBsbmdMYXRzIHRvIHNjcmVlbiBwaXhlbHNcbiAgICAgKiBhbmQgdmljZSB2ZXJzYS5cbiAgICAgKiBOb3RlOiBDdXJyZW50bHkgcmV0dXJucyBib3R0b20tbGVmdCBjb29yZGluYXRlcyFcbiAgICAgKiBOb3RlOiBTdGFydHMgd2l0aCB0aGUgR0wgcHJvamVjdGlvbiBtYXRyaXggYW5kIGFkZHMgc3RlcHMgdG8gdGhlXG4gICAgICogICAgICAgc2NhbGUgYW5kIHRyYW5zbGF0ZSB0aGF0IG1hdHJpeCBvbnRvIHRoZSB3aW5kb3cuXG4gICAgICogTm90ZTogV2ViR0wgY29udHJvbHMgY2xpcCBzcGFjZSB0byBzY3JlZW4gcHJvamVjdGlvbiB3aXRoIGdsLnZpZXdwb3J0XG4gICAgICogICAgICAgYW5kIGRvZXMgbm90IG5lZWQgdGhpcyBzdGVwLlxuICAgICAqL1xuXG4gICAgLy8gbWF0cml4IGZvciBjb252ZXJzaW9uIGZyb20gbG9jYXRpb24gdG8gc2NyZWVuIGNvb3JkaW5hdGVzXG4gICAgY29uc3QgbSA9IGNyZWF0ZU1hdDQoKTtcbiAgICBtYXQ0X3NjYWxlKG0sIG0sIFt0aGlzLndpZHRoIC8gMiwgLXRoaXMuaGVpZ2h0IC8gMiwgMV0pO1xuICAgIG1hdDRfdHJhbnNsYXRlKG0sIG0sIFsxLCAtMSwgMF0pO1xuICAgIG1hdDRfbXVsdGlwbHkobSwgbSwgdGhpcy52aWV3UHJvamVjdGlvbk1hdHJpeCk7XG4gICAgdGhpcy5waXhlbFByb2plY3Rpb25NYXRyaXggPSBtO1xuXG4gICAgdGhpcy5waXhlbFVucHJvamVjdGlvbk1hdHJpeCA9IG1hdDRfaW52ZXJ0KGNyZWF0ZU1hdDQoKSwgdGhpcy5waXhlbFByb2plY3Rpb25NYXRyaXgpO1xuICAgIGlmICghdGhpcy5waXhlbFVucHJvamVjdGlvbk1hdHJpeCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQaXhlbCBwcm9qZWN0IG1hdHJpeCBub3QgaW52ZXJ0aWJsZScpO1xuICAgIH1cbiAgfVxuXG4gIF9wcm9qZWN0RmxhdCh4eXosIHNjYWxlID0gdGhpcy5zY2FsZSkge1xuICAgIHJldHVybiB4eXo7XG4gIH1cblxuICBfdW5wcm9qZWN0RmxhdCh4eXosIHNjYWxlID0gdGhpcy5zY2FsZSkge1xuICAgIHJldHVybiB4eXo7XG4gIH1cbn1cblxuLy8gSGVscGVyLCBhdm9pZHMgbG93LXByZWNpc2lvbiAzMiBiaXQgbWF0cmljZXMgZnJvbSBnbC1tYXRyaXggbWF0NC5jcmVhdGUoKVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU1hdDQoKSB7XG4gIHJldHVybiBbMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMV07XG59XG4iXX0=