'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _viewport = require('./viewport');

var _viewport2 = _interopRequireDefault(_viewport);

var _webMercatorUtils = require('../../viewports/web-mercator-utils');

var _translate = require('gl-mat4/translate');

var _translate2 = _interopRequireDefault(_translate);

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// View and Projection Matrix calculations for mapbox-js style
// map view properties


var DEFAULT_MAP_STATE = {
  latitude: 37,
  longitude: -122,
  zoom: 11,
  pitch: 0,
  bearing: 0,
  altitude: 1.5
};

var ERR_ARGUMENT = 'Illegal argument to WebMercatorViewport';

var WebMercatorViewport = function (_Viewport) {
  _inherits(WebMercatorViewport, _Viewport);

  /**
   * @classdesc
   * Creates view/projection matrices from mercator params
   * Note: The Viewport is immutable in the sense that it only has accessors.
   * A new viewport instance should be created if any parameters have changed.
   *
   * @class
   * @param {Object} opt - options
   * @param {Boolean} mercator=true - Whether to use mercator projection
   *
   * @param {Number} opt.width=1 - Width of "viewport" or window
   * @param {Number} opt.height=1 - Height of "viewport" or window
   * @param {Array} opt.center=[0, 0] - Center of viewport
   *   [longitude, latitude] or [x, y]
   * @param {Number} opt.scale=1 - Either use scale or zoom
   * @param {Number} opt.pitch=0 - Camera angle in degrees (0 is straight down)
   * @param {Number} opt.bearing=0 - Map rotation in degrees (0 means north is up)
   * @param {Number} opt.altitude= - Altitude of camera in screen units
   *
   * Web mercator projection short-hand parameters
   * @param {Number} opt.latitude - Center of viewport on map (alternative to opt.center)
   * @param {Number} opt.longitude - Center of viewport on map (alternative to opt.center)
   * @param {Number} opt.zoom - Scale = Math.pow(2,zoom) on map (alternative to opt.scale)
    * Notes:
   *  - Only one of center or [latitude, longitude] can be specified
   *  - [latitude, longitude] can only be specified when "mercator" is true
   *  - Altitude has a default value that matches assumptions in mapbox-gl
   *  - width and height are forced to 1 if supplied as 0, to avoid
   *    division by zero. This is intended to reduce the burden of apps to
   *    to check values before instantiating a Viewport.
   */
  /* eslint-disable complexity, max-statements */
  function WebMercatorViewport() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        width = _ref.width,
        height = _ref.height,
        latitude = _ref.latitude,
        longitude = _ref.longitude,
        zoom = _ref.zoom,
        pitch = _ref.pitch,
        bearing = _ref.bearing,
        altitude = _ref.altitude,
        _ref$farZMultiplier = _ref.farZMultiplier,
        farZMultiplier = _ref$farZMultiplier === undefined ? 10 : _ref$farZMultiplier;

    _classCallCheck(this, WebMercatorViewport);

    // Viewport - support undefined arguments
    width = width !== undefined ? width : DEFAULT_MAP_STATE.width;
    height = height !== undefined ? height : DEFAULT_MAP_STATE.height;
    zoom = zoom !== undefined ? zoom : DEFAULT_MAP_STATE.zoom;
    latitude = latitude !== undefined ? latitude : DEFAULT_MAP_STATE.latitude;
    longitude = longitude !== undefined ? longitude : DEFAULT_MAP_STATE.longitude;
    bearing = bearing !== undefined ? bearing : DEFAULT_MAP_STATE.bearing;
    pitch = pitch !== undefined ? pitch : DEFAULT_MAP_STATE.pitch;
    altitude = altitude !== undefined ? altitude : DEFAULT_MAP_STATE.altitude;

    // Silently allow apps to send in 0,0 to facilitate isomorphic render etc
    width = width || 1;
    height = height || 1;

    var scale = Math.pow(2, zoom);
    // Altitude - prevent division by 0
    // TODO - just throw an Error instead?
    altitude = Math.max(0.75, altitude);

    var distanceScales = (0, _webMercatorUtils.calculateDistanceScales)({ latitude: latitude, longitude: longitude, scale: scale });

    var projectionMatrix = (0, _webMercatorUtils.makeProjectionMatrixFromMercatorParams)({
      width: width,
      height: height,
      pitch: pitch,
      bearing: bearing,
      altitude: altitude,
      farZMultiplier: farZMultiplier
    });

    // The uncentered matrix allows us two move the center addition to the
    // shader (cheap) which gives a coordinate system that has its center in
    // the layer's center position. This makes rotations and other modelMatrx
    // transforms much more useful.
    var viewMatrixUncentered = (0, _webMercatorUtils.makeUncenteredViewMatrixFromMercatorParams)({
      width: width,
      height: height,
      longitude: longitude,
      latitude: latitude,
      zoom: zoom,
      pitch: pitch,
      bearing: bearing,
      altitude: altitude,
      distanceScales: distanceScales
    });

    // Make a centered version of the matrix for projection modes without an offset
    var center = (0, _webMercatorUtils.projectFlat)([longitude, latitude], scale);

    var viewMatrix = (0, _translate2.default)((0, _viewport.createMat4)(), viewMatrixUncentered, [-center[0], -center[1], 0]);

    // Save parameters
    var _this = _possibleConstructorReturn(this, (WebMercatorViewport.__proto__ || Object.getPrototypeOf(WebMercatorViewport)).call(this, {
      width: width,
      height: height,
      viewMatrix: viewMatrix,
      projectionMatrix: projectionMatrix,
      distanceScales: distanceScales
    }));

    _this.latitude = latitude;
    _this.longitude = longitude;
    _this.zoom = zoom;
    _this.pitch = pitch;
    _this.bearing = bearing;
    _this.altitude = altitude;

    // Save calculated values
    _this.scale = scale;
    _this.center = center;
    _this.viewMatrixUncentered = viewMatrixUncentered;

    // Bind methods
    _this.metersToLngLatDelta = _this.metersToLngLatDelta.bind(_this);
    _this.lngLatDeltaToMeters = _this.lngLatDeltaToMeters.bind(_this);
    _this.addMetersToLngLat = _this.addMetersToLngLat.bind(_this);

    Object.freeze(_this);
    return _this;
  }
  /* eslint-enable complexity, max-statements */

  /**
   * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.
   * Performs the nonlinear part of the web mercator projection.
   * Remaining projection is done with 4x4 matrices which also handles
   * perspective.
   *
   * @param {Array} lngLat - [lng, lat] coordinates
   *   Specifies a point on the sphere to project onto the map.
   * @return {Array} [x,y] coordinates.
   */


  _createClass(WebMercatorViewport, [{
    key: '_projectFlat',
    value: function _projectFlat(lngLat) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      return (0, _webMercatorUtils.projectFlat)(lngLat, scale);
    }

    /**
     * Unproject world point [x,y] on map onto {lat, lon} on sphere
     *
     * @param {object|Vector} xy - object with {x,y} members
     *  representing point on projected map plane
     * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.
     *   Has toArray method if you need a GeoJSON Array.
     *   Per cartographic tradition, lat and lon are specified as degrees.
     */

  }, {
    key: '_unprojectFlat',
    value: function _unprojectFlat(xy) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      return (0, _webMercatorUtils.unprojectFlat)(xy, scale);
    }

    /*
    getLngLatAtViewportPosition(lnglat, xy) {
      const c = this.locationCoordinate(lnglat);
      const coordAtPoint = this.pointCoordinate(xy);
      const coordCenter = this.pointCoordinate(this.centerPoint);
      const translate = coordAtPoint._sub(c);
      this.center = this.coordinateLocation(coordCenter._sub(translate));
    }
    */

    /**
     * Converts a meter offset to a lnglat offset
     *
     * Note: Uses simple linear approximation around the viewport center
     * Error increases with size of offset (roughly 1% per 100km)
     *
     * @param {[Number,Number]|[Number,Number,Number]) xyz - array of meter deltas
     * @return {[Number,Number]|[Number,Number,Number]) - array of [lng,lat,z] deltas
     */

  }, {
    key: 'metersToLngLatDelta',
    value: function metersToLngLatDelta(xyz) {
      var _xyz = _slicedToArray(xyz, 3),
          x = _xyz[0],
          y = _xyz[1],
          _xyz$ = _xyz[2],
          z = _xyz$ === undefined ? 0 : _xyz$;

      (0, _assert2.default)(Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(z), ERR_ARGUMENT);
      var _distanceScales = this.distanceScales,
          pixelsPerMeter = _distanceScales.pixelsPerMeter,
          degreesPerPixel = _distanceScales.degreesPerPixel;

      var deltaLng = x * pixelsPerMeter[0] * degreesPerPixel[0];
      var deltaLat = y * pixelsPerMeter[1] * degreesPerPixel[1];
      return xyz.length === 2 ? [deltaLng, deltaLat] : [deltaLng, deltaLat, z];
    }

    /**
     * Converts a lnglat offset to a meter offset
     *
     * Note: Uses simple linear approximation around the viewport center
     * Error increases with size of offset (roughly 1% per 100km)
     *
     * @param {[Number,Number]|[Number,Number,Number]) deltaLngLatZ - array of [lng,lat,z] deltas
     * @return {[Number,Number]|[Number,Number,Number]) - array of meter deltas
     */

  }, {
    key: 'lngLatDeltaToMeters',
    value: function lngLatDeltaToMeters(deltaLngLatZ) {
      var _deltaLngLatZ = _slicedToArray(deltaLngLatZ, 3),
          deltaLng = _deltaLngLatZ[0],
          deltaLat = _deltaLngLatZ[1],
          _deltaLngLatZ$ = _deltaLngLatZ[2],
          deltaZ = _deltaLngLatZ$ === undefined ? 0 : _deltaLngLatZ$;

      (0, _assert2.default)(Number.isFinite(deltaLng) && Number.isFinite(deltaLat) && Number.isFinite(deltaZ), ERR_ARGUMENT);
      var _distanceScales2 = this.distanceScales,
          pixelsPerDegree = _distanceScales2.pixelsPerDegree,
          metersPerPixel = _distanceScales2.metersPerPixel;

      var deltaX = deltaLng * pixelsPerDegree[0] * metersPerPixel[0];
      var deltaY = deltaLat * pixelsPerDegree[1] * metersPerPixel[1];
      return deltaLngLatZ.length === 2 ? [deltaX, deltaY] : [deltaX, deltaY, deltaZ];
    }

    /**
     * Add a meter delta to a base lnglat coordinate, returning a new lnglat array
     *
     * Note: Uses simple linear approximation around the viewport center
     * Error increases with size of offset (roughly 1% per 100km)
     *
     * @param {[Number,Number]|[Number,Number,Number]) lngLatZ - base coordinate
     * @param {[Number,Number]|[Number,Number,Number]) xyz - array of meter deltas
     * @return {[Number,Number]|[Number,Number,Number]) array of [lng,lat,z] deltas
     */

  }, {
    key: 'addMetersToLngLat',
    value: function addMetersToLngLat(lngLatZ, xyz) {
      var _lngLatZ = _slicedToArray(lngLatZ, 3),
          lng = _lngLatZ[0],
          lat = _lngLatZ[1],
          _lngLatZ$ = _lngLatZ[2],
          Z = _lngLatZ$ === undefined ? 0 : _lngLatZ$;

      var _metersToLngLatDelta = this.metersToLngLatDelta(xyz),
          _metersToLngLatDelta2 = _slicedToArray(_metersToLngLatDelta, 3),
          deltaLng = _metersToLngLatDelta2[0],
          deltaLat = _metersToLngLatDelta2[1],
          _metersToLngLatDelta3 = _metersToLngLatDelta2[2],
          deltaZ = _metersToLngLatDelta3 === undefined ? 0 : _metersToLngLatDelta3;

      return lngLatZ.length === 2 ? [lng + deltaLng, lat + deltaLat] : [lng + deltaLng, lat + deltaLat, Z + deltaZ];
    }
  }]);

  return WebMercatorViewport;
}(_viewport2.default);

exports.default = WebMercatorViewport;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIvdmlld3BvcnRzL3dlYi1tZXJjYXRvci12aWV3cG9ydC5qcyJdLCJuYW1lcyI6WyJERUZBVUxUX01BUF9TVEFURSIsImxhdGl0dWRlIiwibG9uZ2l0dWRlIiwiem9vbSIsInBpdGNoIiwiYmVhcmluZyIsImFsdGl0dWRlIiwiRVJSX0FSR1VNRU5UIiwiV2ViTWVyY2F0b3JWaWV3cG9ydCIsIndpZHRoIiwiaGVpZ2h0IiwiZmFyWk11bHRpcGxpZXIiLCJ1bmRlZmluZWQiLCJzY2FsZSIsIk1hdGgiLCJwb3ciLCJtYXgiLCJkaXN0YW5jZVNjYWxlcyIsInByb2plY3Rpb25NYXRyaXgiLCJ2aWV3TWF0cml4VW5jZW50ZXJlZCIsImNlbnRlciIsInZpZXdNYXRyaXgiLCJtZXRlcnNUb0xuZ0xhdERlbHRhIiwiYmluZCIsImxuZ0xhdERlbHRhVG9NZXRlcnMiLCJhZGRNZXRlcnNUb0xuZ0xhdCIsIk9iamVjdCIsImZyZWV6ZSIsImxuZ0xhdCIsInh5IiwieHl6IiwieCIsInkiLCJ6IiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJwaXhlbHNQZXJNZXRlciIsImRlZ3JlZXNQZXJQaXhlbCIsImRlbHRhTG5nIiwiZGVsdGFMYXQiLCJsZW5ndGgiLCJkZWx0YUxuZ0xhdFoiLCJkZWx0YVoiLCJwaXhlbHNQZXJEZWdyZWUiLCJtZXRlcnNQZXJQaXhlbCIsImRlbHRhWCIsImRlbHRhWSIsImxuZ0xhdFoiLCJsbmciLCJsYXQiLCJaIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBc0JBOzs7O0FBRUE7O0FBTUE7Ozs7QUFDQTs7Ozs7Ozs7OzsrZUEvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBWUEsSUFBTUEsb0JBQW9CO0FBQ3hCQyxZQUFVLEVBRGM7QUFFeEJDLGFBQVcsQ0FBQyxHQUZZO0FBR3hCQyxRQUFNLEVBSGtCO0FBSXhCQyxTQUFPLENBSmlCO0FBS3hCQyxXQUFTLENBTGU7QUFNeEJDLFlBQVU7QUFOYyxDQUExQjs7QUFTQSxJQUFNQyxlQUFlLHlDQUFyQjs7SUFFcUJDLG1COzs7QUFDbkI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQ0E7QUFDQSxpQ0FXUTtBQUFBLG1GQUFKLEVBQUk7QUFBQSxRQVROQyxLQVNNLFFBVE5BLEtBU007QUFBQSxRQVJOQyxNQVFNLFFBUk5BLE1BUU07QUFBQSxRQVBOVCxRQU9NLFFBUE5BLFFBT007QUFBQSxRQU5OQyxTQU1NLFFBTk5BLFNBTU07QUFBQSxRQUxOQyxJQUtNLFFBTE5BLElBS007QUFBQSxRQUpOQyxLQUlNLFFBSk5BLEtBSU07QUFBQSxRQUhOQyxPQUdNLFFBSE5BLE9BR007QUFBQSxRQUZOQyxRQUVNLFFBRk5BLFFBRU07QUFBQSxtQ0FETkssY0FDTTtBQUFBLFFBRE5BLGNBQ00sdUNBRFcsRUFDWDs7QUFBQTs7QUFDTjtBQUNBRixZQUFRQSxVQUFVRyxTQUFWLEdBQXNCSCxLQUF0QixHQUE4QlQsa0JBQWtCUyxLQUF4RDtBQUNBQyxhQUFTQSxXQUFXRSxTQUFYLEdBQXVCRixNQUF2QixHQUFnQ1Ysa0JBQWtCVSxNQUEzRDtBQUNBUCxXQUFPQSxTQUFTUyxTQUFULEdBQXFCVCxJQUFyQixHQUE0Qkgsa0JBQWtCRyxJQUFyRDtBQUNBRixlQUFXQSxhQUFhVyxTQUFiLEdBQXlCWCxRQUF6QixHQUFvQ0Qsa0JBQWtCQyxRQUFqRTtBQUNBQyxnQkFBWUEsY0FBY1UsU0FBZCxHQUEwQlYsU0FBMUIsR0FBc0NGLGtCQUFrQkUsU0FBcEU7QUFDQUcsY0FBVUEsWUFBWU8sU0FBWixHQUF3QlAsT0FBeEIsR0FBa0NMLGtCQUFrQkssT0FBOUQ7QUFDQUQsWUFBUUEsVUFBVVEsU0FBVixHQUFzQlIsS0FBdEIsR0FBOEJKLGtCQUFrQkksS0FBeEQ7QUFDQUUsZUFBV0EsYUFBYU0sU0FBYixHQUF5Qk4sUUFBekIsR0FBb0NOLGtCQUFrQk0sUUFBakU7O0FBRUE7QUFDQUcsWUFBUUEsU0FBUyxDQUFqQjtBQUNBQyxhQUFTQSxVQUFVLENBQW5COztBQUVBLFFBQU1HLFFBQVFDLEtBQUtDLEdBQUwsQ0FBUyxDQUFULEVBQVlaLElBQVosQ0FBZDtBQUNBO0FBQ0E7QUFDQUcsZUFBV1EsS0FBS0UsR0FBTCxDQUFTLElBQVQsRUFBZVYsUUFBZixDQUFYOztBQUVBLFFBQU1XLGlCQUFpQiwrQ0FBd0IsRUFBQ2hCLGtCQUFELEVBQVdDLG9CQUFYLEVBQXNCVyxZQUF0QixFQUF4QixDQUF2Qjs7QUFFQSxRQUFNSyxtQkFBbUIsOERBQXVDO0FBQzlEVCxrQkFEOEQ7QUFFOURDLG9CQUY4RDtBQUc5RE4sa0JBSDhEO0FBSTlEQyxzQkFKOEQ7QUFLOURDLHdCQUw4RDtBQU05REs7QUFOOEQsS0FBdkMsQ0FBekI7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFNUSx1QkFBdUIsa0VBQTJDO0FBQ3RFVixrQkFEc0U7QUFFdEVDLG9CQUZzRTtBQUd0RVIsMEJBSHNFO0FBSXRFRCx3QkFKc0U7QUFLdEVFLGdCQUxzRTtBQU10RUMsa0JBTnNFO0FBT3RFQyxzQkFQc0U7QUFRdEVDLHdCQVJzRTtBQVN0RVc7QUFUc0UsS0FBM0MsQ0FBN0I7O0FBWUE7QUFDQSxRQUFNRyxTQUFTLG1DQUFZLENBQUNsQixTQUFELEVBQVlELFFBQVosQ0FBWixFQUFtQ1ksS0FBbkMsQ0FBZjs7QUFFQSxRQUFNUSxhQUFhLHlCQUNqQiwyQkFEaUIsRUFDSEYsb0JBREcsRUFDbUIsQ0FBQyxDQUFDQyxPQUFPLENBQVAsQ0FBRixFQUFhLENBQUNBLE9BQU8sQ0FBUCxDQUFkLEVBQXlCLENBQXpCLENBRG5CLENBQW5COztBQVdBO0FBN0RNLDBJQXFEQTtBQUNKWCxrQkFESTtBQUVKQyxvQkFGSTtBQUdKVyw0QkFISTtBQUlKSCx3Q0FKSTtBQUtKRDtBQUxJLEtBckRBOztBQThETixVQUFLaEIsUUFBTCxHQUFnQkEsUUFBaEI7QUFDQSxVQUFLQyxTQUFMLEdBQWlCQSxTQUFqQjtBQUNBLFVBQUtDLElBQUwsR0FBWUEsSUFBWjtBQUNBLFVBQUtDLEtBQUwsR0FBYUEsS0FBYjtBQUNBLFVBQUtDLE9BQUwsR0FBZUEsT0FBZjtBQUNBLFVBQUtDLFFBQUwsR0FBZ0JBLFFBQWhCOztBQUVBO0FBQ0EsVUFBS08sS0FBTCxHQUFhQSxLQUFiO0FBQ0EsVUFBS08sTUFBTCxHQUFjQSxNQUFkO0FBQ0EsVUFBS0Qsb0JBQUwsR0FBNEJBLG9CQUE1Qjs7QUFFQTtBQUNBLFVBQUtHLG1CQUFMLEdBQTJCLE1BQUtBLG1CQUFMLENBQXlCQyxJQUF6QixPQUEzQjtBQUNBLFVBQUtDLG1CQUFMLEdBQTJCLE1BQUtBLG1CQUFMLENBQXlCRCxJQUF6QixPQUEzQjtBQUNBLFVBQUtFLGlCQUFMLEdBQXlCLE1BQUtBLGlCQUFMLENBQXVCRixJQUF2QixPQUF6Qjs7QUFFQUcsV0FBT0MsTUFBUDtBQS9FTTtBQWdGUDtBQUNEOztBQUVBOzs7Ozs7Ozs7Ozs7OztpQ0FVYUMsTSxFQUE0QjtBQUFBLFVBQXBCZixLQUFvQix1RUFBWixLQUFLQSxLQUFPOztBQUN2QyxhQUFPLG1DQUFZZSxNQUFaLEVBQW9CZixLQUFwQixDQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7OzttQ0FTZWdCLEUsRUFBd0I7QUFBQSxVQUFwQmhCLEtBQW9CLHVFQUFaLEtBQUtBLEtBQU87O0FBQ3JDLGFBQU8scUNBQWNnQixFQUFkLEVBQWtCaEIsS0FBbEIsQ0FBUDtBQUNEOztBQUVEOzs7Ozs7Ozs7O0FBVUE7Ozs7Ozs7Ozs7Ozt3Q0FTb0JpQixHLEVBQUs7QUFBQSxnQ0FDREEsR0FEQztBQUFBLFVBQ2hCQyxDQURnQjtBQUFBLFVBQ2JDLENBRGE7QUFBQTtBQUFBLFVBQ1ZDLENBRFUseUJBQ04sQ0FETTs7QUFFdkIsNEJBQU9DLE9BQU9DLFFBQVAsQ0FBZ0JKLENBQWhCLEtBQXNCRyxPQUFPQyxRQUFQLENBQWdCSCxDQUFoQixDQUF0QixJQUE0Q0UsT0FBT0MsUUFBUCxDQUFnQkYsQ0FBaEIsQ0FBbkQsRUFBdUUxQixZQUF2RTtBQUZ1Qiw0QkFHbUIsS0FBS1UsY0FIeEI7QUFBQSxVQUdoQm1CLGNBSGdCLG1CQUdoQkEsY0FIZ0I7QUFBQSxVQUdBQyxlQUhBLG1CQUdBQSxlQUhBOztBQUl2QixVQUFNQyxXQUFXUCxJQUFJSyxlQUFlLENBQWYsQ0FBSixHQUF3QkMsZ0JBQWdCLENBQWhCLENBQXpDO0FBQ0EsVUFBTUUsV0FBV1AsSUFBSUksZUFBZSxDQUFmLENBQUosR0FBd0JDLGdCQUFnQixDQUFoQixDQUF6QztBQUNBLGFBQU9QLElBQUlVLE1BQUosS0FBZSxDQUFmLEdBQW1CLENBQUNGLFFBQUQsRUFBV0MsUUFBWCxDQUFuQixHQUEwQyxDQUFDRCxRQUFELEVBQVdDLFFBQVgsRUFBcUJOLENBQXJCLENBQWpEO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7Ozt3Q0FTb0JRLFksRUFBYztBQUFBLHlDQUNTQSxZQURUO0FBQUEsVUFDekJILFFBRHlCO0FBQUEsVUFDZkMsUUFEZTtBQUFBO0FBQUEsVUFDTEcsTUFESyxrQ0FDSSxDQURKOztBQUVoQyw0QkFBT1IsT0FBT0MsUUFBUCxDQUFnQkcsUUFBaEIsS0FBNkJKLE9BQU9DLFFBQVAsQ0FBZ0JJLFFBQWhCLENBQTdCLElBQTBETCxPQUFPQyxRQUFQLENBQWdCTyxNQUFoQixDQUFqRSxFQUNFbkMsWUFERjtBQUZnQyw2QkFJVSxLQUFLVSxjQUpmO0FBQUEsVUFJekIwQixlQUp5QixvQkFJekJBLGVBSnlCO0FBQUEsVUFJUkMsY0FKUSxvQkFJUkEsY0FKUTs7QUFLaEMsVUFBTUMsU0FBU1AsV0FBV0ssZ0JBQWdCLENBQWhCLENBQVgsR0FBZ0NDLGVBQWUsQ0FBZixDQUEvQztBQUNBLFVBQU1FLFNBQVNQLFdBQVdJLGdCQUFnQixDQUFoQixDQUFYLEdBQWdDQyxlQUFlLENBQWYsQ0FBL0M7QUFDQSxhQUFPSCxhQUFhRCxNQUFiLEtBQXdCLENBQXhCLEdBQTRCLENBQUNLLE1BQUQsRUFBU0MsTUFBVCxDQUE1QixHQUErQyxDQUFDRCxNQUFELEVBQVNDLE1BQVQsRUFBaUJKLE1BQWpCLENBQXREO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7c0NBVWtCSyxPLEVBQVNqQixHLEVBQUs7QUFBQSxvQ0FDSmlCLE9BREk7QUFBQSxVQUN2QkMsR0FEdUI7QUFBQSxVQUNsQkMsR0FEa0I7QUFBQTtBQUFBLFVBQ2JDLENBRGEsNkJBQ1QsQ0FEUzs7QUFBQSxpQ0FFVyxLQUFLNUIsbUJBQUwsQ0FBeUJRLEdBQXpCLENBRlg7QUFBQTtBQUFBLFVBRXZCUSxRQUZ1QjtBQUFBLFVBRWJDLFFBRmE7QUFBQTtBQUFBLFVBRUhHLE1BRkcseUNBRU0sQ0FGTjs7QUFHOUIsYUFBT0ssUUFBUVAsTUFBUixLQUFtQixDQUFuQixHQUNMLENBQUNRLE1BQU1WLFFBQVAsRUFBaUJXLE1BQU1WLFFBQXZCLENBREssR0FFTCxDQUFDUyxNQUFNVixRQUFQLEVBQWlCVyxNQUFNVixRQUF2QixFQUFpQ1csSUFBSVIsTUFBckMsQ0FGRjtBQUdEOzs7Ozs7a0JBMU5rQmxDLG1CIiwiZmlsZSI6IndlYi1tZXJjYXRvci12aWV3cG9ydC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG4vLyBWaWV3IGFuZCBQcm9qZWN0aW9uIE1hdHJpeCBjYWxjdWxhdGlvbnMgZm9yIG1hcGJveC1qcyBzdHlsZVxuLy8gbWFwIHZpZXcgcHJvcGVydGllc1xuaW1wb3J0IFZpZXdwb3J0LCB7Y3JlYXRlTWF0NH0gZnJvbSAnLi92aWV3cG9ydCc7XG5cbmltcG9ydCB7XG4gIHByb2plY3RGbGF0LCB1bnByb2plY3RGbGF0LFxuICBjYWxjdWxhdGVEaXN0YW5jZVNjYWxlcyxcbiAgbWFrZVByb2plY3Rpb25NYXRyaXhGcm9tTWVyY2F0b3JQYXJhbXMsIG1ha2VVbmNlbnRlcmVkVmlld01hdHJpeEZyb21NZXJjYXRvclBhcmFtc1xufSBmcm9tICcuLi8uLi92aWV3cG9ydHMvd2ViLW1lcmNhdG9yLXV0aWxzJztcblxuaW1wb3J0IG1hdDRfdHJhbnNsYXRlIGZyb20gJ2dsLW1hdDQvdHJhbnNsYXRlJztcbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcblxuY29uc3QgREVGQVVMVF9NQVBfU1RBVEUgPSB7XG4gIGxhdGl0dWRlOiAzNyxcbiAgbG9uZ2l0dWRlOiAtMTIyLFxuICB6b29tOiAxMSxcbiAgcGl0Y2g6IDAsXG4gIGJlYXJpbmc6IDAsXG4gIGFsdGl0dWRlOiAxLjVcbn07XG5cbmNvbnN0IEVSUl9BUkdVTUVOVCA9ICdJbGxlZ2FsIGFyZ3VtZW50IHRvIFdlYk1lcmNhdG9yVmlld3BvcnQnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXZWJNZXJjYXRvclZpZXdwb3J0IGV4dGVuZHMgVmlld3BvcnQge1xuICAvKipcbiAgICogQGNsYXNzZGVzY1xuICAgKiBDcmVhdGVzIHZpZXcvcHJvamVjdGlvbiBtYXRyaWNlcyBmcm9tIG1lcmNhdG9yIHBhcmFtc1xuICAgKiBOb3RlOiBUaGUgVmlld3BvcnQgaXMgaW1tdXRhYmxlIGluIHRoZSBzZW5zZSB0aGF0IGl0IG9ubHkgaGFzIGFjY2Vzc29ycy5cbiAgICogQSBuZXcgdmlld3BvcnQgaW5zdGFuY2Ugc2hvdWxkIGJlIGNyZWF0ZWQgaWYgYW55IHBhcmFtZXRlcnMgaGF2ZSBjaGFuZ2VkLlxuICAgKlxuICAgKiBAY2xhc3NcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdCAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtCb29sZWFufSBtZXJjYXRvcj10cnVlIC0gV2hldGhlciB0byB1c2UgbWVyY2F0b3IgcHJvamVjdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LndpZHRoPTEgLSBXaWR0aCBvZiBcInZpZXdwb3J0XCIgb3Igd2luZG93XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQuaGVpZ2h0PTEgLSBIZWlnaHQgb2YgXCJ2aWV3cG9ydFwiIG9yIHdpbmRvd1xuICAgKiBAcGFyYW0ge0FycmF5fSBvcHQuY2VudGVyPVswLCAwXSAtIENlbnRlciBvZiB2aWV3cG9ydFxuICAgKiAgIFtsb25naXR1ZGUsIGxhdGl0dWRlXSBvciBbeCwgeV1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC5zY2FsZT0xIC0gRWl0aGVyIHVzZSBzY2FsZSBvciB6b29tXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQucGl0Y2g9MCAtIENhbWVyYSBhbmdsZSBpbiBkZWdyZWVzICgwIGlzIHN0cmFpZ2h0IGRvd24pXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQuYmVhcmluZz0wIC0gTWFwIHJvdGF0aW9uIGluIGRlZ3JlZXMgKDAgbWVhbnMgbm9ydGggaXMgdXApXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQuYWx0aXR1ZGU9IC0gQWx0aXR1ZGUgb2YgY2FtZXJhIGluIHNjcmVlbiB1bml0c1xuICAgKlxuICAgKiBXZWIgbWVyY2F0b3IgcHJvamVjdGlvbiBzaG9ydC1oYW5kIHBhcmFtZXRlcnNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC5sYXRpdHVkZSAtIENlbnRlciBvZiB2aWV3cG9ydCBvbiBtYXAgKGFsdGVybmF0aXZlIHRvIG9wdC5jZW50ZXIpXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQubG9uZ2l0dWRlIC0gQ2VudGVyIG9mIHZpZXdwb3J0IG9uIG1hcCAoYWx0ZXJuYXRpdmUgdG8gb3B0LmNlbnRlcilcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC56b29tIC0gU2NhbGUgPSBNYXRoLnBvdygyLHpvb20pIG9uIG1hcCAoYWx0ZXJuYXRpdmUgdG8gb3B0LnNjYWxlKVxuXG4gICAqIE5vdGVzOlxuICAgKiAgLSBPbmx5IG9uZSBvZiBjZW50ZXIgb3IgW2xhdGl0dWRlLCBsb25naXR1ZGVdIGNhbiBiZSBzcGVjaWZpZWRcbiAgICogIC0gW2xhdGl0dWRlLCBsb25naXR1ZGVdIGNhbiBvbmx5IGJlIHNwZWNpZmllZCB3aGVuIFwibWVyY2F0b3JcIiBpcyB0cnVlXG4gICAqICAtIEFsdGl0dWRlIGhhcyBhIGRlZmF1bHQgdmFsdWUgdGhhdCBtYXRjaGVzIGFzc3VtcHRpb25zIGluIG1hcGJveC1nbFxuICAgKiAgLSB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBmb3JjZWQgdG8gMSBpZiBzdXBwbGllZCBhcyAwLCB0byBhdm9pZFxuICAgKiAgICBkaXZpc2lvbiBieSB6ZXJvLiBUaGlzIGlzIGludGVuZGVkIHRvIHJlZHVjZSB0aGUgYnVyZGVuIG9mIGFwcHMgdG9cbiAgICogICAgdG8gY2hlY2sgdmFsdWVzIGJlZm9yZSBpbnN0YW50aWF0aW5nIGEgVmlld3BvcnQuXG4gICAqL1xuICAvKiBlc2xpbnQtZGlzYWJsZSBjb21wbGV4aXR5LCBtYXgtc3RhdGVtZW50cyAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgLy8gTWFwIHN0YXRlXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIGxhdGl0dWRlLFxuICAgIGxvbmdpdHVkZSxcbiAgICB6b29tLFxuICAgIHBpdGNoLFxuICAgIGJlYXJpbmcsXG4gICAgYWx0aXR1ZGUsXG4gICAgZmFyWk11bHRpcGxpZXIgPSAxMFxuICB9ID0ge30pIHtcbiAgICAvLyBWaWV3cG9ydCAtIHN1cHBvcnQgdW5kZWZpbmVkIGFyZ3VtZW50c1xuICAgIHdpZHRoID0gd2lkdGggIT09IHVuZGVmaW5lZCA/IHdpZHRoIDogREVGQVVMVF9NQVBfU1RBVEUud2lkdGg7XG4gICAgaGVpZ2h0ID0gaGVpZ2h0ICE9PSB1bmRlZmluZWQgPyBoZWlnaHQgOiBERUZBVUxUX01BUF9TVEFURS5oZWlnaHQ7XG4gICAgem9vbSA9IHpvb20gIT09IHVuZGVmaW5lZCA/IHpvb20gOiBERUZBVUxUX01BUF9TVEFURS56b29tO1xuICAgIGxhdGl0dWRlID0gbGF0aXR1ZGUgIT09IHVuZGVmaW5lZCA/IGxhdGl0dWRlIDogREVGQVVMVF9NQVBfU1RBVEUubGF0aXR1ZGU7XG4gICAgbG9uZ2l0dWRlID0gbG9uZ2l0dWRlICE9PSB1bmRlZmluZWQgPyBsb25naXR1ZGUgOiBERUZBVUxUX01BUF9TVEFURS5sb25naXR1ZGU7XG4gICAgYmVhcmluZyA9IGJlYXJpbmcgIT09IHVuZGVmaW5lZCA/IGJlYXJpbmcgOiBERUZBVUxUX01BUF9TVEFURS5iZWFyaW5nO1xuICAgIHBpdGNoID0gcGl0Y2ggIT09IHVuZGVmaW5lZCA/IHBpdGNoIDogREVGQVVMVF9NQVBfU1RBVEUucGl0Y2g7XG4gICAgYWx0aXR1ZGUgPSBhbHRpdHVkZSAhPT0gdW5kZWZpbmVkID8gYWx0aXR1ZGUgOiBERUZBVUxUX01BUF9TVEFURS5hbHRpdHVkZTtcblxuICAgIC8vIFNpbGVudGx5IGFsbG93IGFwcHMgdG8gc2VuZCBpbiAwLDAgdG8gZmFjaWxpdGF0ZSBpc29tb3JwaGljIHJlbmRlciBldGNcbiAgICB3aWR0aCA9IHdpZHRoIHx8IDE7XG4gICAgaGVpZ2h0ID0gaGVpZ2h0IHx8IDE7XG5cbiAgICBjb25zdCBzY2FsZSA9IE1hdGgucG93KDIsIHpvb20pO1xuICAgIC8vIEFsdGl0dWRlIC0gcHJldmVudCBkaXZpc2lvbiBieSAwXG4gICAgLy8gVE9ETyAtIGp1c3QgdGhyb3cgYW4gRXJyb3IgaW5zdGVhZD9cbiAgICBhbHRpdHVkZSA9IE1hdGgubWF4KDAuNzUsIGFsdGl0dWRlKTtcblxuICAgIGNvbnN0IGRpc3RhbmNlU2NhbGVzID0gY2FsY3VsYXRlRGlzdGFuY2VTY2FsZXMoe2xhdGl0dWRlLCBsb25naXR1ZGUsIHNjYWxlfSk7XG5cbiAgICBjb25zdCBwcm9qZWN0aW9uTWF0cml4ID0gbWFrZVByb2plY3Rpb25NYXRyaXhGcm9tTWVyY2F0b3JQYXJhbXMoe1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBwaXRjaCxcbiAgICAgIGJlYXJpbmcsXG4gICAgICBhbHRpdHVkZSxcbiAgICAgIGZhclpNdWx0aXBsaWVyXG4gICAgfSk7XG5cbiAgICAvLyBUaGUgdW5jZW50ZXJlZCBtYXRyaXggYWxsb3dzIHVzIHR3byBtb3ZlIHRoZSBjZW50ZXIgYWRkaXRpb24gdG8gdGhlXG4gICAgLy8gc2hhZGVyIChjaGVhcCkgd2hpY2ggZ2l2ZXMgYSBjb29yZGluYXRlIHN5c3RlbSB0aGF0IGhhcyBpdHMgY2VudGVyIGluXG4gICAgLy8gdGhlIGxheWVyJ3MgY2VudGVyIHBvc2l0aW9uLiBUaGlzIG1ha2VzIHJvdGF0aW9ucyBhbmQgb3RoZXIgbW9kZWxNYXRyeFxuICAgIC8vIHRyYW5zZm9ybXMgbXVjaCBtb3JlIHVzZWZ1bC5cbiAgICBjb25zdCB2aWV3TWF0cml4VW5jZW50ZXJlZCA9IG1ha2VVbmNlbnRlcmVkVmlld01hdHJpeEZyb21NZXJjYXRvclBhcmFtcyh7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIGxvbmdpdHVkZSxcbiAgICAgIGxhdGl0dWRlLFxuICAgICAgem9vbSxcbiAgICAgIHBpdGNoLFxuICAgICAgYmVhcmluZyxcbiAgICAgIGFsdGl0dWRlLFxuICAgICAgZGlzdGFuY2VTY2FsZXNcbiAgICB9KTtcblxuICAgIC8vIE1ha2UgYSBjZW50ZXJlZCB2ZXJzaW9uIG9mIHRoZSBtYXRyaXggZm9yIHByb2plY3Rpb24gbW9kZXMgd2l0aG91dCBhbiBvZmZzZXRcbiAgICBjb25zdCBjZW50ZXIgPSBwcm9qZWN0RmxhdChbbG9uZ2l0dWRlLCBsYXRpdHVkZV0sIHNjYWxlKTtcblxuICAgIGNvbnN0IHZpZXdNYXRyaXggPSBtYXQ0X3RyYW5zbGF0ZShcbiAgICAgIGNyZWF0ZU1hdDQoKSwgdmlld01hdHJpeFVuY2VudGVyZWQsIFstY2VudGVyWzBdLCAtY2VudGVyWzFdLCAwXSk7XG5cbiAgICBzdXBlcih7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHZpZXdNYXRyaXgsXG4gICAgICBwcm9qZWN0aW9uTWF0cml4LFxuICAgICAgZGlzdGFuY2VTY2FsZXNcbiAgICB9KTtcblxuICAgIC8vIFNhdmUgcGFyYW1ldGVyc1xuICAgIHRoaXMubGF0aXR1ZGUgPSBsYXRpdHVkZTtcbiAgICB0aGlzLmxvbmdpdHVkZSA9IGxvbmdpdHVkZTtcbiAgICB0aGlzLnpvb20gPSB6b29tO1xuICAgIHRoaXMucGl0Y2ggPSBwaXRjaDtcbiAgICB0aGlzLmJlYXJpbmcgPSBiZWFyaW5nO1xuICAgIHRoaXMuYWx0aXR1ZGUgPSBhbHRpdHVkZTtcblxuICAgIC8vIFNhdmUgY2FsY3VsYXRlZCB2YWx1ZXNcbiAgICB0aGlzLnNjYWxlID0gc2NhbGU7XG4gICAgdGhpcy5jZW50ZXIgPSBjZW50ZXI7XG4gICAgdGhpcy52aWV3TWF0cml4VW5jZW50ZXJlZCA9IHZpZXdNYXRyaXhVbmNlbnRlcmVkO1xuXG4gICAgLy8gQmluZCBtZXRob2RzXG4gICAgdGhpcy5tZXRlcnNUb0xuZ0xhdERlbHRhID0gdGhpcy5tZXRlcnNUb0xuZ0xhdERlbHRhLmJpbmQodGhpcyk7XG4gICAgdGhpcy5sbmdMYXREZWx0YVRvTWV0ZXJzID0gdGhpcy5sbmdMYXREZWx0YVRvTWV0ZXJzLmJpbmQodGhpcyk7XG4gICAgdGhpcy5hZGRNZXRlcnNUb0xuZ0xhdCA9IHRoaXMuYWRkTWV0ZXJzVG9MbmdMYXQuYmluZCh0aGlzKTtcblxuICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSBjb21wbGV4aXR5LCBtYXgtc3RhdGVtZW50cyAqL1xuXG4gIC8qKlxuICAgKiBQcm9qZWN0IFtsbmcsbGF0XSBvbiBzcGhlcmUgb250byBbeCx5XSBvbiA1MTIqNTEyIE1lcmNhdG9yIFpvb20gMCB0aWxlLlxuICAgKiBQZXJmb3JtcyB0aGUgbm9ubGluZWFyIHBhcnQgb2YgdGhlIHdlYiBtZXJjYXRvciBwcm9qZWN0aW9uLlxuICAgKiBSZW1haW5pbmcgcHJvamVjdGlvbiBpcyBkb25lIHdpdGggNHg0IG1hdHJpY2VzIHdoaWNoIGFsc28gaGFuZGxlc1xuICAgKiBwZXJzcGVjdGl2ZS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gbG5nTGF0IC0gW2xuZywgbGF0XSBjb29yZGluYXRlc1xuICAgKiAgIFNwZWNpZmllcyBhIHBvaW50IG9uIHRoZSBzcGhlcmUgdG8gcHJvamVjdCBvbnRvIHRoZSBtYXAuXG4gICAqIEByZXR1cm4ge0FycmF5fSBbeCx5XSBjb29yZGluYXRlcy5cbiAgICovXG4gIF9wcm9qZWN0RmxhdChsbmdMYXQsIHNjYWxlID0gdGhpcy5zY2FsZSkge1xuICAgIHJldHVybiBwcm9qZWN0RmxhdChsbmdMYXQsIHNjYWxlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnByb2plY3Qgd29ybGQgcG9pbnQgW3gseV0gb24gbWFwIG9udG8ge2xhdCwgbG9ufSBvbiBzcGhlcmVcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R8VmVjdG9yfSB4eSAtIG9iamVjdCB3aXRoIHt4LHl9IG1lbWJlcnNcbiAgICogIHJlcHJlc2VudGluZyBwb2ludCBvbiBwcm9qZWN0ZWQgbWFwIHBsYW5lXG4gICAqIEByZXR1cm4ge0dlb0Nvb3JkaW5hdGVzfSAtIG9iamVjdCB3aXRoIHtsYXQsbG9ufSBvZiBwb2ludCBvbiBzcGhlcmUuXG4gICAqICAgSGFzIHRvQXJyYXkgbWV0aG9kIGlmIHlvdSBuZWVkIGEgR2VvSlNPTiBBcnJheS5cbiAgICogICBQZXIgY2FydG9ncmFwaGljIHRyYWRpdGlvbiwgbGF0IGFuZCBsb24gYXJlIHNwZWNpZmllZCBhcyBkZWdyZWVzLlxuICAgKi9cbiAgX3VucHJvamVjdEZsYXQoeHksIHNjYWxlID0gdGhpcy5zY2FsZSkge1xuICAgIHJldHVybiB1bnByb2plY3RGbGF0KHh5LCBzY2FsZSk7XG4gIH1cblxuICAvKlxuICBnZXRMbmdMYXRBdFZpZXdwb3J0UG9zaXRpb24obG5nbGF0LCB4eSkge1xuICAgIGNvbnN0IGMgPSB0aGlzLmxvY2F0aW9uQ29vcmRpbmF0ZShsbmdsYXQpO1xuICAgIGNvbnN0IGNvb3JkQXRQb2ludCA9IHRoaXMucG9pbnRDb29yZGluYXRlKHh5KTtcbiAgICBjb25zdCBjb29yZENlbnRlciA9IHRoaXMucG9pbnRDb29yZGluYXRlKHRoaXMuY2VudGVyUG9pbnQpO1xuICAgIGNvbnN0IHRyYW5zbGF0ZSA9IGNvb3JkQXRQb2ludC5fc3ViKGMpO1xuICAgIHRoaXMuY2VudGVyID0gdGhpcy5jb29yZGluYXRlTG9jYXRpb24oY29vcmRDZW50ZXIuX3N1Yih0cmFuc2xhdGUpKTtcbiAgfVxuICAqL1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIG1ldGVyIG9mZnNldCB0byBhIGxuZ2xhdCBvZmZzZXRcbiAgICpcbiAgICogTm90ZTogVXNlcyBzaW1wbGUgbGluZWFyIGFwcHJveGltYXRpb24gYXJvdW5kIHRoZSB2aWV3cG9ydCBjZW50ZXJcbiAgICogRXJyb3IgaW5jcmVhc2VzIHdpdGggc2l6ZSBvZiBvZmZzZXQgKHJvdWdobHkgMSUgcGVyIDEwMGttKVxuICAgKlxuICAgKiBAcGFyYW0ge1tOdW1iZXIsTnVtYmVyXXxbTnVtYmVyLE51bWJlcixOdW1iZXJdKSB4eXogLSBhcnJheSBvZiBtZXRlciBkZWx0YXNcbiAgICogQHJldHVybiB7W051bWJlcixOdW1iZXJdfFtOdW1iZXIsTnVtYmVyLE51bWJlcl0pIC0gYXJyYXkgb2YgW2xuZyxsYXQsel0gZGVsdGFzXG4gICAqL1xuICBtZXRlcnNUb0xuZ0xhdERlbHRhKHh5eikge1xuICAgIGNvbnN0IFt4LCB5LCB6ID0gMF0gPSB4eXo7XG4gICAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZSh4KSAmJiBOdW1iZXIuaXNGaW5pdGUoeSkgJiYgTnVtYmVyLmlzRmluaXRlKHopLCBFUlJfQVJHVU1FTlQpO1xuICAgIGNvbnN0IHtwaXhlbHNQZXJNZXRlciwgZGVncmVlc1BlclBpeGVsfSA9IHRoaXMuZGlzdGFuY2VTY2FsZXM7XG4gICAgY29uc3QgZGVsdGFMbmcgPSB4ICogcGl4ZWxzUGVyTWV0ZXJbMF0gKiBkZWdyZWVzUGVyUGl4ZWxbMF07XG4gICAgY29uc3QgZGVsdGFMYXQgPSB5ICogcGl4ZWxzUGVyTWV0ZXJbMV0gKiBkZWdyZWVzUGVyUGl4ZWxbMV07XG4gICAgcmV0dXJuIHh5ei5sZW5ndGggPT09IDIgPyBbZGVsdGFMbmcsIGRlbHRhTGF0XSA6IFtkZWx0YUxuZywgZGVsdGFMYXQsIHpdO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgbG5nbGF0IG9mZnNldCB0byBhIG1ldGVyIG9mZnNldFxuICAgKlxuICAgKiBOb3RlOiBVc2VzIHNpbXBsZSBsaW5lYXIgYXBwcm94aW1hdGlvbiBhcm91bmQgdGhlIHZpZXdwb3J0IGNlbnRlclxuICAgKiBFcnJvciBpbmNyZWFzZXMgd2l0aCBzaXplIG9mIG9mZnNldCAocm91Z2hseSAxJSBwZXIgMTAwa20pXG4gICAqXG4gICAqIEBwYXJhbSB7W051bWJlcixOdW1iZXJdfFtOdW1iZXIsTnVtYmVyLE51bWJlcl0pIGRlbHRhTG5nTGF0WiAtIGFycmF5IG9mIFtsbmcsbGF0LHpdIGRlbHRhc1xuICAgKiBAcmV0dXJuIHtbTnVtYmVyLE51bWJlcl18W051bWJlcixOdW1iZXIsTnVtYmVyXSkgLSBhcnJheSBvZiBtZXRlciBkZWx0YXNcbiAgICovXG4gIGxuZ0xhdERlbHRhVG9NZXRlcnMoZGVsdGFMbmdMYXRaKSB7XG4gICAgY29uc3QgW2RlbHRhTG5nLCBkZWx0YUxhdCwgZGVsdGFaID0gMF0gPSBkZWx0YUxuZ0xhdFo7XG4gICAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZShkZWx0YUxuZykgJiYgTnVtYmVyLmlzRmluaXRlKGRlbHRhTGF0KSAmJiBOdW1iZXIuaXNGaW5pdGUoZGVsdGFaKSxcbiAgICAgIEVSUl9BUkdVTUVOVCk7XG4gICAgY29uc3Qge3BpeGVsc1BlckRlZ3JlZSwgbWV0ZXJzUGVyUGl4ZWx9ID0gdGhpcy5kaXN0YW5jZVNjYWxlcztcbiAgICBjb25zdCBkZWx0YVggPSBkZWx0YUxuZyAqIHBpeGVsc1BlckRlZ3JlZVswXSAqIG1ldGVyc1BlclBpeGVsWzBdO1xuICAgIGNvbnN0IGRlbHRhWSA9IGRlbHRhTGF0ICogcGl4ZWxzUGVyRGVncmVlWzFdICogbWV0ZXJzUGVyUGl4ZWxbMV07XG4gICAgcmV0dXJuIGRlbHRhTG5nTGF0Wi5sZW5ndGggPT09IDIgPyBbZGVsdGFYLCBkZWx0YVldIDogW2RlbHRhWCwgZGVsdGFZLCBkZWx0YVpdO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIG1ldGVyIGRlbHRhIHRvIGEgYmFzZSBsbmdsYXQgY29vcmRpbmF0ZSwgcmV0dXJuaW5nIGEgbmV3IGxuZ2xhdCBhcnJheVxuICAgKlxuICAgKiBOb3RlOiBVc2VzIHNpbXBsZSBsaW5lYXIgYXBwcm94aW1hdGlvbiBhcm91bmQgdGhlIHZpZXdwb3J0IGNlbnRlclxuICAgKiBFcnJvciBpbmNyZWFzZXMgd2l0aCBzaXplIG9mIG9mZnNldCAocm91Z2hseSAxJSBwZXIgMTAwa20pXG4gICAqXG4gICAqIEBwYXJhbSB7W051bWJlcixOdW1iZXJdfFtOdW1iZXIsTnVtYmVyLE51bWJlcl0pIGxuZ0xhdFogLSBiYXNlIGNvb3JkaW5hdGVcbiAgICogQHBhcmFtIHtbTnVtYmVyLE51bWJlcl18W051bWJlcixOdW1iZXIsTnVtYmVyXSkgeHl6IC0gYXJyYXkgb2YgbWV0ZXIgZGVsdGFzXG4gICAqIEByZXR1cm4ge1tOdW1iZXIsTnVtYmVyXXxbTnVtYmVyLE51bWJlcixOdW1iZXJdKSBhcnJheSBvZiBbbG5nLGxhdCx6XSBkZWx0YXNcbiAgICovXG4gIGFkZE1ldGVyc1RvTG5nTGF0KGxuZ0xhdFosIHh5eikge1xuICAgIGNvbnN0IFtsbmcsIGxhdCwgWiA9IDBdID0gbG5nTGF0WjtcbiAgICBjb25zdCBbZGVsdGFMbmcsIGRlbHRhTGF0LCBkZWx0YVogPSAwXSA9IHRoaXMubWV0ZXJzVG9MbmdMYXREZWx0YSh4eXopO1xuICAgIHJldHVybiBsbmdMYXRaLmxlbmd0aCA9PT0gMiA/XG4gICAgICBbbG5nICsgZGVsdGFMbmcsIGxhdCArIGRlbHRhTGF0XSA6XG4gICAgICBbbG5nICsgZGVsdGFMbmcsIGxhdCArIGRlbHRhTGF0LCBaICsgZGVsdGFaXTtcbiAgfVxufVxuIl19