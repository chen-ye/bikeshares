'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* eslint-disable guard-for-in */


exports.glArrayFromType = glArrayFromType;

var _luma = require('luma.gl');

var _stats = require('./stats');

var _stats2 = _interopRequireDefault(_stats);

var _utils = require('./utils');

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var LOG_START_END_PRIORITY = 1;
var LOG_DETAIL_PRIORITY = 2;

function noop() {}

/* eslint-disable complexity */
function glArrayFromType(glType) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$clamped = _ref.clamped,
      clamped = _ref$clamped === undefined ? true : _ref$clamped;

  // Sorted in some order of likelihood to reduce amount of comparisons
  switch (glType) {
    case _luma.GL.FLOAT:
      return Float32Array;
    case _luma.GL.UNSIGNED_SHORT:
    case _luma.GL.UNSIGNED_SHORT_5_6_5:
    case _luma.GL.UNSIGNED_SHORT_4_4_4_4:
    case _luma.GL.UNSIGNED_SHORT_5_5_5_1:
      return Uint16Array;
    case _luma.GL.UNSIGNED_INT:
      return Uint32Array;
    case _luma.GL.UNSIGNED_BYTE:
      return clamped ? Uint8ClampedArray : Uint8Array;
    case _luma.GL.BYTE:
      return Int8Array;
    case _luma.GL.SHORT:
      return Int16Array;
    case _luma.GL.INT:
      return Int32Array;
    default:
      throw new Error('Failed to deduce type from array');
  }
}
/* eslint-enable complexity */

// Default loggers
var logFunctions = {
  onUpdateStart: function onUpdateStart(_ref2) {
    var level = _ref2.level,
        id = _ref2.id,
        numInstances = _ref2.numInstances;

    _utils.log.time(level, 'Updated attributes for ' + numInstances + ' instances in ' + id + ' in');
  },
  onLog: function onLog(_ref3) {
    var level = _ref3.level,
        message = _ref3.message;

    _utils.log.log(level, message);
  },
  onUpdateEnd: function onUpdateEnd(_ref4) {
    var level = _ref4.level,
        id = _ref4.id,
        numInstances = _ref4.numInstances;

    _utils.log.timeEnd(level, 'Updated attributes for ' + numInstances + ' instances in ' + id + ' in');
  }
};

var AttributeManager = function () {
  _createClass(AttributeManager, null, [{
    key: 'setDefaultLogFunctions',

    /**
     * Sets log functions to help trace or time attribute updates.
     * Default logging uses deck logger.
     *
     * `onLog` is called for each attribute.
     *
     * To enable detailed control of timming and e.g. hierarchical logging,
     * hooks are also provided for update start and end.
     *
     * @param {Object} [opts]
     * @param {String} [opts.onLog=] - called to print
     * @param {String} [opts.onUpdateStart=] - called before update() starts
     * @param {String} [opts.onUpdateEnd=] - called after update() ends
     */
    value: function setDefaultLogFunctions() {
      var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          onLog = _ref5.onLog,
          onUpdateStart = _ref5.onUpdateStart,
          onUpdateEnd = _ref5.onUpdateEnd;

      if (onLog !== undefined) {
        logFunctions.onLog = onLog || noop;
      }
      if (onUpdateStart !== undefined) {
        logFunctions.onUpdateStart = onUpdateStart || noop;
      }
      if (onUpdateEnd !== undefined) {
        logFunctions.onUpdateEnd = onUpdateEnd || noop;
      }
    }

    /**
     * @classdesc
     * Automated attribute generation and management. Suitable when a set of
     * vertex shader attributes are generated by iteration over a data array,
     * and updates to these attributes are needed either when the data itself
     * changes, or when other data relevant to the calculations change.
     *
     * - First the application registers descriptions of its dynamic vertex
     *   attributes using AttributeManager.add().
     * - Then, when any change that affects attributes is detected by the
     *   application, the app will call AttributeManager.invalidate().
     * - Finally before it renders, it calls AttributeManager.update() to
     *   ensure that attributes are automatically rebuilt if anything has been
     *   invalidated.
     *
     * The application provided update functions describe how attributes
     * should be updated from a data array and are expected to traverse
     * that data array (or iterable) and fill in the attribute's typed array.
     *
     * Note that the attribute manager intentionally does not do advanced
     * change detection, but instead makes it easy to build such detection
     * by offering the ability to "invalidate" each attribute separately.
     *
     * Summary:
     * - keeps track of valid state for each attribute
     * - auto reallocates attributes when needed
     * - auto updates attributes with registered updater functions
     * - allows overriding with application supplied buffers
     *
     * Limitations:
     * - There are currently no provisions for only invalidating a range of
     *   indices in an attribute.
     *
     * @class
     * @param {Object} [props]
     * @param {String} [props.id] - identifier (for debugging)
     */

  }]);

  function AttributeManager() {
    var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref6$id = _ref6.id,
        id = _ref6$id === undefined ? 'attribute-manager' : _ref6$id;

    _classCallCheck(this, AttributeManager);

    this.id = id;

    this.attributes = {};
    this.updateTriggers = {};
    this.allocedInstances = -1;
    this.needsRedraw = true;

    this.userData = {};
    this.stats = new _stats2.default({ id: 'attr' });

    // For debugging sanity, prevent uninitialized members
    Object.seal(this);
  }

  /**
   * Adds attributes
   * Takes a map of attribute descriptor objects
   * - keys are attribute names
   * - values are objects with attribute fields
   *
   * attribute.size - number of elements per object
   * attribute.updater - number of elements
   * attribute.instanced=0 - is this is an instanced attribute (a.k.a. divisor)
   * attribute.noAlloc=false - if this attribute should not be allocated
   *
   * @example
   * attributeManager.add({
   *   positions: {size: 2, update: calculatePositions}
   *   colors: {size: 3, update: calculateColors}
   * });
   *
   * @param {Object} attributes - attribute map (see above)
   * @param {Object} updaters - separate map of update functions (deprecated)
   */


  _createClass(AttributeManager, [{
    key: 'add',
    value: function add(attributes) {
      var updaters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      this._add(attributes, updaters);
    }

    /**
      * Removes attributes
      * Takes an array of attribute names and delete them from
      * the attribute map if they exists
      *
      * @example
      * attributeManager.remove(['position']);
      *
      * @param {Object} attributeNameArray - attribute name array (see above)
      */

  }, {
    key: 'remove',
    value: function remove(attributeNameArray) {
      for (var i = 0; i < attributeNameArray.length; i++) {
        var name = attributeNameArray[i];
        if (this.attributes[name] !== undefined) {
          delete this.attributes[name];
        }
      }
    }

    /* Marks an attribute for update
     * @param {string} triggerName: attribute or accessor name
     */

  }, {
    key: 'invalidate',
    value: function invalidate(triggerName) {
      var attributes = this.attributes,
          updateTriggers = this.updateTriggers;

      var attributesToUpdate = updateTriggers[triggerName];

      if (!attributesToUpdate) {
        var message = 'invalidating non-existent attribute ' + triggerName + ' for ' + this.id + '\n';
        message += 'Valid attributes: ' + Object.keys(attributes).join(', ');
        (0, _assert2.default)(attributesToUpdate, message);
      }
      attributesToUpdate.forEach(function (name) {
        var attribute = attributes[name];
        if (attribute) {
          attribute.needsUpdate = true;
        }
      });
      // For performance tuning
      logFunctions.onLog({
        level: LOG_DETAIL_PRIORITY,
        message: 'invalidated attribute ' + attributesToUpdate + ' for ' + this.id,
        id: this.identifier
      });
    }
  }, {
    key: 'invalidateAll',
    value: function invalidateAll() {
      var attributes = this.attributes;

      for (var attributeName in attributes) {
        this.invalidate(attributeName);
      }
    }

    /**
     * Ensure all attribute buffers are updated from props or data.
     *
     * Note: Any preallocated buffers in "buffers" matching registered attribute
     * names will be used. No update will happen in this case.
     * Note: Calls onUpdateStart and onUpdateEnd log callbacks before and after.
     *
     * @param {Object} opts - options
     * @param {Object} opts.data - data (iterable object)
     * @param {Object} opts.numInstances - count of data
     * @param {Object} opts.buffers = {} - pre-allocated buffers
     * @param {Object} opts.props - passed to updaters
     * @param {Object} opts.context - Used as "this" context for updaters
     */

  }, {
    key: 'update',
    value: function update() {
      var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          data = _ref7.data,
          numInstances = _ref7.numInstances,
          _ref7$props = _ref7.props,
          props = _ref7$props === undefined ? {} : _ref7$props,
          _ref7$buffers = _ref7.buffers,
          buffers = _ref7$buffers === undefined ? {} : _ref7$buffers,
          _ref7$context = _ref7.context,
          context = _ref7$context === undefined ? {} : _ref7$context,
          _ref7$ignoreUnknownAt = _ref7.ignoreUnknownAttributes,
          ignoreUnknownAttributes = _ref7$ignoreUnknownAt === undefined ? false : _ref7$ignoreUnknownAt;

      // First apply any application provided buffers
      this._checkExternalBuffers({ buffers: buffers, ignoreUnknownAttributes: ignoreUnknownAttributes });
      this._setExternalBuffers(buffers);

      // Only initiate alloc/update (and logging) if actually needed
      if (this._analyzeBuffers({ numInstances: numInstances })) {
        logFunctions.onUpdateStart({ level: LOG_START_END_PRIORITY, id: this.id, numInstances: numInstances });
        this.stats.timeStart();
        this._updateBuffers({ numInstances: numInstances, data: data, props: props, context: context });
        this.stats.timeEnd();
        logFunctions.onUpdateEnd({ level: LOG_START_END_PRIORITY, id: this.id, numInstances: numInstances });
      }
    }

    /**
     * Returns all attribute descriptors
     * Note: Format matches luma.gl Model/Program.setAttributes()
     * @return {Object} attributes - descriptors
     */

  }, {
    key: 'getAttributes',
    value: function getAttributes() {
      return this.attributes;
    }

    /**
     * Returns changed attribute descriptors
     * This indicates which WebGLBuggers need to be updated
     * @return {Object} attributes - descriptors
     */

  }, {
    key: 'getChangedAttributes',
    value: function getChangedAttributes(_ref8) {
      var _ref8$clearChangedFla = _ref8.clearChangedFlags,
          clearChangedFlags = _ref8$clearChangedFla === undefined ? false : _ref8$clearChangedFla;
      var attributes = this.attributes;

      var changedAttributes = {};
      for (var attributeName in attributes) {
        var attribute = attributes[attributeName];
        if (attribute.changed) {
          attribute.changed = attribute.changed && !clearChangedFlags;
          changedAttributes[attributeName] = attribute;
        }
      }
      return changedAttributes;
    }

    /**
     * Returns the redraw flag, optionally clearing it.
     * Redraw flag will be set if any attributes attributes changed since
     * flag was last cleared.
     *
     * @param {Object} [opts]
     * @param {String} [opts.clearRedrawFlags=false] - whether to clear the flag
     * @return {Boolean} - whether a redraw is needed.
     */

  }, {
    key: 'getNeedsRedraw',
    value: function getNeedsRedraw() {
      var _ref9 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref9$clearRedrawFlag = _ref9.clearRedrawFlags,
          clearRedrawFlags = _ref9$clearRedrawFlag === undefined ? false : _ref9$clearRedrawFlag;

      var redraw = this.needsRedraw;
      redraw = redraw || this.needsRedraw;
      this.needsRedraw = this.needsRedraw && !clearRedrawFlags;
      return redraw;
    }

    /**
     * Sets the redraw flag.
     * @param {Boolean} redraw=true
     * @return {AttributeManager} - for chaining
     */

  }, {
    key: 'setNeedsRedraw',
    value: function setNeedsRedraw() {
      var redraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      this.needsRedraw = true;
      return this;
    }

    // DEPRECATED METHODS

    /**
     * @deprecated since version 2.5, use add() instead
     * Adds attributes
     * @param {Object} attributes - attribute map (see above)
     * @param {Object} updaters - separate map of update functions (deprecated)
     */

  }, {
    key: 'addInstanced',
    value: function addInstanced(attributes) {
      var updaters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      this._add(attributes, updaters, { instanced: 1 });
    }

    // PRIVATE METHODS

    // Used to register an attribute

  }, {
    key: '_add',
    value: function _add(attributes) {
      var updaters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var _extraProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      var newAttributes = {};

      for (var attributeName in attributes) {
        // support for separate update function map
        // For now, just copy any attributes from that map into the main map
        // TODO - Attribute maps are a deprecated feature, remove
        if (attributeName in updaters) {
          attributes[attributeName] = Object.assign({}, attributes[attributeName], updaters[attributeName]);
        }

        var attribute = attributes[attributeName];

        var isIndexed = attribute.isIndexed || attribute.elements;
        var size = attribute.elements && 1 || attribute.size;
        var value = attribute.value || null;

        // Initialize the attribute descriptor, with WebGL and metadata fields
        var attributeData = Object.assign({
          // Ensure that fields are present before Object.seal()
          target: undefined,
          userData: {} // Reserved for application
        },
        // Metadata
        attribute, {
          // State
          isExternalBuffer: false,
          needsAlloc: false,
          needsUpdate: false,
          changed: false,

          // Luma fields
          isIndexed: isIndexed,
          size: size,
          value: value
        }, _extraProps);
        // Sanity - no app fields on our attributes. Use userData instead.
        Object.seal(attributeData);

        // Check all fields and generate helpful error messages
        this._validateAttributeDefinition(attributeName, attributeData);

        // Add to both attributes list (for registration with model)
        newAttributes[attributeName] = attributeData;
      }

      Object.assign(this.attributes, newAttributes);

      this._mapUpdateTriggersToAttributes();
    }

    // build updateTrigger name to attribute name mapping

  }, {
    key: '_mapUpdateTriggersToAttributes',
    value: function _mapUpdateTriggersToAttributes() {
      var _this = this;

      var triggers = {};

      var _loop = function _loop(attributeName) {
        var attribute = _this.attributes[attributeName];
        var accessor = attribute.accessor;

        // use attribute name as update trigger key

        triggers[attributeName] = [attributeName];

        // use accessor name as update trigger key
        if (typeof accessor === 'string') {
          accessor = [accessor];
        }
        if (Array.isArray(accessor)) {
          accessor.forEach(function (accessorName) {
            if (!triggers[accessorName]) {
              triggers[accessorName] = [];
            }
            triggers[accessorName].push(attributeName);
          });
        }
      };

      for (var attributeName in this.attributes) {
        _loop(attributeName);
      }

      this.updateTriggers = triggers;
    }
  }, {
    key: '_validateAttributeDefinition',
    value: function _validateAttributeDefinition(attributeName, attribute) {
      (0, _assert2.default)(attribute.size >= 1 && attribute.size <= 4, 'Attribute definition for ' + attributeName + ' invalid size');

      // Check that either 'accessor' or 'update' is a valid function
      var hasUpdater = attribute.noAlloc || typeof attribute.update === 'function' || typeof attribute.accessor === 'string';
      if (!hasUpdater) {
        throw new Error('Attribute ' + attributeName + ' missing update or accessor');
      }
    }

    // Checks that any attribute buffers in props are valid
    // Note: This is just to help app catch mistakes

  }, {
    key: '_checkExternalBuffers',
    value: function _checkExternalBuffers() {
      var _ref10 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref10$buffers = _ref10.buffers,
          buffers = _ref10$buffers === undefined ? {} : _ref10$buffers,
          _ref10$ignoreUnknownA = _ref10.ignoreUnknownAttributes,
          ignoreUnknownAttributes = _ref10$ignoreUnknownA === undefined ? false : _ref10$ignoreUnknownA;

      var attributes = this.attributes;

      for (var attributeName in buffers) {
        var attribute = attributes[attributeName];
        if (!attribute && !ignoreUnknownAttributes) {
          throw new Error('Unknown attribute prop ' + attributeName);
        }
        // const buffer = buffers[attributeName];
        // TODO - check buffer type
      }
    }

    // Set the buffers for the supplied attributes
    // Update attribute buffers from any attributes in props
    // Detach any previously set buffers, marking all
    // Attributes for auto allocation
    /* eslint-disable max-statements */

  }, {
    key: '_setExternalBuffers',
    value: function _setExternalBuffers(bufferMap) {
      var attributes = this.attributes,
          numInstances = this.numInstances;

      // Copy the refs of any supplied buffers in the props

      for (var attributeName in attributes) {
        var attribute = attributes[attributeName];
        var buffer = bufferMap[attributeName];
        attribute.isExternalBuffer = false;
        if (buffer) {
          var ArrayType = glArrayFromType(attribute.type || _luma.GL.FLOAT);
          if (!(buffer instanceof ArrayType)) {
            throw new Error('Attribute ' + attributeName + ' must be of type ' + ArrayType.name);
          }
          if (attribute.auto && buffer.length <= numInstances * attribute.size) {
            throw new Error('Attribute prop array must match length and size');
          }

          attribute.isExternalBuffer = true;
          attribute.needsUpdate = false;
          if (attribute.value !== buffer) {
            attribute.value = buffer;
            attribute.changed = true;
            this.needsRedraw = true;
          }
        }
      }
    }
    /* eslint-enable max-statements */

    /* Checks that typed arrays for attributes are big enough
     * sets alloc flag if not
     * @return {Boolean} whether any updates are needed
     */

  }, {
    key: '_analyzeBuffers',
    value: function _analyzeBuffers(_ref11) {
      var numInstances = _ref11.numInstances;
      var attributes = this.attributes;

      (0, _assert2.default)(numInstances !== undefined, 'numInstances not defined');

      // Track whether any allocations or updates are needed
      var needsUpdate = false;

      for (var attributeName in attributes) {
        var attribute = attributes[attributeName];
        if (!attribute.isExternalBuffer) {
          // Do we need to reallocate the attribute's typed array?
          var needsAlloc = attribute.value === null || attribute.value.length / attribute.size < numInstances;
          if (needsAlloc && (attribute.update || attribute.accessor)) {
            attribute.needsAlloc = true;
            needsUpdate = true;
          }
          if (attribute.needsUpdate) {
            needsUpdate = true;
          }
        }
      }

      return needsUpdate;
    }

    /**
     * @private
     * Calls update on any buffers that need update
     * TODO? - If app supplied all attributes, no need to iterate over data
     *
     * @param {Object} opts - options
     * @param {Object} opts.data - data (iterable object)
     * @param {Object} opts.numInstances - count of data
     * @param {Object} opts.buffers = {} - pre-allocated buffers
     * @param {Object} opts.props - passed to updaters
     * @param {Object} opts.context - Used as "this" context for updaters
     */
    /* eslint-disable max-statements, complexity */

  }, {
    key: '_updateBuffers',
    value: function _updateBuffers(_ref12) {
      var numInstances = _ref12.numInstances,
          data = _ref12.data,
          props = _ref12.props,
          context = _ref12.context;
      var attributes = this.attributes;

      // Allocate at least one element to ensure a valid buffer

      var allocCount = Math.max(numInstances, 1);

      for (var attributeName in attributes) {
        var attribute = attributes[attributeName];

        // Allocate a new typed array if needed
        if (attribute.needsAlloc) {
          var ArrayType = glArrayFromType(attribute.type || _luma.GL.FLOAT);
          attribute.value = new ArrayType(attribute.size * allocCount);
          logFunctions.onLog({
            level: LOG_DETAIL_PRIORITY,
            message: this.id + ':' + attributeName + ' allocated ' + allocCount,
            id: this.id
          });
          attribute.needsAlloc = false;
          attribute.needsUpdate = true;
        }

        // Call updater function if needed
        if (attribute.needsUpdate) {
          this._updateBuffer({ attribute: attribute, attributeName: attributeName, numInstances: numInstances, data: data, props: props, context: context });
        }
      }

      this.allocedInstances = allocCount;
    }
  }, {
    key: '_updateBuffer',
    value: function _updateBuffer(_ref13) {
      var attribute = _ref13.attribute,
          attributeName = _ref13.attributeName,
          numInstances = _ref13.numInstances,
          data = _ref13.data,
          props = _ref13.props,
          context = _ref13.context;
      var update = attribute.update,
          accessor = attribute.accessor;

      if (update) {
        // Custom updater - typically for non-instanced layers
        logFunctions.onLog({
          level: LOG_DETAIL_PRIORITY,
          message: this.id + ':' + attributeName + ' updating ' + numInstances,
          id: this.id
        });
        update.call(context, attribute, { data: data, props: props, numInstances: numInstances });
        this._checkAttributeArray(attribute, attributeName);
      } else if (accessor) {
        // Standard updater
        this._updateBufferViaStandardAccessor({ attribute: attribute, data: data, props: props });
        this._checkAttributeArray(attribute, attributeName);
      } else {
        logFunctions.onLog({
          level: LOG_DETAIL_PRIORITY,
          message: this.id + ':' + attributeName + ' missing update function',
          id: this.id
        });
      }

      attribute.needsUpdate = false;
      attribute.changed = true;
      this.needsRedraw = true;
    }
    /* eslint-enable max-statements */

  }, {
    key: '_updateBufferViaStandardAccessor',
    value: function _updateBufferViaStandardAccessor(_ref14) {
      var attribute = _ref14.attribute,
          data = _ref14.data,
          props = _ref14.props;
      var accessor = attribute.accessor,
          value = attribute.value,
          size = attribute.size;

      var accessorFunc = props[accessor];

      (0, _assert2.default)(typeof accessorFunc === 'function', 'accessor "' + accessor + '" is not a function');

      var _attribute$defaultVal = attribute.defaultValue,
          defaultValue = _attribute$defaultVal === undefined ? [0, 0, 0, 0] : _attribute$defaultVal;

      defaultValue = Array.isArray(defaultValue) ? defaultValue : [defaultValue];
      var i = 0;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var object = _step.value;

          var objectValue = accessorFunc(object);
          objectValue = Array.isArray(objectValue) ? objectValue : [objectValue];
          /* eslint-disable no-fallthrough, default-case */
          switch (size) {
            case 4:
              value[i + 3] = Number.isFinite(objectValue[3]) ? objectValue[3] : defaultValue[3];
            case 3:
              value[i + 2] = Number.isFinite(objectValue[2]) ? objectValue[2] : defaultValue[2];
            case 2:
              value[i + 1] = Number.isFinite(objectValue[1]) ? objectValue[1] : defaultValue[1];
            case 1:
              value[i + 0] = Number.isFinite(objectValue[0]) ? objectValue[0] : defaultValue[0];
          }
          i += size;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: '_checkAttributeArray',
    value: function _checkAttributeArray(attribute, attributeName) {
      var value = attribute.value;

      if (value && value.length >= 4) {
        var valid = Number.isFinite(value[0]) && Number.isFinite(value[1]) && Number.isFinite(value[2]) && Number.isFinite(value[3]);
        if (!valid) {
          throw new Error('Illegal attribute generated for ' + attributeName);
        }
      }
    }
  }]);

  return AttributeManager;
}();

exports.default = AttributeManager;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvYXR0cmlidXRlLW1hbmFnZXIuanMiXSwibmFtZXMiOlsiZ2xBcnJheUZyb21UeXBlIiwiTE9HX1NUQVJUX0VORF9QUklPUklUWSIsIkxPR19ERVRBSUxfUFJJT1JJVFkiLCJub29wIiwiZ2xUeXBlIiwiY2xhbXBlZCIsIkZMT0FUIiwiRmxvYXQzMkFycmF5IiwiVU5TSUdORURfU0hPUlQiLCJVTlNJR05FRF9TSE9SVF81XzZfNSIsIlVOU0lHTkVEX1NIT1JUXzRfNF80XzQiLCJVTlNJR05FRF9TSE9SVF81XzVfNV8xIiwiVWludDE2QXJyYXkiLCJVTlNJR05FRF9JTlQiLCJVaW50MzJBcnJheSIsIlVOU0lHTkVEX0JZVEUiLCJVaW50OENsYW1wZWRBcnJheSIsIlVpbnQ4QXJyYXkiLCJCWVRFIiwiSW50OEFycmF5IiwiU0hPUlQiLCJJbnQxNkFycmF5IiwiSU5UIiwiSW50MzJBcnJheSIsIkVycm9yIiwibG9nRnVuY3Rpb25zIiwib25VcGRhdGVTdGFydCIsImxldmVsIiwiaWQiLCJudW1JbnN0YW5jZXMiLCJ0aW1lIiwib25Mb2ciLCJtZXNzYWdlIiwibG9nIiwib25VcGRhdGVFbmQiLCJ0aW1lRW5kIiwiQXR0cmlidXRlTWFuYWdlciIsInVuZGVmaW5lZCIsImF0dHJpYnV0ZXMiLCJ1cGRhdGVUcmlnZ2VycyIsImFsbG9jZWRJbnN0YW5jZXMiLCJuZWVkc1JlZHJhdyIsInVzZXJEYXRhIiwic3RhdHMiLCJPYmplY3QiLCJzZWFsIiwidXBkYXRlcnMiLCJfYWRkIiwiYXR0cmlidXRlTmFtZUFycmF5IiwiaSIsImxlbmd0aCIsIm5hbWUiLCJ0cmlnZ2VyTmFtZSIsImF0dHJpYnV0ZXNUb1VwZGF0ZSIsImtleXMiLCJqb2luIiwiZm9yRWFjaCIsImF0dHJpYnV0ZSIsIm5lZWRzVXBkYXRlIiwiaWRlbnRpZmllciIsImF0dHJpYnV0ZU5hbWUiLCJpbnZhbGlkYXRlIiwiZGF0YSIsInByb3BzIiwiYnVmZmVycyIsImNvbnRleHQiLCJpZ25vcmVVbmtub3duQXR0cmlidXRlcyIsIl9jaGVja0V4dGVybmFsQnVmZmVycyIsIl9zZXRFeHRlcm5hbEJ1ZmZlcnMiLCJfYW5hbHl6ZUJ1ZmZlcnMiLCJ0aW1lU3RhcnQiLCJfdXBkYXRlQnVmZmVycyIsImNsZWFyQ2hhbmdlZEZsYWdzIiwiY2hhbmdlZEF0dHJpYnV0ZXMiLCJjaGFuZ2VkIiwiY2xlYXJSZWRyYXdGbGFncyIsInJlZHJhdyIsImluc3RhbmNlZCIsIl9leHRyYVByb3BzIiwibmV3QXR0cmlidXRlcyIsImFzc2lnbiIsImlzSW5kZXhlZCIsImVsZW1lbnRzIiwic2l6ZSIsInZhbHVlIiwiYXR0cmlidXRlRGF0YSIsInRhcmdldCIsImlzRXh0ZXJuYWxCdWZmZXIiLCJuZWVkc0FsbG9jIiwiX3ZhbGlkYXRlQXR0cmlidXRlRGVmaW5pdGlvbiIsIl9tYXBVcGRhdGVUcmlnZ2Vyc1RvQXR0cmlidXRlcyIsInRyaWdnZXJzIiwiYWNjZXNzb3IiLCJBcnJheSIsImlzQXJyYXkiLCJhY2Nlc3Nvck5hbWUiLCJwdXNoIiwiaGFzVXBkYXRlciIsIm5vQWxsb2MiLCJ1cGRhdGUiLCJidWZmZXJNYXAiLCJidWZmZXIiLCJBcnJheVR5cGUiLCJ0eXBlIiwiYXV0byIsImFsbG9jQ291bnQiLCJNYXRoIiwibWF4IiwiX3VwZGF0ZUJ1ZmZlciIsImNhbGwiLCJfY2hlY2tBdHRyaWJ1dGVBcnJheSIsIl91cGRhdGVCdWZmZXJWaWFTdGFuZGFyZEFjY2Vzc29yIiwiYWNjZXNzb3JGdW5jIiwiZGVmYXVsdFZhbHVlIiwib2JqZWN0Iiwib2JqZWN0VmFsdWUiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsInZhbGlkIl0sIm1hcHBpbmdzIjoiOzs7Ozs7cWpCQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7UUFZZ0JBLGUsR0FBQUEsZTs7QUFYaEI7O0FBQ0E7Ozs7QUFDQTs7QUFD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QU1vRSxRQUNKRixPQUFPQyxRQUFQLENBQWdCakMsTUFBTSxDQUFOLENBQWhCLEtBQTZCZ0MsT0FBT0MsUUFBUCxDQUFnQmpDLE1BQU0sQ0FBTixDQUFoQixDQUE3QixJQUNBZ0MsT0FBT0MsUUFBUCxDQUFnQmpDLE1BQU0sQ0FBTixDQUFoQixDQURBLElBQzZCZ0MsT0FBT0MsUUFBUCxDQUFnQmpDLE1BQU0sQ0FBTixDQUFoQixDQUYvQjtBQUdBLFlBQUksQ0FBQ2tDLEtBQUwsRUFBWTtBQUNWLGdCQUFNLElBQUk5RixLQUFKLHNDQUE2Q29DLGFBQTdDLENBQU47QUFDRDtBQUNGO0FBQ0Y7Ozs7OztrQkF0aUJrQnhCLGdCIiwiZmlsZSI6ImF0dHJpYnV0ZS1tYW5hZ2VyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IC0gMjAxNyBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbi8qIGVzbGludC1kaXNhYmxlIGd1YXJkLWZvci1pbiAqL1xuaW1wb3J0IHtHTH0gZnJvbSAnbHVtYS5nbCc7XG5pbXBvcnQgU3RhdHMgZnJvbSAnLi9zdGF0cyc7XG5pbXBvcnQge2xvZ30gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5cbmNvbnN0IExPR19TVEFSVF9FTkRfUFJJT1JJVFkgPSAxO1xuY29uc3QgTE9HX0RFVEFJTF9QUklPUklUWSA9IDI7XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBjb21wbGV4aXR5ICovXG5leHBvcnQgZnVuY3Rpb24gZ2xBcnJheUZyb21UeXBlKGdsVHlwZSwge2NsYW1wZWQgPSB0cnVlfSA9IHt9KSB7XG4gIC8vIFNvcnRlZCBpbiBzb21lIG9yZGVyIG9mIGxpa2VsaWhvb2QgdG8gcmVkdWNlIGFtb3VudCBvZiBjb21wYXJpc29uc1xuICBzd2l0Y2ggKGdsVHlwZSkge1xuICBjYXNlIEdMLkZMT0FUOlxuICAgIHJldHVybiBGbG9hdDMyQXJyYXk7XG4gIGNhc2UgR0wuVU5TSUdORURfU0hPUlQ6XG4gIGNhc2UgR0wuVU5TSUdORURfU0hPUlRfNV82XzU6XG4gIGNhc2UgR0wuVU5TSUdORURfU0hPUlRfNF80XzRfNDpcbiAgY2FzZSBHTC5VTlNJR05FRF9TSE9SVF81XzVfNV8xOlxuICAgIHJldHVybiBVaW50MTZBcnJheTtcbiAgY2FzZSBHTC5VTlNJR05FRF9JTlQ6XG4gICAgcmV0dXJuIFVpbnQzMkFycmF5O1xuICBjYXNlIEdMLlVOU0lHTkVEX0JZVEU6XG4gICAgcmV0dXJuIGNsYW1wZWQgPyBVaW50OENsYW1wZWRBcnJheSA6IFVpbnQ4QXJyYXk7XG4gIGNhc2UgR0wuQllURTpcbiAgICByZXR1cm4gSW50OEFycmF5O1xuICBjYXNlIEdMLlNIT1JUOlxuICAgIHJldHVybiBJbnQxNkFycmF5O1xuICBjYXNlIEdMLklOVDpcbiAgICByZXR1cm4gSW50MzJBcnJheTtcbiAgZGVmYXVsdDpcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBkZWR1Y2UgdHlwZSBmcm9tIGFycmF5Jyk7XG4gIH1cbn1cbi8qIGVzbGludC1lbmFibGUgY29tcGxleGl0eSAqL1xuXG4vLyBEZWZhdWx0IGxvZ2dlcnNcbmNvbnN0IGxvZ0Z1bmN0aW9ucyA9IHtcbiAgb25VcGRhdGVTdGFydDogKHtsZXZlbCwgaWQsIG51bUluc3RhbmNlc30pID0+IHtcbiAgICBsb2cudGltZShsZXZlbCwgYFVwZGF0ZWQgYXR0cmlidXRlcyBmb3IgJHtudW1JbnN0YW5jZXN9IGluc3RhbmNlcyBpbiAke2lkfSBpbmApO1xuICB9LFxuICBvbkxvZzogKHtsZXZlbCwgbWVzc2FnZX0pID0+IHtcbiAgICBsb2cubG9nKGxldmVsLCBtZXNzYWdlKTtcbiAgfSxcbiAgb25VcGRhdGVFbmQ6ICh7bGV2ZWwsIGlkLCBudW1JbnN0YW5jZXN9KSA9PiB7XG4gICAgbG9nLnRpbWVFbmQobGV2ZWwsIGBVcGRhdGVkIGF0dHJpYnV0ZXMgZm9yICR7bnVtSW5zdGFuY2VzfSBpbnN0YW5jZXMgaW4gJHtpZH0gaW5gKTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXR0cmlidXRlTWFuYWdlciB7XG4gIC8qKlxuICAgKiBTZXRzIGxvZyBmdW5jdGlvbnMgdG8gaGVscCB0cmFjZSBvciB0aW1lIGF0dHJpYnV0ZSB1cGRhdGVzLlxuICAgKiBEZWZhdWx0IGxvZ2dpbmcgdXNlcyBkZWNrIGxvZ2dlci5cbiAgICpcbiAgICogYG9uTG9nYCBpcyBjYWxsZWQgZm9yIGVhY2ggYXR0cmlidXRlLlxuICAgKlxuICAgKiBUbyBlbmFibGUgZGV0YWlsZWQgY29udHJvbCBvZiB0aW1taW5nIGFuZCBlLmcuIGhpZXJhcmNoaWNhbCBsb2dnaW5nLFxuICAgKiBob29rcyBhcmUgYWxzbyBwcm92aWRlZCBmb3IgdXBkYXRlIHN0YXJ0IGFuZCBlbmQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c11cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRzLm9uTG9nPV0gLSBjYWxsZWQgdG8gcHJpbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRzLm9uVXBkYXRlU3RhcnQ9XSAtIGNhbGxlZCBiZWZvcmUgdXBkYXRlKCkgc3RhcnRzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0cy5vblVwZGF0ZUVuZD1dIC0gY2FsbGVkIGFmdGVyIHVwZGF0ZSgpIGVuZHNcbiAgICovXG4gIHN0YXRpYyBzZXREZWZhdWx0TG9nRnVuY3Rpb25zKHtcbiAgICBvbkxvZyxcbiAgICBvblVwZGF0ZVN0YXJ0LFxuICAgIG9uVXBkYXRlRW5kXG4gIH0gPSB7fSkge1xuICAgIGlmIChvbkxvZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBsb2dGdW5jdGlvbnMub25Mb2cgPSBvbkxvZyB8fCBub29wO1xuICAgIH1cbiAgICBpZiAob25VcGRhdGVTdGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBsb2dGdW5jdGlvbnMub25VcGRhdGVTdGFydCA9IG9uVXBkYXRlU3RhcnQgfHwgbm9vcDtcbiAgICB9XG4gICAgaWYgKG9uVXBkYXRlRW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGxvZ0Z1bmN0aW9ucy5vblVwZGF0ZUVuZCA9IG9uVXBkYXRlRW5kIHx8IG5vb3A7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBjbGFzc2Rlc2NcbiAgICogQXV0b21hdGVkIGF0dHJpYnV0ZSBnZW5lcmF0aW9uIGFuZCBtYW5hZ2VtZW50LiBTdWl0YWJsZSB3aGVuIGEgc2V0IG9mXG4gICAqIHZlcnRleCBzaGFkZXIgYXR0cmlidXRlcyBhcmUgZ2VuZXJhdGVkIGJ5IGl0ZXJhdGlvbiBvdmVyIGEgZGF0YSBhcnJheSxcbiAgICogYW5kIHVwZGF0ZXMgdG8gdGhlc2UgYXR0cmlidXRlcyBhcmUgbmVlZGVkIGVpdGhlciB3aGVuIHRoZSBkYXRhIGl0c2VsZlxuICAgKiBjaGFuZ2VzLCBvciB3aGVuIG90aGVyIGRhdGEgcmVsZXZhbnQgdG8gdGhlIGNhbGN1bGF0aW9ucyBjaGFuZ2UuXG4gICAqXG4gICAqIC0gRmlyc3QgdGhlIGFwcGxpY2F0aW9uIHJlZ2lzdGVycyBkZXNjcmlwdGlvbnMgb2YgaXRzIGR5bmFtaWMgdmVydGV4XG4gICAqICAgYXR0cmlidXRlcyB1c2luZyBBdHRyaWJ1dGVNYW5hZ2VyLmFkZCgpLlxuICAgKiAtIFRoZW4sIHdoZW4gYW55IGNoYW5nZSB0aGF0IGFmZmVjdHMgYXR0cmlidXRlcyBpcyBkZXRlY3RlZCBieSB0aGVcbiAgICogICBhcHBsaWNhdGlvbiwgdGhlIGFwcCB3aWxsIGNhbGwgQXR0cmlidXRlTWFuYWdlci5pbnZhbGlkYXRlKCkuXG4gICAqIC0gRmluYWxseSBiZWZvcmUgaXQgcmVuZGVycywgaXQgY2FsbHMgQXR0cmlidXRlTWFuYWdlci51cGRhdGUoKSB0b1xuICAgKiAgIGVuc3VyZSB0aGF0IGF0dHJpYnV0ZXMgYXJlIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBpZiBhbnl0aGluZyBoYXMgYmVlblxuICAgKiAgIGludmFsaWRhdGVkLlxuICAgKlxuICAgKiBUaGUgYXBwbGljYXRpb24gcHJvdmlkZWQgdXBkYXRlIGZ1bmN0aW9ucyBkZXNjcmliZSBob3cgYXR0cmlidXRlc1xuICAgKiBzaG91bGQgYmUgdXBkYXRlZCBmcm9tIGEgZGF0YSBhcnJheSBhbmQgYXJlIGV4cGVjdGVkIHRvIHRyYXZlcnNlXG4gICAqIHRoYXQgZGF0YSBhcnJheSAob3IgaXRlcmFibGUpIGFuZCBmaWxsIGluIHRoZSBhdHRyaWJ1dGUncyB0eXBlZCBhcnJheS5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoZSBhdHRyaWJ1dGUgbWFuYWdlciBpbnRlbnRpb25hbGx5IGRvZXMgbm90IGRvIGFkdmFuY2VkXG4gICAqIGNoYW5nZSBkZXRlY3Rpb24sIGJ1dCBpbnN0ZWFkIG1ha2VzIGl0IGVhc3kgdG8gYnVpbGQgc3VjaCBkZXRlY3Rpb25cbiAgICogYnkgb2ZmZXJpbmcgdGhlIGFiaWxpdHkgdG8gXCJpbnZhbGlkYXRlXCIgZWFjaCBhdHRyaWJ1dGUgc2VwYXJhdGVseS5cbiAgICpcbiAgICogU3VtbWFyeTpcbiAgICogLSBrZWVwcyB0cmFjayBvZiB2YWxpZCBzdGF0ZSBmb3IgZWFjaCBhdHRyaWJ1dGVcbiAgICogLSBhdXRvIHJlYWxsb2NhdGVzIGF0dHJpYnV0ZXMgd2hlbiBuZWVkZWRcbiAgICogLSBhdXRvIHVwZGF0ZXMgYXR0cmlidXRlcyB3aXRoIHJlZ2lzdGVyZWQgdXBkYXRlciBmdW5jdGlvbnNcbiAgICogLSBhbGxvd3Mgb3ZlcnJpZGluZyB3aXRoIGFwcGxpY2F0aW9uIHN1cHBsaWVkIGJ1ZmZlcnNcbiAgICpcbiAgICogTGltaXRhdGlvbnM6XG4gICAqIC0gVGhlcmUgYXJlIGN1cnJlbnRseSBubyBwcm92aXNpb25zIGZvciBvbmx5IGludmFsaWRhdGluZyBhIHJhbmdlIG9mXG4gICAqICAgaW5kaWNlcyBpbiBhbiBhdHRyaWJ1dGUuXG4gICAqXG4gICAqIEBjbGFzc1xuICAgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BzXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3Byb3BzLmlkXSAtIGlkZW50aWZpZXIgKGZvciBkZWJ1Z2dpbmcpXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7aWQgPSAnYXR0cmlidXRlLW1hbmFnZXInfSA9IHt9KSB7XG4gICAgdGhpcy5pZCA9IGlkO1xuXG4gICAgdGhpcy5hdHRyaWJ1dGVzID0ge307XG4gICAgdGhpcy51cGRhdGVUcmlnZ2VycyA9IHt9O1xuICAgIHRoaXMuYWxsb2NlZEluc3RhbmNlcyA9IC0xO1xuICAgIHRoaXMubmVlZHNSZWRyYXcgPSB0cnVlO1xuXG4gICAgdGhpcy51c2VyRGF0YSA9IHt9O1xuICAgIHRoaXMuc3RhdHMgPSBuZXcgU3RhdHMoe2lkOiAnYXR0cid9KTtcblxuICAgIC8vIEZvciBkZWJ1Z2dpbmcgc2FuaXR5LCBwcmV2ZW50IHVuaW5pdGlhbGl6ZWQgbWVtYmVyc1xuICAgIE9iamVjdC5zZWFsKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYXR0cmlidXRlc1xuICAgKiBUYWtlcyBhIG1hcCBvZiBhdHRyaWJ1dGUgZGVzY3JpcHRvciBvYmplY3RzXG4gICAqIC0ga2V5cyBhcmUgYXR0cmlidXRlIG5hbWVzXG4gICAqIC0gdmFsdWVzIGFyZSBvYmplY3RzIHdpdGggYXR0cmlidXRlIGZpZWxkc1xuICAgKlxuICAgKiBhdHRyaWJ1dGUuc2l6ZSAtIG51bWJlciBvZiBlbGVtZW50cyBwZXIgb2JqZWN0XG4gICAqIGF0dHJpYnV0ZS51cGRhdGVyIC0gbnVtYmVyIG9mIGVsZW1lbnRzXG4gICAqIGF0dHJpYnV0ZS5pbnN0YW5jZWQ9MCAtIGlzIHRoaXMgaXMgYW4gaW5zdGFuY2VkIGF0dHJpYnV0ZSAoYS5rLmEuIGRpdmlzb3IpXG4gICAqIGF0dHJpYnV0ZS5ub0FsbG9jPWZhbHNlIC0gaWYgdGhpcyBhdHRyaWJ1dGUgc2hvdWxkIG5vdCBiZSBhbGxvY2F0ZWRcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYXR0cmlidXRlTWFuYWdlci5hZGQoe1xuICAgKiAgIHBvc2l0aW9uczoge3NpemU6IDIsIHVwZGF0ZTogY2FsY3VsYXRlUG9zaXRpb25zfVxuICAgKiAgIGNvbG9yczoge3NpemU6IDMsIHVwZGF0ZTogY2FsY3VsYXRlQ29sb3JzfVxuICAgKiB9KTtcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZXMgLSBhdHRyaWJ1dGUgbWFwIChzZWUgYWJvdmUpXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB1cGRhdGVycyAtIHNlcGFyYXRlIG1hcCBvZiB1cGRhdGUgZnVuY3Rpb25zIChkZXByZWNhdGVkKVxuICAgKi9cbiAgYWRkKGF0dHJpYnV0ZXMsIHVwZGF0ZXJzID0ge30pIHtcbiAgICB0aGlzLl9hZGQoYXR0cmlidXRlcywgdXBkYXRlcnMpO1xuICB9XG5cbiAvKipcbiAgICogUmVtb3ZlcyBhdHRyaWJ1dGVzXG4gICAqIFRha2VzIGFuIGFycmF5IG9mIGF0dHJpYnV0ZSBuYW1lcyBhbmQgZGVsZXRlIHRoZW0gZnJvbVxuICAgKiB0aGUgYXR0cmlidXRlIG1hcCBpZiB0aGV5IGV4aXN0c1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBhdHRyaWJ1dGVNYW5hZ2VyLnJlbW92ZShbJ3Bvc2l0aW9uJ10pO1xuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYXR0cmlidXRlTmFtZUFycmF5IC0gYXR0cmlidXRlIG5hbWUgYXJyYXkgKHNlZSBhYm92ZSlcbiAgICovXG4gIHJlbW92ZShhdHRyaWJ1dGVOYW1lQXJyYXkpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF0dHJpYnV0ZU5hbWVBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgbmFtZSA9IGF0dHJpYnV0ZU5hbWVBcnJheVtpXTtcbiAgICAgIGlmICh0aGlzLmF0dHJpYnV0ZXNbbmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkZWxldGUgdGhpcy5hdHRyaWJ1dGVzW25hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qIE1hcmtzIGFuIGF0dHJpYnV0ZSBmb3IgdXBkYXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0cmlnZ2VyTmFtZTogYXR0cmlidXRlIG9yIGFjY2Vzc29yIG5hbWVcbiAgICovXG4gIGludmFsaWRhdGUodHJpZ2dlck5hbWUpIHtcbiAgICBjb25zdCB7YXR0cmlidXRlcywgdXBkYXRlVHJpZ2dlcnN9ID0gdGhpcztcbiAgICBjb25zdCBhdHRyaWJ1dGVzVG9VcGRhdGUgPSB1cGRhdGVUcmlnZ2Vyc1t0cmlnZ2VyTmFtZV07XG5cbiAgICBpZiAoIWF0dHJpYnV0ZXNUb1VwZGF0ZSkge1xuICAgICAgbGV0IG1lc3NhZ2UgPVxuICAgICAgICBgaW52YWxpZGF0aW5nIG5vbi1leGlzdGVudCBhdHRyaWJ1dGUgJHt0cmlnZ2VyTmFtZX0gZm9yICR7dGhpcy5pZH1cXG5gO1xuICAgICAgbWVzc2FnZSArPSBgVmFsaWQgYXR0cmlidXRlczogJHtPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5qb2luKCcsICcpfWA7XG4gICAgICBhc3NlcnQoYXR0cmlidXRlc1RvVXBkYXRlLCBtZXNzYWdlKTtcbiAgICB9XG4gICAgYXR0cmlidXRlc1RvVXBkYXRlLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW25hbWVdO1xuICAgICAgaWYgKGF0dHJpYnV0ZSkge1xuICAgICAgICBhdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIEZvciBwZXJmb3JtYW5jZSB0dW5pbmdcbiAgICBsb2dGdW5jdGlvbnMub25Mb2coe1xuICAgICAgbGV2ZWw6IExPR19ERVRBSUxfUFJJT1JJVFksXG4gICAgICBtZXNzYWdlOiBgaW52YWxpZGF0ZWQgYXR0cmlidXRlICR7YXR0cmlidXRlc1RvVXBkYXRlfSBmb3IgJHt0aGlzLmlkfWAsXG4gICAgICBpZDogdGhpcy5pZGVudGlmaWVyXG4gICAgfSk7XG4gIH1cblxuICBpbnZhbGlkYXRlQWxsKCkge1xuICAgIGNvbnN0IHthdHRyaWJ1dGVzfSA9IHRoaXM7XG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRW5zdXJlIGFsbCBhdHRyaWJ1dGUgYnVmZmVycyBhcmUgdXBkYXRlZCBmcm9tIHByb3BzIG9yIGRhdGEuXG4gICAqXG4gICAqIE5vdGU6IEFueSBwcmVhbGxvY2F0ZWQgYnVmZmVycyBpbiBcImJ1ZmZlcnNcIiBtYXRjaGluZyByZWdpc3RlcmVkIGF0dHJpYnV0ZVxuICAgKiBuYW1lcyB3aWxsIGJlIHVzZWQuIE5vIHVwZGF0ZSB3aWxsIGhhcHBlbiBpbiB0aGlzIGNhc2UuXG4gICAqIE5vdGU6IENhbGxzIG9uVXBkYXRlU3RhcnQgYW5kIG9uVXBkYXRlRW5kIGxvZyBjYWxsYmFja3MgYmVmb3JlIGFuZCBhZnRlci5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLmRhdGEgLSBkYXRhIChpdGVyYWJsZSBvYmplY3QpXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLm51bUluc3RhbmNlcyAtIGNvdW50IG9mIGRhdGFcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMuYnVmZmVycyA9IHt9IC0gcHJlLWFsbG9jYXRlZCBidWZmZXJzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLnByb3BzIC0gcGFzc2VkIHRvIHVwZGF0ZXJzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLmNvbnRleHQgLSBVc2VkIGFzIFwidGhpc1wiIGNvbnRleHQgZm9yIHVwZGF0ZXJzXG4gICAqL1xuICB1cGRhdGUoe1xuICAgIGRhdGEsXG4gICAgbnVtSW5zdGFuY2VzLFxuICAgIHByb3BzID0ge30sXG4gICAgYnVmZmVycyA9IHt9LFxuICAgIGNvbnRleHQgPSB7fSxcbiAgICBpZ25vcmVVbmtub3duQXR0cmlidXRlcyA9IGZhbHNlXG4gIH0gPSB7fSkge1xuICAgIC8vIEZpcnN0IGFwcGx5IGFueSBhcHBsaWNhdGlvbiBwcm92aWRlZCBidWZmZXJzXG4gICAgdGhpcy5fY2hlY2tFeHRlcm5hbEJ1ZmZlcnMoe2J1ZmZlcnMsIGlnbm9yZVVua25vd25BdHRyaWJ1dGVzfSk7XG4gICAgdGhpcy5fc2V0RXh0ZXJuYWxCdWZmZXJzKGJ1ZmZlcnMpO1xuXG4gICAgLy8gT25seSBpbml0aWF0ZSBhbGxvYy91cGRhdGUgKGFuZCBsb2dnaW5nKSBpZiBhY3R1YWxseSBuZWVkZWRcbiAgICBpZiAodGhpcy5fYW5hbHl6ZUJ1ZmZlcnMoe251bUluc3RhbmNlc30pKSB7XG4gICAgICBsb2dGdW5jdGlvbnMub25VcGRhdGVTdGFydCh7bGV2ZWw6IExPR19TVEFSVF9FTkRfUFJJT1JJVFksIGlkOiB0aGlzLmlkLCBudW1JbnN0YW5jZXN9KTtcbiAgICAgIHRoaXMuc3RhdHMudGltZVN0YXJ0KCk7XG4gICAgICB0aGlzLl91cGRhdGVCdWZmZXJzKHtudW1JbnN0YW5jZXMsIGRhdGEsIHByb3BzLCBjb250ZXh0fSk7XG4gICAgICB0aGlzLnN0YXRzLnRpbWVFbmQoKTtcbiAgICAgIGxvZ0Z1bmN0aW9ucy5vblVwZGF0ZUVuZCh7bGV2ZWw6IExPR19TVEFSVF9FTkRfUFJJT1JJVFksIGlkOiB0aGlzLmlkLCBudW1JbnN0YW5jZXN9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbGwgYXR0cmlidXRlIGRlc2NyaXB0b3JzXG4gICAqIE5vdGU6IEZvcm1hdCBtYXRjaGVzIGx1bWEuZ2wgTW9kZWwvUHJvZ3JhbS5zZXRBdHRyaWJ1dGVzKClcbiAgICogQHJldHVybiB7T2JqZWN0fSBhdHRyaWJ1dGVzIC0gZGVzY3JpcHRvcnNcbiAgICovXG4gIGdldEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGNoYW5nZWQgYXR0cmlidXRlIGRlc2NyaXB0b3JzXG4gICAqIFRoaXMgaW5kaWNhdGVzIHdoaWNoIFdlYkdMQnVnZ2VycyBuZWVkIHRvIGJlIHVwZGF0ZWRcbiAgICogQHJldHVybiB7T2JqZWN0fSBhdHRyaWJ1dGVzIC0gZGVzY3JpcHRvcnNcbiAgICovXG4gIGdldENoYW5nZWRBdHRyaWJ1dGVzKHtjbGVhckNoYW5nZWRGbGFncyA9IGZhbHNlfSkge1xuICAgIGNvbnN0IHthdHRyaWJ1dGVzfSA9IHRoaXM7XG4gICAgY29uc3QgY2hhbmdlZEF0dHJpYnV0ZXMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcbiAgICAgIGlmIChhdHRyaWJ1dGUuY2hhbmdlZCkge1xuICAgICAgICBhdHRyaWJ1dGUuY2hhbmdlZCA9IGF0dHJpYnV0ZS5jaGFuZ2VkICYmICFjbGVhckNoYW5nZWRGbGFncztcbiAgICAgICAgY2hhbmdlZEF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV0gPSBhdHRyaWJ1dGU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjaGFuZ2VkQXR0cmlidXRlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByZWRyYXcgZmxhZywgb3B0aW9uYWxseSBjbGVhcmluZyBpdC5cbiAgICogUmVkcmF3IGZsYWcgd2lsbCBiZSBzZXQgaWYgYW55IGF0dHJpYnV0ZXMgYXR0cmlidXRlcyBjaGFuZ2VkIHNpbmNlXG4gICAqIGZsYWcgd2FzIGxhc3QgY2xlYXJlZC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdHMuY2xlYXJSZWRyYXdGbGFncz1mYWxzZV0gLSB3aGV0aGVyIHRvIGNsZWFyIHRoZSBmbGFnXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IC0gd2hldGhlciBhIHJlZHJhdyBpcyBuZWVkZWQuXG4gICAqL1xuICBnZXROZWVkc1JlZHJhdyh7Y2xlYXJSZWRyYXdGbGFncyA9IGZhbHNlfSA9IHt9KSB7XG4gICAgbGV0IHJlZHJhdyA9IHRoaXMubmVlZHNSZWRyYXc7XG4gICAgcmVkcmF3ID0gcmVkcmF3IHx8IHRoaXMubmVlZHNSZWRyYXc7XG4gICAgdGhpcy5uZWVkc1JlZHJhdyA9IHRoaXMubmVlZHNSZWRyYXcgJiYgIWNsZWFyUmVkcmF3RmxhZ3M7XG4gICAgcmV0dXJuIHJlZHJhdztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSByZWRyYXcgZmxhZy5cbiAgICogQHBhcmFtIHtCb29sZWFufSByZWRyYXc9dHJ1ZVxuICAgKiBAcmV0dXJuIHtBdHRyaWJ1dGVNYW5hZ2VyfSAtIGZvciBjaGFpbmluZ1xuICAgKi9cbiAgc2V0TmVlZHNSZWRyYXcocmVkcmF3ID0gdHJ1ZSkge1xuICAgIHRoaXMubmVlZHNSZWRyYXcgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gREVQUkVDQVRFRCBNRVRIT0RTXG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi41LCB1c2UgYWRkKCkgaW5zdGVhZFxuICAgKiBBZGRzIGF0dHJpYnV0ZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZXMgLSBhdHRyaWJ1dGUgbWFwIChzZWUgYWJvdmUpXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB1cGRhdGVycyAtIHNlcGFyYXRlIG1hcCBvZiB1cGRhdGUgZnVuY3Rpb25zIChkZXByZWNhdGVkKVxuICAgKi9cbiAgYWRkSW5zdGFuY2VkKGF0dHJpYnV0ZXMsIHVwZGF0ZXJzID0ge30pIHtcbiAgICB0aGlzLl9hZGQoYXR0cmlidXRlcywgdXBkYXRlcnMsIHtpbnN0YW5jZWQ6IDF9KTtcbiAgfVxuXG4gIC8vIFBSSVZBVEUgTUVUSE9EU1xuXG4gIC8vIFVzZWQgdG8gcmVnaXN0ZXIgYW4gYXR0cmlidXRlXG4gIF9hZGQoYXR0cmlidXRlcywgdXBkYXRlcnMgPSB7fSwgX2V4dHJhUHJvcHMgPSB7fSkge1xuXG4gICAgY29uc3QgbmV3QXR0cmlidXRlcyA9IHt9O1xuXG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIC8vIHN1cHBvcnQgZm9yIHNlcGFyYXRlIHVwZGF0ZSBmdW5jdGlvbiBtYXBcbiAgICAgIC8vIEZvciBub3csIGp1c3QgY29weSBhbnkgYXR0cmlidXRlcyBmcm9tIHRoYXQgbWFwIGludG8gdGhlIG1haW4gbWFwXG4gICAgICAvLyBUT0RPIC0gQXR0cmlidXRlIG1hcHMgYXJlIGEgZGVwcmVjYXRlZCBmZWF0dXJlLCByZW1vdmVcbiAgICAgIGlmIChhdHRyaWJ1dGVOYW1lIGluIHVwZGF0ZXJzKSB7XG4gICAgICAgIGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV0gPVxuICAgICAgICAgIE9iamVjdC5hc3NpZ24oe30sIGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV0sIHVwZGF0ZXJzW2F0dHJpYnV0ZU5hbWVdKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcblxuICAgICAgY29uc3QgaXNJbmRleGVkID0gYXR0cmlidXRlLmlzSW5kZXhlZCB8fCBhdHRyaWJ1dGUuZWxlbWVudHM7XG4gICAgICBjb25zdCBzaXplID0gKGF0dHJpYnV0ZS5lbGVtZW50cyAmJiAxKSB8fCBhdHRyaWJ1dGUuc2l6ZTtcbiAgICAgIGNvbnN0IHZhbHVlID0gYXR0cmlidXRlLnZhbHVlIHx8IG51bGw7XG5cbiAgICAgIC8vIEluaXRpYWxpemUgdGhlIGF0dHJpYnV0ZSBkZXNjcmlwdG9yLCB3aXRoIFdlYkdMIGFuZCBtZXRhZGF0YSBmaWVsZHNcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZURhdGEgPSBPYmplY3QuYXNzaWduKFxuICAgICAgICB7XG4gICAgICAgICAgLy8gRW5zdXJlIHRoYXQgZmllbGRzIGFyZSBwcmVzZW50IGJlZm9yZSBPYmplY3Quc2VhbCgpXG4gICAgICAgICAgdGFyZ2V0OiB1bmRlZmluZWQsXG4gICAgICAgICAgdXNlckRhdGE6IHt9ICAgICAgICAvLyBSZXNlcnZlZCBmb3IgYXBwbGljYXRpb25cbiAgICAgICAgfSxcbiAgICAgICAgLy8gTWV0YWRhdGFcbiAgICAgICAgYXR0cmlidXRlLFxuICAgICAgICB7XG4gICAgICAgICAgLy8gU3RhdGVcbiAgICAgICAgICBpc0V4dGVybmFsQnVmZmVyOiBmYWxzZSxcbiAgICAgICAgICBuZWVkc0FsbG9jOiBmYWxzZSxcbiAgICAgICAgICBuZWVkc1VwZGF0ZTogZmFsc2UsXG4gICAgICAgICAgY2hhbmdlZDogZmFsc2UsXG5cbiAgICAgICAgICAvLyBMdW1hIGZpZWxkc1xuICAgICAgICAgIGlzSW5kZXhlZCxcbiAgICAgICAgICBzaXplLFxuICAgICAgICAgIHZhbHVlXG4gICAgICAgIH0sXG4gICAgICAgIF9leHRyYVByb3BzXG4gICAgICApO1xuICAgICAgLy8gU2FuaXR5IC0gbm8gYXBwIGZpZWxkcyBvbiBvdXIgYXR0cmlidXRlcy4gVXNlIHVzZXJEYXRhIGluc3RlYWQuXG4gICAgICBPYmplY3Quc2VhbChhdHRyaWJ1dGVEYXRhKTtcblxuICAgICAgLy8gQ2hlY2sgYWxsIGZpZWxkcyBhbmQgZ2VuZXJhdGUgaGVscGZ1bCBlcnJvciBtZXNzYWdlc1xuICAgICAgdGhpcy5fdmFsaWRhdGVBdHRyaWJ1dGVEZWZpbml0aW9uKGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZURhdGEpO1xuXG4gICAgICAvLyBBZGQgdG8gYm90aCBhdHRyaWJ1dGVzIGxpc3QgKGZvciByZWdpc3RyYXRpb24gd2l0aCBtb2RlbClcbiAgICAgIG5ld0F0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV0gPSBhdHRyaWJ1dGVEYXRhO1xuICAgIH1cblxuICAgIE9iamVjdC5hc3NpZ24odGhpcy5hdHRyaWJ1dGVzLCBuZXdBdHRyaWJ1dGVzKTtcblxuICAgIHRoaXMuX21hcFVwZGF0ZVRyaWdnZXJzVG9BdHRyaWJ1dGVzKCk7XG4gIH1cblxuICAvLyBidWlsZCB1cGRhdGVUcmlnZ2VyIG5hbWUgdG8gYXR0cmlidXRlIG5hbWUgbWFwcGluZ1xuICBfbWFwVXBkYXRlVHJpZ2dlcnNUb0F0dHJpYnV0ZXMoKSB7XG4gICAgY29uc3QgdHJpZ2dlcnMgPSB7fTtcblxuICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IHRoaXMuYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcbiAgICAgIGxldCB7YWNjZXNzb3J9ID0gYXR0cmlidXRlO1xuXG4gICAgICAvLyB1c2UgYXR0cmlidXRlIG5hbWUgYXMgdXBkYXRlIHRyaWdnZXIga2V5XG4gICAgICB0cmlnZ2Vyc1thdHRyaWJ1dGVOYW1lXSA9IFthdHRyaWJ1dGVOYW1lXTtcblxuICAgICAgLy8gdXNlIGFjY2Vzc29yIG5hbWUgYXMgdXBkYXRlIHRyaWdnZXIga2V5XG4gICAgICBpZiAodHlwZW9mIGFjY2Vzc29yID09PSAnc3RyaW5nJykge1xuICAgICAgICBhY2Nlc3NvciA9IFthY2Nlc3Nvcl07XG4gICAgICB9XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhY2Nlc3NvcikpIHtcbiAgICAgICAgYWNjZXNzb3IuZm9yRWFjaChhY2Nlc3Nvck5hbWUgPT4ge1xuICAgICAgICAgIGlmICghdHJpZ2dlcnNbYWNjZXNzb3JOYW1lXSkge1xuICAgICAgICAgICAgdHJpZ2dlcnNbYWNjZXNzb3JOYW1lXSA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0cmlnZ2Vyc1thY2Nlc3Nvck5hbWVdLnB1c2goYXR0cmlidXRlTmFtZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMudXBkYXRlVHJpZ2dlcnMgPSB0cmlnZ2VycztcbiAgfVxuXG4gIF92YWxpZGF0ZUF0dHJpYnV0ZURlZmluaXRpb24oYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlKSB7XG4gICAgYXNzZXJ0KGF0dHJpYnV0ZS5zaXplID49IDEgJiYgYXR0cmlidXRlLnNpemUgPD0gNCxcbiAgICAgIGBBdHRyaWJ1dGUgZGVmaW5pdGlvbiBmb3IgJHthdHRyaWJ1dGVOYW1lfSBpbnZhbGlkIHNpemVgKTtcblxuICAgIC8vIENoZWNrIHRoYXQgZWl0aGVyICdhY2Nlc3Nvcicgb3IgJ3VwZGF0ZScgaXMgYSB2YWxpZCBmdW5jdGlvblxuICAgIGNvbnN0IGhhc1VwZGF0ZXIgPSBhdHRyaWJ1dGUubm9BbGxvYyB8fFxuICAgICAgdHlwZW9mIGF0dHJpYnV0ZS51cGRhdGUgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgIHR5cGVvZiBhdHRyaWJ1dGUuYWNjZXNzb3IgPT09ICdzdHJpbmcnO1xuICAgIGlmICghaGFzVXBkYXRlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBdHRyaWJ1dGUgJHthdHRyaWJ1dGVOYW1lfSBtaXNzaW5nIHVwZGF0ZSBvciBhY2Nlc3NvcmApO1xuICAgIH1cbiAgfVxuXG4gIC8vIENoZWNrcyB0aGF0IGFueSBhdHRyaWJ1dGUgYnVmZmVycyBpbiBwcm9wcyBhcmUgdmFsaWRcbiAgLy8gTm90ZTogVGhpcyBpcyBqdXN0IHRvIGhlbHAgYXBwIGNhdGNoIG1pc3Rha2VzXG4gIF9jaGVja0V4dGVybmFsQnVmZmVycyh7XG4gICAgYnVmZmVycyA9IHt9LFxuICAgIGlnbm9yZVVua25vd25BdHRyaWJ1dGVzID0gZmFsc2VcbiAgfSA9IHt9KSB7XG4gICAgY29uc3Qge2F0dHJpYnV0ZXN9ID0gdGhpcztcbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gYnVmZmVycykge1xuICAgICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcbiAgICAgIGlmICghYXR0cmlidXRlICYmICFpZ25vcmVVbmtub3duQXR0cmlidXRlcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gYXR0cmlidXRlIHByb3AgJHthdHRyaWJ1dGVOYW1lfWApO1xuICAgICAgfVxuICAgICAgLy8gY29uc3QgYnVmZmVyID0gYnVmZmVyc1thdHRyaWJ1dGVOYW1lXTtcbiAgICAgIC8vIFRPRE8gLSBjaGVjayBidWZmZXIgdHlwZVxuICAgIH1cbiAgfVxuXG4gIC8vIFNldCB0aGUgYnVmZmVycyBmb3IgdGhlIHN1cHBsaWVkIGF0dHJpYnV0ZXNcbiAgLy8gVXBkYXRlIGF0dHJpYnV0ZSBidWZmZXJzIGZyb20gYW55IGF0dHJpYnV0ZXMgaW4gcHJvcHNcbiAgLy8gRGV0YWNoIGFueSBwcmV2aW91c2x5IHNldCBidWZmZXJzLCBtYXJraW5nIGFsbFxuICAvLyBBdHRyaWJ1dGVzIGZvciBhdXRvIGFsbG9jYXRpb25cbiAgLyogZXNsaW50LWRpc2FibGUgbWF4LXN0YXRlbWVudHMgKi9cbiAgX3NldEV4dGVybmFsQnVmZmVycyhidWZmZXJNYXApIHtcbiAgICBjb25zdCB7YXR0cmlidXRlcywgbnVtSW5zdGFuY2VzfSA9IHRoaXM7XG5cbiAgICAvLyBDb3B5IHRoZSByZWZzIG9mIGFueSBzdXBwbGllZCBidWZmZXJzIGluIHRoZSBwcm9wc1xuICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdO1xuICAgICAgY29uc3QgYnVmZmVyID0gYnVmZmVyTWFwW2F0dHJpYnV0ZU5hbWVdO1xuICAgICAgYXR0cmlidXRlLmlzRXh0ZXJuYWxCdWZmZXIgPSBmYWxzZTtcbiAgICAgIGlmIChidWZmZXIpIHtcbiAgICAgICAgY29uc3QgQXJyYXlUeXBlID0gZ2xBcnJheUZyb21UeXBlKGF0dHJpYnV0ZS50eXBlIHx8IEdMLkZMT0FUKTtcbiAgICAgICAgaWYgKCEoYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlUeXBlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQXR0cmlidXRlICR7YXR0cmlidXRlTmFtZX0gbXVzdCBiZSBvZiB0eXBlICR7QXJyYXlUeXBlLm5hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0dHJpYnV0ZS5hdXRvICYmIGJ1ZmZlci5sZW5ndGggPD0gbnVtSW5zdGFuY2VzICogYXR0cmlidXRlLnNpemUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dHJpYnV0ZSBwcm9wIGFycmF5IG11c3QgbWF0Y2ggbGVuZ3RoIGFuZCBzaXplJyk7XG4gICAgICAgIH1cblxuICAgICAgICBhdHRyaWJ1dGUuaXNFeHRlcm5hbEJ1ZmZlciA9IHRydWU7XG4gICAgICAgIGF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuICAgICAgICBpZiAoYXR0cmlidXRlLnZhbHVlICE9PSBidWZmZXIpIHtcbiAgICAgICAgICBhdHRyaWJ1dGUudmFsdWUgPSBidWZmZXI7XG4gICAgICAgICAgYXR0cmlidXRlLmNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMubmVlZHNSZWRyYXcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qIGVzbGludC1lbmFibGUgbWF4LXN0YXRlbWVudHMgKi9cblxuICAvKiBDaGVja3MgdGhhdCB0eXBlZCBhcnJheXMgZm9yIGF0dHJpYnV0ZXMgYXJlIGJpZyBlbm91Z2hcbiAgICogc2V0cyBhbGxvYyBmbGFnIGlmIG5vdFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSB3aGV0aGVyIGFueSB1cGRhdGVzIGFyZSBuZWVkZWRcbiAgICovXG4gIF9hbmFseXplQnVmZmVycyh7bnVtSW5zdGFuY2VzfSkge1xuICAgIGNvbnN0IHthdHRyaWJ1dGVzfSA9IHRoaXM7XG4gICAgYXNzZXJ0KG51bUluc3RhbmNlcyAhPT0gdW5kZWZpbmVkLCAnbnVtSW5zdGFuY2VzIG5vdCBkZWZpbmVkJyk7XG5cbiAgICAvLyBUcmFjayB3aGV0aGVyIGFueSBhbGxvY2F0aW9ucyBvciB1cGRhdGVzIGFyZSBuZWVkZWRcbiAgICBsZXQgbmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdO1xuICAgICAgaWYgKCFhdHRyaWJ1dGUuaXNFeHRlcm5hbEJ1ZmZlcikge1xuICAgICAgICAvLyBEbyB3ZSBuZWVkIHRvIHJlYWxsb2NhdGUgdGhlIGF0dHJpYnV0ZSdzIHR5cGVkIGFycmF5P1xuICAgICAgICBjb25zdCBuZWVkc0FsbG9jID1cbiAgICAgICAgICBhdHRyaWJ1dGUudmFsdWUgPT09IG51bGwgfHxcbiAgICAgICAgICBhdHRyaWJ1dGUudmFsdWUubGVuZ3RoIC8gYXR0cmlidXRlLnNpemUgPCBudW1JbnN0YW5jZXM7XG4gICAgICAgIGlmIChuZWVkc0FsbG9jICYmIChhdHRyaWJ1dGUudXBkYXRlIHx8IGF0dHJpYnV0ZS5hY2Nlc3NvcikpIHtcbiAgICAgICAgICBhdHRyaWJ1dGUubmVlZHNBbGxvYyA9IHRydWU7XG4gICAgICAgICAgbmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdHRyaWJ1dGUubmVlZHNVcGRhdGUpIHtcbiAgICAgICAgICBuZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmVlZHNVcGRhdGU7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQ2FsbHMgdXBkYXRlIG9uIGFueSBidWZmZXJzIHRoYXQgbmVlZCB1cGRhdGVcbiAgICogVE9ETz8gLSBJZiBhcHAgc3VwcGxpZWQgYWxsIGF0dHJpYnV0ZXMsIG5vIG5lZWQgdG8gaXRlcmF0ZSBvdmVyIGRhdGFcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLmRhdGEgLSBkYXRhIChpdGVyYWJsZSBvYmplY3QpXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLm51bUluc3RhbmNlcyAtIGNvdW50IG9mIGRhdGFcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMuYnVmZmVycyA9IHt9IC0gcHJlLWFsbG9jYXRlZCBidWZmZXJzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLnByb3BzIC0gcGFzc2VkIHRvIHVwZGF0ZXJzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLmNvbnRleHQgLSBVc2VkIGFzIFwidGhpc1wiIGNvbnRleHQgZm9yIHVwZGF0ZXJzXG4gICAqL1xuICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtc3RhdGVtZW50cywgY29tcGxleGl0eSAqL1xuICBfdXBkYXRlQnVmZmVycyh7bnVtSW5zdGFuY2VzLCBkYXRhLCBwcm9wcywgY29udGV4dH0pIHtcbiAgICBjb25zdCB7YXR0cmlidXRlc30gPSB0aGlzO1xuXG4gICAgLy8gQWxsb2NhdGUgYXQgbGVhc3Qgb25lIGVsZW1lbnQgdG8gZW5zdXJlIGEgdmFsaWQgYnVmZmVyXG4gICAgY29uc3QgYWxsb2NDb3VudCA9IE1hdGgubWF4KG51bUluc3RhbmNlcywgMSk7XG5cbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcblxuICAgICAgLy8gQWxsb2NhdGUgYSBuZXcgdHlwZWQgYXJyYXkgaWYgbmVlZGVkXG4gICAgICBpZiAoYXR0cmlidXRlLm5lZWRzQWxsb2MpIHtcbiAgICAgICAgY29uc3QgQXJyYXlUeXBlID0gZ2xBcnJheUZyb21UeXBlKGF0dHJpYnV0ZS50eXBlIHx8IEdMLkZMT0FUKTtcbiAgICAgICAgYXR0cmlidXRlLnZhbHVlID0gbmV3IEFycmF5VHlwZShhdHRyaWJ1dGUuc2l6ZSAqIGFsbG9jQ291bnQpO1xuICAgICAgICBsb2dGdW5jdGlvbnMub25Mb2coe1xuICAgICAgICAgIGxldmVsOiBMT0dfREVUQUlMX1BSSU9SSVRZLFxuICAgICAgICAgIG1lc3NhZ2U6IGAke3RoaXMuaWR9OiR7YXR0cmlidXRlTmFtZX0gYWxsb2NhdGVkICR7YWxsb2NDb3VudH1gLFxuICAgICAgICAgIGlkOiB0aGlzLmlkXG4gICAgICAgIH0pO1xuICAgICAgICBhdHRyaWJ1dGUubmVlZHNBbGxvYyA9IGZhbHNlO1xuICAgICAgICBhdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBDYWxsIHVwZGF0ZXIgZnVuY3Rpb24gaWYgbmVlZGVkXG4gICAgICBpZiAoYXR0cmlidXRlLm5lZWRzVXBkYXRlKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUJ1ZmZlcih7YXR0cmlidXRlLCBhdHRyaWJ1dGVOYW1lLCBudW1JbnN0YW5jZXMsIGRhdGEsIHByb3BzLCBjb250ZXh0fSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5hbGxvY2VkSW5zdGFuY2VzID0gYWxsb2NDb3VudDtcbiAgfVxuXG4gIF91cGRhdGVCdWZmZXIoe2F0dHJpYnV0ZSwgYXR0cmlidXRlTmFtZSwgbnVtSW5zdGFuY2VzLCBkYXRhLCBwcm9wcywgY29udGV4dH0pIHtcbiAgICBjb25zdCB7dXBkYXRlLCBhY2Nlc3Nvcn0gPSBhdHRyaWJ1dGU7XG4gICAgaWYgKHVwZGF0ZSkge1xuICAgICAgLy8gQ3VzdG9tIHVwZGF0ZXIgLSB0eXBpY2FsbHkgZm9yIG5vbi1pbnN0YW5jZWQgbGF5ZXJzXG4gICAgICBsb2dGdW5jdGlvbnMub25Mb2coe1xuICAgICAgICBsZXZlbDogTE9HX0RFVEFJTF9QUklPUklUWSxcbiAgICAgICAgbWVzc2FnZTogYCR7dGhpcy5pZH06JHthdHRyaWJ1dGVOYW1lfSB1cGRhdGluZyAke251bUluc3RhbmNlc31gLFxuICAgICAgICBpZDogdGhpcy5pZFxuICAgICAgfSk7XG4gICAgICB1cGRhdGUuY2FsbChjb250ZXh0LCBhdHRyaWJ1dGUsIHtkYXRhLCBwcm9wcywgbnVtSW5zdGFuY2VzfSk7XG4gICAgICB0aGlzLl9jaGVja0F0dHJpYnV0ZUFycmF5KGF0dHJpYnV0ZSwgYXR0cmlidXRlTmFtZSk7XG4gICAgfSBlbHNlIGlmIChhY2Nlc3Nvcikge1xuICAgICAgLy8gU3RhbmRhcmQgdXBkYXRlclxuICAgICAgdGhpcy5fdXBkYXRlQnVmZmVyVmlhU3RhbmRhcmRBY2Nlc3Nvcih7YXR0cmlidXRlLCBkYXRhLCBwcm9wc30pO1xuICAgICAgdGhpcy5fY2hlY2tBdHRyaWJ1dGVBcnJheShhdHRyaWJ1dGUsIGF0dHJpYnV0ZU5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dGdW5jdGlvbnMub25Mb2coe1xuICAgICAgICBsZXZlbDogTE9HX0RFVEFJTF9QUklPUklUWSxcbiAgICAgICAgbWVzc2FnZTogYCR7dGhpcy5pZH06JHthdHRyaWJ1dGVOYW1lfSBtaXNzaW5nIHVwZGF0ZSBmdW5jdGlvbmAsXG4gICAgICAgIGlkOiB0aGlzLmlkXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBhdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSBmYWxzZTtcbiAgICBhdHRyaWJ1dGUuY2hhbmdlZCA9IHRydWU7XG4gICAgdGhpcy5uZWVkc1JlZHJhdyA9IHRydWU7XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSBtYXgtc3RhdGVtZW50cyAqL1xuXG4gIF91cGRhdGVCdWZmZXJWaWFTdGFuZGFyZEFjY2Vzc29yKHthdHRyaWJ1dGUsIGRhdGEsIHByb3BzfSkge1xuICAgIGNvbnN0IHthY2Nlc3NvciwgdmFsdWUsIHNpemV9ID0gYXR0cmlidXRlO1xuICAgIGNvbnN0IGFjY2Vzc29yRnVuYyA9IHByb3BzW2FjY2Vzc29yXTtcblxuICAgIGFzc2VydCh0eXBlb2YgYWNjZXNzb3JGdW5jID09PSAnZnVuY3Rpb24nLCBgYWNjZXNzb3IgXCIke2FjY2Vzc29yfVwiIGlzIG5vdCBhIGZ1bmN0aW9uYCk7XG5cbiAgICBsZXQge2RlZmF1bHRWYWx1ZSA9IFswLCAwLCAwLCAwXX0gPSBhdHRyaWJ1dGU7XG4gICAgZGVmYXVsdFZhbHVlID0gQXJyYXkuaXNBcnJheShkZWZhdWx0VmFsdWUpID8gZGVmYXVsdFZhbHVlIDogW2RlZmF1bHRWYWx1ZV07XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoY29uc3Qgb2JqZWN0IG9mIGRhdGEpIHtcbiAgICAgIGxldCBvYmplY3RWYWx1ZSA9IGFjY2Vzc29yRnVuYyhvYmplY3QpO1xuICAgICAgb2JqZWN0VmFsdWUgPSBBcnJheS5pc0FycmF5KG9iamVjdFZhbHVlKSA/IG9iamVjdFZhbHVlIDogW29iamVjdFZhbHVlXTtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWZhbGx0aHJvdWdoLCBkZWZhdWx0LWNhc2UgKi9cbiAgICAgIHN3aXRjaCAoc2l6ZSkge1xuICAgICAgY2FzZSA0OiB2YWx1ZVtpICsgM10gPSBOdW1iZXIuaXNGaW5pdGUob2JqZWN0VmFsdWVbM10pID8gb2JqZWN0VmFsdWVbM10gOiBkZWZhdWx0VmFsdWVbM107XG4gICAgICBjYXNlIDM6IHZhbHVlW2kgKyAyXSA9IE51bWJlci5pc0Zpbml0ZShvYmplY3RWYWx1ZVsyXSkgPyBvYmplY3RWYWx1ZVsyXSA6IGRlZmF1bHRWYWx1ZVsyXTtcbiAgICAgIGNhc2UgMjogdmFsdWVbaSArIDFdID0gTnVtYmVyLmlzRmluaXRlKG9iamVjdFZhbHVlWzFdKSA/IG9iamVjdFZhbHVlWzFdIDogZGVmYXVsdFZhbHVlWzFdO1xuICAgICAgY2FzZSAxOiB2YWx1ZVtpICsgMF0gPSBOdW1iZXIuaXNGaW5pdGUob2JqZWN0VmFsdWVbMF0pID8gb2JqZWN0VmFsdWVbMF0gOiBkZWZhdWx0VmFsdWVbMF07XG4gICAgICB9XG4gICAgICBpICs9IHNpemU7XG4gICAgfVxuICB9XG5cbiAgX2NoZWNrQXR0cmlidXRlQXJyYXkoYXR0cmlidXRlLCBhdHRyaWJ1dGVOYW1lKSB7XG4gICAgY29uc3Qge3ZhbHVlfSA9IGF0dHJpYnV0ZTtcbiAgICBpZiAodmFsdWUgJiYgdmFsdWUubGVuZ3RoID49IDQpIHtcbiAgICAgIGNvbnN0IHZhbGlkID1cbiAgICAgICAgTnVtYmVyLmlzRmluaXRlKHZhbHVlWzBdKSAmJiBOdW1iZXIuaXNGaW5pdGUodmFsdWVbMV0pICYmXG4gICAgICAgIE51bWJlci5pc0Zpbml0ZSh2YWx1ZVsyXSkgJiYgTnVtYmVyLmlzRmluaXRlKHZhbHVlWzNdKTtcbiAgICAgIGlmICghdmFsaWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbGxlZ2FsIGF0dHJpYnV0ZSBnZW5lcmF0ZWQgZm9yICR7YXR0cmlidXRlTmFtZX1gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiJdfQ==