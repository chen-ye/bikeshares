'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.compareProps = compareProps;
exports.getDefaultProps = getDefaultProps;
exports.mergeDefaultProps = mergeDefaultProps;

var _utils = require('./utils');

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Performs equality by iterating through keys on an object and returning false
 * when any key has values which are not strictly equal between the arguments.
 * @param {Object} opt.oldProps - object with old key/value pairs
 * @param {Object} opt.newProps - object with new key/value pairs
 * @param {Object} opt.ignoreProps={} - object, keys that should not be compared
 * @returns {null|String} - null when values of all keys are strictly equal.
 *   if unequal, returns a string explaining what changed.
 */
/* eslint-disable max-statements, complexity */
function compareProps() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      oldProps = _ref.oldProps,
      newProps = _ref.newProps,
      _ref$ignoreProps = _ref.ignoreProps,
      ignoreProps = _ref$ignoreProps === undefined ? {} : _ref$ignoreProps,
      _ref$triggerName = _ref.triggerName,
      triggerName = _ref$triggerName === undefined ? 'props' : _ref$triggerName;

  (0, _assert2.default)(oldProps !== undefined && newProps !== undefined, 'compareProps args');

  // shallow equality => deep equality
  if (oldProps === newProps) {
    return null;
  }

  if ((typeof newProps === 'undefined' ? 'undefined' : _typeof(newProps)) !== 'object' || newProps === null) {
    return triggerName + ' changed shallowly';
  }

  if ((typeof oldProps === 'undefined' ? 'undefined' : _typeof(oldProps)) !== 'object' || oldProps === null) {
    return triggerName + ' changed shallowly';
  }

  // Test if new props different from old props
  for (var key in oldProps) {
    if (!(key in ignoreProps)) {
      if (!newProps.hasOwnProperty(key)) {
        return triggerName + ' ' + key + ' dropped: ' + oldProps[key] + ' -> (undefined)';
      }

      var equals = newProps[key] && oldProps[key] && newProps[key].equals;
      if (equals && !equals.call(newProps[key], oldProps[key])) {
        return triggerName + ' ' + key + ' changed deeply: ' + oldProps[key] + ' -> ' + newProps[key];
      }

      if (!equals && oldProps[key] !== newProps[key]) {
        return triggerName + ' ' + key + ' changed shallowly: ' + oldProps[key] + ' -> ' + newProps[key];
      }
    }
  }

  // Test if any new props have been added
  for (var _key in newProps) {
    if (!(_key in ignoreProps)) {
      if (!oldProps.hasOwnProperty(_key)) {
        return triggerName + ' ' + _key + ' added: (undefined) -> ' + newProps[_key];
      }
    }
  }

  return null;
}
/* eslint-enable max-statements, complexity */

// HELPERS

// Constructors have their super class constructors as prototypes
function getOwnProperty(object, prop) {
  return object.hasOwnProperty(prop) && object[prop];
}

/*
 * Return merged default props stored on layers constructor, create them if needed
 */
function getDefaultProps(layer) {
  var mergedDefaultProps = getOwnProperty(layer.constructor, 'mergedDefaultProps');
  if (mergedDefaultProps) {
    return mergedDefaultProps;
  }
  return mergeDefaultProps(layer);
}

/*
 * Walk a prototype chain and merge all default props from any 'defaultProps' objects
 */
function mergeDefaultProps(object) {
  var objectNameKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'layerName';

  var subClassConstructor = object.constructor;
  var objectName = getOwnProperty(subClassConstructor, objectNameKey);
  if (!objectName) {
    _utils.log.once(0, object.constructor.name + ' does not specify a ' + objectNameKey);
  }

  // Use the object's constructor name as default id prop.
  // Note that constructor names are substituted during minification and may not be "human readable"
  var mergedDefaultProps = {
    id: objectName || object.constructor.name
  };

  // Reverse shadowing
  // TODO - Rewrite to stop when mergedDefaultProps is available on parent?
  while (object) {
    var objectDefaultProps = getOwnProperty(object.constructor, 'defaultProps');
    Object.freeze(objectDefaultProps);
    if (objectDefaultProps) {
      mergedDefaultProps = Object.assign({}, objectDefaultProps, mergedDefaultProps);
    }
    object = Object.getPrototypeOf(object);
  }

  Object.freeze(mergedDefaultProps);

  // Store for quick lookup
  subClassConstructor.mergedDefaultProps = mergedDefaultProps;

  (0, _assert2.default)(mergeDefaultProps);
  return mergedDefaultProps;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvcHJvcHMuanMiXSwibmFtZXMiOlsiY29tcGFyZVByb3BzIiwiZ2V0RGVmYXVsdFByb3BzIiwibWVyZ2VEZWZhdWx0UHJvcHMiLCJvbGRQcm9wcyIsIm5ld1Byb3BzIiwiaWdub3JlUHJvcHMiLCJ0cmlnZ2VyTmFtZSIsInVuZGVmaW5lZCIsImtleSIsImhhc093blByb3BlcnR5IiwiZXF1YWxzIiwiY2FsbCIsImdldE93blByb3BlcnR5Iiwib2JqZWN0IiwicHJvcCIsImxheWVyIiwibWVyZ2VkRGVmYXVsdFByb3BzIiwiY29uc3RydWN0b3IiLCJvYmplY3ROYW1lS2V5Iiwic3ViQ2xhc3NDb25zdHJ1Y3RvciIsIm9iamVjdE5hbWUiLCJvbmNlIiwibmFtZSIsImlkIiwib2JqZWN0RGVmYXVsdFByb3BzIiwiT2JqZWN0IiwiZnJlZXplIiwiYXNzaWduIiwiZ2V0UHJvdG90eXBlT2YiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O1FBYWdCQSxZLEdBQUFBLFk7UUF5REFDLGUsR0FBQUEsZTtRQVdBQyxpQixHQUFBQSxpQjs7QUFqRmhCOztBQUNBOzs7Ozs7QUFFQTs7Ozs7Ozs7O0FBU0E7QUFDTyxTQUFTRixZQUFULEdBQTBGO0FBQUEsaUZBQUosRUFBSTtBQUFBLE1BQW5FRyxRQUFtRSxRQUFuRUEsUUFBbUU7QUFBQSxNQUF6REMsUUFBeUQsUUFBekRBLFFBQXlEO0FBQUEsOEJBQS9DQyxXQUErQztBQUFBLE1BQS9DQSxXQUErQyxvQ0FBakMsRUFBaUM7QUFBQSw4QkFBN0JDLFdBQTZCO0FBQUEsTUFBN0JBLFdBQTZCLG9DQUFmLE9BQWU7O0FBQy9GLHdCQUFPSCxhQUFhSSxTQUFiLElBQTBCSCxhQUFhRyxTQUE5QyxFQUF5RCxtQkFBekQ7O0FBRUE7QUFDQSxNQUFJSixhQUFhQyxRQUFqQixFQUEyQjtBQUN6QixXQUFPLElBQVA7QUFDRDs7QUFFRCxNQUFJLFFBQU9BLFFBQVAseUNBQU9BLFFBQVAsT0FBb0IsUUFBcEIsSUFBZ0NBLGFB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a0JBQWxCLEVBQXNDUixrQkFBdEMsQ0FBckI7QUFDRDtBQUNESCxhQUFTWSxPQUFPRyxjQUFQLENBQXNCZixNQUF0QixDQUFUO0FBQ0Q7O0FBRURZLFNBQU9DLE1BQVAsQ0FBY1Ysa0JBQWQ7O0FBRUE7QUFDQUcsc0JBQW9CSCxrQkFBcEIsR0FBeUNBLGtCQUF6Qzs7QUFFQSx3QkFBT2QsaUJBQVA7QUFDQSxTQUFPYyxrQkFBUDtBQUNEIiwiZmlsZSI6InByb3BzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtsb2d9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuXG4vKipcbiAqIFBlcmZvcm1zIGVxdWFsaXR5IGJ5IGl0ZXJhdGluZyB0aHJvdWdoIGtleXMgb24gYW4gb2JqZWN0IGFuZCByZXR1cm5pbmcgZmFsc2VcbiAqIHdoZW4gYW55IGtleSBoYXMgdmFsdWVzIHdoaWNoIGFyZSBub3Qgc3RyaWN0bHkgZXF1YWwgYmV0d2VlbiB0aGUgYXJndW1lbnRzLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdC5vbGRQcm9wcyAtIG9iamVjdCB3aXRoIG9sZCBrZXkvdmFsdWUgcGFpcnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHQubmV3UHJvcHMgLSBvYmplY3Qgd2l0aCBuZXcga2V5L3ZhbHVlIHBhaXJzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0Lmlnbm9yZVByb3BzPXt9IC0gb2JqZWN0LCBrZXlzIHRoYXQgc2hvdWxkIG5vdCBiZSBjb21wYXJlZFxuICogQHJldHVybnMge251bGx8U3RyaW5nfSAtIG51bGwgd2hlbiB2YWx1ZXMgb2YgYWxsIGtleXMgYXJlIHN0cmljdGx5IGVxdWFsLlxuICogICBpZiB1bmVxdWFsLCByZXR1cm5zIGEgc3RyaW5nIGV4cGxhaW5pbmcgd2hhdCBjaGFuZ2VkLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtc3RhdGVtZW50cywgY29tcGxleGl0eSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmVQcm9wcyh7b2xkUHJvcHMsIG5ld1Byb3BzLCBpZ25vcmVQcm9wcyA9IHt9LCB0cmlnZ2VyTmFtZSA9ICdwcm9wcyd9ID0ge30pIHtcbiAgYXNzZXJ0KG9sZFByb3BzICE9PSB1bmRlZmluZWQgJiYgbmV3UHJvcHMgIT09IHVuZGVmaW5lZCwgJ2NvbXBhcmVQcm9wcyBhcmdzJyk7XG5cbiAgLy8gc2hhbGxvdyBlcXVhbGl0eSA9PiBkZWVwIGVxdWFsaXR5XG4gIGlmIChvbGRQcm9wcyA9PT0gbmV3UHJvcHMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgbmV3UHJvcHMgIT09ICdvYmplY3QnIHx8IG5ld1Byb3BzID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGAke3RyaWdnZXJOYW1lfSBjaGFuZ2VkIHNoYWxsb3dseWA7XG4gIH1cblxuICBpZiAodHlwZW9mIG9sZFByb3BzICE9PSAnb2JqZWN0JyB8fCBvbGRQcm9wcyA9PT0gbnVsbCkge1xuICAgIHJldHVybiBgJHt0cmlnZ2VyTmFtZX0gY2hhbmdlZCBzaGFsbG93bHlgO1xuICB9XG5cbiAgLy8gVGVzdCBpZiBuZXcgcHJvcHMgZGlmZmVyZW50IGZyb20gb2xkIHByb3BzXG4gIGZvciAoY29uc3Qga2V5IGluIG9sZFByb3BzKSB7XG4gICAgaWYgKCEoa2V5IGluIGlnbm9yZVByb3BzKSkge1xuICAgICAgaWYgKCFuZXdQcm9wcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHJldHVybiBgJHt0cmlnZ2VyTmFtZX0gJHtrZXl9IGRyb3BwZWQ6ICR7b2xkUHJvcHNba2V5XX0gLT4gKHVuZGVmaW5lZClgO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBlcXVhbHMgPSBuZXdQcm9wc1trZXldICYmIG9sZFByb3BzW2tleV0gJiYgbmV3UHJvcHNba2V5XS5lcXVhbHM7XG4gICAgICBpZiAoZXF1YWxzICYmICFlcXVhbHMuY2FsbChuZXdQcm9wc1trZXldLCBvbGRQcm9wc1trZXldKSkge1xuICAgICAgICByZXR1cm4gYCR7dHJpZ2dlck5hbWV9ICR7a2V5fSBjaGFuZ2VkIGRlZXBseTogJHtvbGRQcm9wc1trZXldfSAtPiAke25ld1Byb3BzW2tleV19YDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFlcXVhbHMgJiYgb2xkUHJvcHNba2V5XSAhPT0gbmV3UHJvcHNba2V5XSkge1xuICAgICAgICByZXR1cm4gYCR7dHJpZ2dlck5hbWV9ICR7a2V5fSBjaGFuZ2VkIHNoYWxsb3dseTogJHtvbGRQcm9wc1trZXldfSAtPiAke25ld1Byb3BzW2tleV19YDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBUZXN0IGlmIGFueSBuZXcgcHJvcHMgaGF2ZSBiZWVuIGFkZGVkXG4gIGZvciAoY29uc3Qga2V5IGluIG5ld1Byb3BzKSB7XG4gICAgaWYgKCEoa2V5IGluIGlnbm9yZVByb3BzKSkge1xuICAgICAgaWYgKCFvbGRQcm9wcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHJldHVybiBgJHt0cmlnZ2VyTmFtZX0gJHtrZXl9IGFkZGVkOiAodW5kZWZpbmVkKSAtPiAke25ld1Byb3BzW2tleV19YDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LXN0YXRlbWVudHMsIGNvbXBsZXhpdHkgKi9cblxuLy8gSEVMUEVSU1xuXG4vLyBDb25zdHJ1Y3RvcnMgaGF2ZSB0aGVpciBzdXBlciBjbGFzcyBjb25zdHJ1Y3RvcnMgYXMgcHJvdG90eXBlc1xuZnVuY3Rpb24gZ2V0T3duUHJvcGVydHkob2JqZWN0LCBwcm9wKSB7XG4gIHJldHVybiBvYmplY3QuaGFzT3duUHJvcGVydHkocHJvcCkgJiYgb2JqZWN0W3Byb3BdO1xufVxuXG4vKlxuICogUmV0dXJuIG1lcmdlZCBkZWZhdWx0IHByb3BzIHN0b3JlZCBvbiBsYXllcnMgY29uc3RydWN0b3IsIGNyZWF0ZSB0aGVtIGlmIG5lZWRlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVmYXVsdFByb3BzKGxheWVyKSB7XG4gIGNvbnN0IG1lcmdlZERlZmF1bHRQcm9wcyA9IGdldE93blByb3BlcnR5KGxheWVyLmNvbnN0cnVjdG9yLCAnbWVyZ2VkRGVmYXVsdFByb3BzJyk7XG4gIGlmIChtZXJnZWREZWZhdWx0UHJvcHMpIHtcbiAgICByZXR1cm4gbWVyZ2VkRGVmYXVsdFByb3BzO1xuICB9XG4gIHJldHVybiBtZXJnZURlZmF1bHRQcm9wcyhsYXllcik7XG59XG5cbi8qXG4gKiBXYWxrIGEgcHJvdG90eXBlIGNoYWluIGFuZCBtZXJnZSBhbGwgZGVmYXVsdCBwcm9wcyBmcm9tIGFueSAnZGVmYXVsdFByb3BzJyBvYmplY3RzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZURlZmF1bHRQcm9wcyhvYmplY3QsIG9iamVjdE5hbWVLZXkgPSAnbGF5ZXJOYW1lJykge1xuICBjb25zdCBzdWJDbGFzc0NvbnN0cnVjdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICBjb25zdCBvYmplY3ROYW1lID0gZ2V0T3duUHJvcGVydHkoc3ViQ2xhc3NDb25zdHJ1Y3Rvciwgb2JqZWN0TmFtZUtleSk7XG4gIGlmICghb2JqZWN0TmFtZSkge1xuICAgIGxvZy5vbmNlKDAsIGAke29iamVjdC5jb25zdHJ1Y3Rvci5uYW1lfSBkb2VzIG5vdCBzcGVjaWZ5IGEgJHtvYmplY3ROYW1lS2V5fWApO1xuICB9XG5cbiAgLy8gVXNlIHRoZSBvYmplY3QncyBjb25zdHJ1Y3RvciBuYW1lIGFzIGRlZmF1bHQgaWQgcHJvcC5cbiAgLy8gTm90ZSB0aGF0IGNvbnN0cnVjdG9yIG5hbWVzIGFyZSBzdWJzdGl0dXRlZCBkdXJpbmcgbWluaWZpY2F0aW9uIGFuZCBtYXkgbm90IGJlIFwiaHVtYW4gcmVhZGFibGVcIlxuICBsZXQgbWVyZ2VkRGVmYXVsdFByb3BzID0ge1xuICAgIGlkOiBvYmplY3ROYW1lIHx8IG9iamVjdC5jb25zdHJ1Y3Rvci5uYW1lXG4gIH07XG5cbiAgLy8gUmV2ZXJzZSBzaGFkb3dpbmdcbiAgLy8gVE9ETyAtIFJld3JpdGUgdG8gc3RvcCB3aGVuIG1lcmdlZERlZmF1bHRQcm9wcyBpcyBhdmFpbGFibGUgb24gcGFyZW50P1xuICB3aGlsZSAob2JqZWN0KSB7XG4gICAgY29uc3Qgb2JqZWN0RGVmYXVsdFByb3BzID0gZ2V0T3duUHJvcGVydHkob2JqZWN0LmNvbnN0cnVjdG9yLCAnZGVmYXVsdFByb3BzJyk7XG4gICAgT2JqZWN0LmZyZWV6ZShvYmplY3REZWZhdWx0UHJvcHMpO1xuICAgIGlmIChvYmplY3REZWZhdWx0UHJvcHMpIHtcbiAgICAgIG1lcmdlZERlZmF1bHRQcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIG9iamVjdERlZmF1bHRQcm9wcywgbWVyZ2VkRGVmYXVsdFByb3BzKTtcbiAgICB9XG4gICAgb2JqZWN0ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7XG4gIH1cblxuICBPYmplY3QuZnJlZXplKG1lcmdlZERlZmF1bHRQcm9wcyk7XG5cbiAgLy8gU3RvcmUgZm9yIHF1aWNrIGxvb2t1cFxuICBzdWJDbGFzc0NvbnN0cnVjdG9yLm1lcmdlZERlZmF1bHRQcm9wcyA9IG1lcmdlZERlZmF1bHRQcm9wcztcblxuICBhc3NlcnQobWVyZ2VEZWZhdWx0UHJvcHMpO1xuICByZXR1cm4gbWVyZ2VkRGVmYXVsdFByb3BzO1xufVxuIl19