'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = require('../globals');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ua = typeof _globals.window.navigator !== 'undefined' ? _globals.window.navigator.userAgent.toLowerCase() : '';
var firefox = ua.indexOf('firefox') !== -1;

var WHEEL_EVENTS = [
// Chrome, Safari
'wheel',
// IE
'mousewheel',
// legacy Firefox
'DOMMouseScroll'];
var EVENT_TYPE = 'wheel';

// Constants for normalizing input delta
var WHEEL_DELTA_MAGIC_SCALER = 4.000244140625;
var WHEEL_DELTA_PER_LINE = 40;
var TRACKPAD_MAX_DELTA = 4;
var TRACKPAD_MAX_DELTA_PER_TIME = 200;
// Slow down zoom if shift key is held for more precise zooming
var SHIFT_MULTIPLIER = 0.25;

var WheelInput = function () {
  function WheelInput(element, callback) {
    var _this = this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, WheelInput);

    this.element = element;
    this.callback = callback;

    var events = WHEEL_EVENTS.concat(options.events || []);
    this.options = Object.assign({ enable: true }, options, { events: events });

    this.time = 0;
    this.wheelPosition = null;
    this.type = null;
    this.timeout = null;
    this.lastValue = 0;

    this.handleEvent = this.handleEvent.bind(this);
    this.options.events.forEach(function (event) {
      return element.addEventListener(event, _this.handleEvent);
    });
  }

  _createClass(WheelInput, [{
    key: 'destroy',
    value: function destroy() {
      var _this2 = this;

      this.options.events.forEach(function (event) {
        return _this2.element.removeEventListener(event, _this2.handleEvent);
      });
    }
  }, {
    key: 'set',
    value: function set(options) {
      Object.assign(this.options, options);
    }

    /**
     * Enable this input (begin processing events)
     * if the specified event type is among those handled by this input.
     */

  }, {
    key: 'toggleIfEventSupported',
    value: function toggleIfEventSupported(eventType, enabled) {
      if (eventType === EVENT_TYPE) {
        this.options.enable = enabled;
      }
    }

    /* eslint-disable complexity, max-statements */

  }, {
    key: 'handleEvent',
    value: function handleEvent(event) {
      if (!this.options.enable) {
        return;
      }
      event.preventDefault();

      var value = event.deltaY;
      if (_globals.window.WheelEvent) {
        // Firefox doubles the values on retina screens...
        if (firefox && event.deltaMode === _globals.window.WheelEvent.DOM_DELTA_PIXEL) {
          value /= _globals.window.devicePixelRatio;
        }
        if (event.deltaMode === _globals.window.WheelEvent.DOM_DELTA_LINE) {
          value *= WHEEL_DELTA_PER_LINE;
        }
      }

      var type = this.type,
          timeout = this.timeout,
          lastValue = this.lastValue,
          time = this.time;


      var now = (_globals.window && _globals.window.performance || Date).now();
      var timeDelta = now - (time || 0);

      this.wheelPosition = {
        x: event.clientX,
        y: event.clientY
      };
      time = now;

      if (value !== 0 && value % WHEEL_DELTA_MAGIC_SCALER === 0) {
        // This one is definitely a mouse wheel event.
        type = 'wheel';
        // Normalize this value to match trackpad.
        value = Math.floor(value / WHEEL_DELTA_MAGIC_SCALER);
      } else if (value !== 0 && Math.abs(value) < TRACKPAD_MAX_DELTA) {
        // This one is definitely a trackpad event because it is so small.
        type = 'trackpad';
      } else if (timeDelta > 400) {
        // This is likely a new scroll action.
        type = null;
        lastValue = value;
        // Start a timeout in case this was a singular event,
        // and delay it by up to 40ms.
        timeout = _globals.window.setTimeout(function setTimeout() {
          this._onWheel(event, -lastValue, this.wheelPosition);
          type = 'wheel';
        }.bind(this), 40);
      } else if (!type) {
        // This is a repeating event, but we don't know the type of event just yet.
        // If the delta per time is small, we assume it's a fast trackpad;
        // otherwise we switch into wheel mode.
        type = Math.abs(timeDelta * value) < TRACKPAD_MAX_DELTA_PER_TIME ? 'trackpad' : 'wheel';

        // Make sure our delayed event isn't fired again, because we accumulate
        // the previous event (which was less than 40ms ago) into this event.
        if (timeout) {
          _globals.window.clearTimeout(timeout);
          timeout = null;
          value += lastValue;
        }
      }

      if (event.shiftKey && value) {
        value = value * SHIFT_MULTIPLIER;
      }

      // Only fire the callback if we actually know
      // what type of scrolling device the user uses.
      if (type) {
        this._onWheel(event, -value, this.wheelPosition);
      }
    }
  }, {
    key: '_onWheel',
    value: function _onWheel(srcEvent, delta, position) {
      this.callback({
        type: EVENT_TYPE,
        center: position,
        delta: delta,
        srcEvent: srcEvent,
        pointerType: 'mouse',
        target: srcEvent.target
      });
    }
  }]);

  return WheelInput;
}();

exports.default = WheelInput;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy91dGlscy9ldmVudHMvd2hlZWwtaW5wdXQuanMiXSwibmFtZXMiOlsidWEiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJ0b0xvd2VyQ2FzZSIsImZpcmVmb3giLCJpbmRleE9mIiwiV0hFRUxfRVZFTlRTIiwiRVZFTlRfVFlQRSIsIldIRUVMX0RFTFRBX01BR0lDX1NDQUxFUiIsIldIRUVMX0RFTFRBX1BFUl9MSU5FIiwiVFJBQ0tQQURfTUFYX0RFTFRBIiwiVFJBQ0tQQURfTUFYX0RFTFRBX1BFUl9USU1FIiwiU0hJRlRfTVVMVElQTElFUiIsIldoZWVsSW5wdXQiLCJlbGVtZW50IiwiY2FsbGJhY2siLCJvcHRpb25zIiwiZXZlbnRzIiwiY29uY2F0IiwiT2JqZWN0IiwiYXNzaWduIiwiZW5hYmxlIiwidGltZSIsIndoZWVsUG9zaXRpb24iLCJ0eXBlIiwidGltZW91dCIsImxhc3RWYWx1ZSIsImhhbmRsZUV2ZW50IiwiYmluZCIsImZvckVhY2giLCJhZGRFdmVudExpc3RlbmVyIiwiZXZlbnQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZXZlbnRUeXBlIiwiZW5hYmxlZCIsInByZXZlbnREZWZhdWx0IiwidmFsdWUiLCJkZWx0YVkiLCJXaGVlbEV2ZW50IiwiZGVsdGFNb2RlIiwiRE9NX0RFTFRBX1BJWEVMIiwiZGV2aWNlUGl4ZWxSYXRpbyIsIkRPTV9ERUxUQV9MSU5FIiwibm93IiwicGVyZm9ybWFuY2UiLCJEYXRlIiwidGltZURlbHRhIiwieCIsImNsaWVudFgiLCJ5IiwiY2xpZW50WSIsIk1hdGgiLCJmbG9vciIsImFicyIsInNldFRpbWVvdXQiLCJfb25XaGVlbCIsImNsZWFyVGltZW91dCIsInNoaWZ0S2V5Iiwic3JjRXZlbnQiLCJkZWx0YSIsInBvc2l0aW9uIiwiY2VudGVyIiwicG9pbnRlclR5cGUiLCJ0YXJnZXQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7Ozs7QUFFQSxJQUFNQSxLQUFLLE9BQU8sZ0JBQU9D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NUQsR0FBeUUsT0FBaEY7O0FBRUE7QUFDQTtBQUNBLFlBQUljLE9BQUosRUFBYTtBQUNYLDBCQUFPK0IsWUFBUCxDQUFvQi9CLE9BQXBCO0FBQ0FBLG9CQUFVLElBQVY7QUFDQVcsbUJBQVNWLFNBQVQ7QUFDRDtBQUNGOztBQUVELFVBQUlLLE1BQU0wQixRQUFOLElBQWtCckIsS0FBdEIsRUFBNkI7QUFDM0JBLGdCQUFRQSxRQUFReEIsZ0JBQWhCO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBLFVBQUlZLElBQUosRUFBVTtBQUNSLGFBQUsrQixRQUFMLENBQWN4QixLQUFkLEVBQXFCLENBQUNLLEtBQXRCLEVBQTZCLEtBQUtiLGFBQWxDO0FBQ0Q7QUFDRjs7OzZCQUVRbUMsUSxFQUFVQyxLLEVBQU9DLFEsRUFBVTtBQUNsQyxXQUFLN0MsUUFBTCxDQUFjO0FBQ1pTLGNBQU1qQixVQURNO0FBRVpzRCxnQkFBUUQsUUFGSTtBQUdaRCxvQkFIWTtBQUlaRCwwQkFKWTtBQUtaSSxxQkFBYSxPQUxEO0FBTVpDLGdCQUFRTCxTQUFTSztBQU5MLE9BQWQ7QUFRRDs7Ozs7O2tCQTVIa0JsRCxVIiwiZmlsZSI6IndoZWVsLWlucHV0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHt3aW5kb3d9IGZyb20gJy4uL2dsb2JhbHMnO1xuXG5jb25zdCB1YSA9IHR5cGVvZiB3aW5kb3cubmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyA/XG4gIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkgOiAnJztcbmNvbnN0IGZpcmVmb3ggPSB1YS5pbmRleE9mKCdmaXJlZm94JykgIT09IC0xO1xuXG5jb25zdCBXSEVFTF9FVkVOVFMgPSBbXG4gIC8vIENocm9tZSwgU2FmYXJpXG4gICd3aGVlbCcsXG4gIC8vIElFXG4gICdtb3VzZXdoZWVsJyxcbiAgLy8gbGVnYWN5IEZpcmVmb3hcbiAgJ0RPTU1vdXNlU2Nyb2xsJ1xuXTtcbmNvbnN0IEVWRU5UX1RZUEUgPSAnd2hlZWwnO1xuXG4vLyBDb25zdGFudHMgZm9yIG5vcm1hbGl6aW5nIGlucHV0IGRlbHRhXG5jb25zdCBXSEVFTF9ERUxUQV9NQUdJQ19TQ0FMRVIgPSA0LjAwMDI0NDE0MDYyNTtcbmNvbnN0IFdIRUVMX0RFTFRBX1BFUl9MSU5FID0gNDA7XG5jb25zdCBUUkFDS1BBRF9NQVhfREVMVEEgPSA0O1xuY29uc3QgVFJBQ0tQQURfTUFYX0RFTFRBX1BFUl9USU1FID0gMjAwO1xuLy8gU2xvdyBkb3duIHpvb20gaWYgc2hpZnQga2V5IGlzIGhlbGQgZm9yIG1vcmUgcHJlY2lzZSB6b29taW5nXG5jb25zdCBTSElGVF9NVUxUSVBMSUVSID0gMC4yNTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2hlZWxJbnB1dCB7XG5cbiAgY29uc3RydWN0b3IoZWxlbWVudCwgY2FsbGJhY2ssIG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuXG4gICAgY29uc3QgZXZlbnRzID0gV0hFRUxfRVZFTlRTLmNvbmNhdChvcHRpb25zLmV2ZW50cyB8fCBbXSk7XG4gICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7ZW5hYmxlOiB0cnVlfSwgb3B0aW9ucywge2V2ZW50c30pO1xuXG4gICAgdGhpcy50aW1lID0gMDtcbiAgICB0aGlzLndoZWVsUG9zaXRpb24gPSBudWxsO1xuICAgIHRoaXMudHlwZSA9IG51bGw7XG4gICAgdGhpcy50aW1lb3V0ID0gbnVsbDtcbiAgICB0aGlzLmxhc3RWYWx1ZSA9IDA7XG5cbiAgICB0aGlzLmhhbmRsZUV2ZW50ID0gdGhpcy5oYW5kbGVFdmVudC5iaW5kKHRoaXMpO1xuICAgIHRoaXMub3B0aW9ucy5ldmVudHMuZm9yRWFjaChldmVudCA9PiBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIHRoaXMuaGFuZGxlRXZlbnQpKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5vcHRpb25zLmV2ZW50cy5mb3JFYWNoKGV2ZW50ID0+IHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCB0aGlzLmhhbmRsZUV2ZW50KSk7XG4gIH1cblxuICBzZXQob3B0aW9ucykge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmFibGUgdGhpcyBpbnB1dCAoYmVnaW4gcHJvY2Vzc2luZyBldmVudHMpXG4gICAqIGlmIHRoZSBzcGVjaWZpZWQgZXZlbnQgdHlwZSBpcyBhbW9uZyB0aG9zZSBoYW5kbGVkIGJ5IHRoaXMgaW5wdXQuXG4gICAqL1xuICB0b2dnbGVJZkV2ZW50U3VwcG9ydGVkKGV2ZW50VHlwZSwgZW5hYmxlZCkge1xuICAgIGlmIChldmVudFR5cGUgPT09IEVWRU5UX1RZUEUpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5lbmFibGUgPSBlbmFibGVkO1xuICAgIH1cbiAgfVxuXG4gIC8qIGVzbGludC1kaXNhYmxlIGNvbXBsZXhpdHksIG1heC1zdGF0ZW1lbnRzICovXG4gIGhhbmRsZUV2ZW50KGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuZW5hYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICBsZXQgdmFsdWUgPSBldmVudC5kZWx0YVk7XG4gICAgaWYgKHdpbmRvdy5XaGVlbEV2ZW50KSB7XG4gICAgICAvLyBGaXJlZm94IGRvdWJsZXMgdGhlIHZhbHVlcyBvbiByZXRpbmEgc2NyZWVucy4uLlxuICAgICAgaWYgKGZpcmVmb3ggJiYgZXZlbnQuZGVsdGFNb2RlID09PSB3aW5kb3cuV2hlZWxFdmVudC5ET01fREVMVEFfUElYRUwpIHtcbiAgICAgICAgdmFsdWUgLz0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnQuZGVsdGFNb2RlID09PSB3aW5kb3cuV2hlZWxFdmVudC5ET01fREVMVEFfTElORSkge1xuICAgICAgICB2YWx1ZSAqPSBXSEVFTF9ERUxUQV9QRVJfTElORTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQge1xuICAgICAgdHlwZSxcbiAgICAgIHRpbWVvdXQsXG4gICAgICBsYXN0VmFsdWUsXG4gICAgICB0aW1lXG4gICAgfSA9IHRoaXM7XG5cbiAgICBjb25zdCBub3cgPSAoKHdpbmRvdyAmJiB3aW5kb3cucGVyZm9ybWFuY2UpIHx8IERhdGUpLm5vdygpO1xuICAgIGNvbnN0IHRpbWVEZWx0YSA9IG5vdyAtICh0aW1lIHx8IDApO1xuXG4gICAgdGhpcy53aGVlbFBvc2l0aW9uID0ge1xuICAgICAgeDogZXZlbnQuY2xpZW50WCxcbiAgICAgIHk6IGV2ZW50LmNsaWVudFlcbiAgICB9O1xuICAgIHRpbWUgPSBub3c7XG5cbiAgICBpZiAodmFsdWUgIT09IDAgJiYgdmFsdWUgJSBXSEVFTF9ERUxUQV9NQUdJQ19TQ0FMRVIgPT09IDApIHtcbiAgICAgIC8vIFRoaXMgb25lIGlzIGRlZmluaXRlbHkgYSBtb3VzZSB3aGVlbCBldmVudC5cbiAgICAgIHR5cGUgPSAnd2hlZWwnO1xuICAgICAgLy8gTm9ybWFsaXplIHRoaXMgdmFsdWUgdG8gbWF0Y2ggdHJhY2twYWQuXG4gICAgICB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUgLyBXSEVFTF9ERUxUQV9NQUdJQ19TQ0FMRVIpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgIT09IDAgJiYgTWF0aC5hYnModmFsdWUpIDwgVFJBQ0tQQURfTUFYX0RFTFRBKSB7XG4gICAgICAvLyBUaGlzIG9uZSBpcyBkZWZpbml0ZWx5IGEgdHJhY2twYWQgZXZlbnQgYmVjYXVzZSBpdCBpcyBzbyBzbWFsbC5cbiAgICAgIHR5cGUgPSAndHJhY2twYWQnO1xuICAgIH0gZWxzZSBpZiAodGltZURlbHRhID4gNDAwKSB7XG4gICAgICAvLyBUaGlzIGlzIGxpa2VseSBhIG5ldyBzY3JvbGwgYWN0aW9uLlxuICAgICAgdHlwZSA9IG51bGw7XG4gICAgICBsYXN0VmFsdWUgPSB2YWx1ZTtcbiAgICAgIC8vIFN0YXJ0IGEgdGltZW91dCBpbiBjYXNlIHRoaXMgd2FzIGEgc2luZ3VsYXIgZXZlbnQsXG4gICAgICAvLyBhbmQgZGVsYXkgaXQgYnkgdXAgdG8gNDBtcy5cbiAgICAgIHRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiBzZXRUaW1lb3V0KCkge1xuICAgICAgICB0aGlzLl9vbldoZWVsKGV2ZW50LCAtbGFzdFZhbHVlLCB0aGlzLndoZWVsUG9zaXRpb24pO1xuICAgICAgICB0eXBlID0gJ3doZWVsJztcbiAgICAgIH0uYmluZCh0aGlzKSwgNDApO1xuICAgIH0gZWxzZSBpZiAoIXR5cGUpIHtcbiAgICAgIC8vIFRoaXMgaXMgYSByZXBlYXRpbmcgZXZlbnQsIGJ1dCB3ZSBkb24ndCBrbm93IHRoZSB0eXBlIG9mIGV2ZW50IGp1c3QgeWV0LlxuICAgICAgLy8gSWYgdGhlIGRlbHRhIHBlciB0aW1lIGlzIHNtYWxsLCB3ZSBhc3N1bWUgaXQncyBhIGZhc3QgdHJhY2twYWQ7XG4gICAgICAvLyBvdGhlcndpc2Ugd2Ugc3dpdGNoIGludG8gd2hlZWwgbW9kZS5cbiAgICAgIHR5cGUgPSBNYXRoLmFicyh0aW1lRGVsdGEgKiB2YWx1ZSkgPCBUUkFDS1BBRF9NQVhfREVMVEFfUEVSX1RJTUUgPyAndHJhY2twYWQnIDogJ3doZWVsJztcblxuICAgICAgLy8gTWFrZSBzdXJlIG91ciBkZWxheWVkIGV2ZW50IGlzbid0IGZpcmVkIGFnYWluLCBiZWNhdXNlIHdlIGFjY3VtdWxhdGVcbiAgICAgIC8vIHRoZSBwcmV2aW91cyBldmVudCAod2hpY2ggd2FzIGxlc3MgdGhhbiA0MG1zIGFnbykgaW50byB0aGlzIGV2ZW50LlxuICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgIHZhbHVlICs9IGxhc3RWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZXZlbnQuc2hpZnRLZXkgJiYgdmFsdWUpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUgKiBTSElGVF9NVUxUSVBMSUVSO1xuICAgIH1cblxuICAgIC8vIE9ubHkgZmlyZSB0aGUgY2FsbGJhY2sgaWYgd2UgYWN0dWFsbHkga25vd1xuICAgIC8vIHdoYXQgdHlwZSBvZiBzY3JvbGxpbmcgZGV2aWNlIHRoZSB1c2VyIHVzZXMuXG4gICAgaWYgKHR5cGUpIHtcbiAgICAgIHRoaXMuX29uV2hlZWwoZXZlbnQsIC12YWx1ZSwgdGhpcy53aGVlbFBvc2l0aW9uKTtcbiAgICB9XG4gIH1cblxuICBfb25XaGVlbChzcmNFdmVudCwgZGVsdGEsIHBvc2l0aW9uKSB7XG4gICAgdGhpcy5jYWxsYmFjayh7XG4gICAgICB0eXBlOiBFVkVOVF9UWVBFLFxuICAgICAgY2VudGVyOiBwb3NpdGlvbixcbiAgICAgIGRlbHRhLFxuICAgICAgc3JjRXZlbnQsXG4gICAgICBwb2ludGVyVHlwZTogJ21vdXNlJyxcbiAgICAgIHRhcmdldDogc3JjRXZlbnQudGFyZ2V0XG4gICAgfSk7XG4gIH1cbn1cbiJdfQ==