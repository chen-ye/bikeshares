'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var MOUSE_EVENTS = ['mousedown', 'mousemove', 'mouseup'];
var EVENT_TYPE = 'pointermove';

/**
 * Hammer.js swallows 'move' events (for pointer/touch/mouse)
 * when the pointer is not down. This class sets up a handler
 * specifically for these events to work around this limitation.
 * Note that this could be extended to more intelligently handle
 * move events across input types, e.g. storing multiple simultaneous
 * pointer/touch events, calculating speed/direction, etc.
 */

var MoveInput = function () {
  function MoveInput(element, callback) {
    var _this = this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, MoveInput);

    this.element = element;
    this.callback = callback;
    this.pressed = false;

    var events = MOUSE_EVENTS.concat(options.events || []);
    this.options = Object.assign({ enable: true }, options, { events: events });

    this.handleEvent = this.handleEvent.bind(this);
    this.options.events.forEach(function (event) {
      return element.addEventListener(event, _this.handleEvent);
    });
  }

  _createClass(MoveInput, [{
    key: 'destroy',
    value: function destroy() {
      var _this2 = this;

      this.options.events.forEach(function (event) {
        return _this2.element.removeEventListener(event, _this2.handleEvent);
      });
    }
  }, {
    key: 'set',
    value: function set(options) {
      Object.assign(this.options, options);
    }

    /**
     * Enable this input (begin processing events)
     * if the specified event type is among those handled by this input.
     */

  }, {
    key: 'toggleIfEventSupported',
    value: function toggleIfEventSupported(eventType, enabled) {
      if (EVENT_TYPE === eventType) {
        this.options.enable = enabled;
      }
    }
  }, {
    key: 'handleEvent',
    value: function handleEvent(event) {
      if (!this.options.enable) {
        return;
      }

      switch (event.type) {
        case 'mousedown':
          if (event.button === 0) {
            // Left button is down
            this.pressed = true;
          }
          break;
        case 'mousemove':
          // Move events use `which` to track the button being pressed
          if (event.which !== 1) {
            // Left button is not down
            this.pressed = false;
          }
          if (!this.pressed) {
            // Drag events are emitted by hammer already
            // we just need to emit the move event on hover
            this.callback({
              type: EVENT_TYPE,
              srcEvent: event,
              isDown: this.pressed,
              pointerType: 'mouse',
              target: event.target
            });
          }
          break;
        case 'mouseup':
          this.pressed = false;
          break;
        default:
      }
    }
  }]);

  return MoveInput;
}();

exports.default = MoveInput;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy91dGlscy9ldmVudHMvbW92ZS1pbnB1dC5qcyJdLCJuYW1lcyI6WyJNT1VTRV9FVkVOVFMiLCJFVkVOVF9UWVBFIiwiTW92ZUlucHV0IiwiZWxlbWVudCIsImNhbGxiYWNrIiwib3B0aW9ucyIsInByZXNzZWQiLCJldmVudHMiLCJjb25jYXQiLCJPYmplY3QiLCJhc3NpZ24iLCJlbmFibGUiLCJoYW5kbGVFdmVudCIsImJpbmQiLCJmb3JFYWNoIiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2ZW50IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImV2ZW50VHlwZSIsImVuYWJsZWQiLCJ0eXBlIiwiYnV0dG9uIiwid2hpY2giLCJzcmNFdmVudCIsImlzRG93biIsInBvaW50ZXJUeXBlIiwidGFyZ2V0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUEsSUFBTUEsZUFBZSxDQUFDLFdBQUQsRUFBYyxXQUFkLEVBQTJCLFNBQTNCLENBQXJCO0FBQ0EsSUFBTUMsYUFBYSxhQUFuQjs7QUFFQTs7Ozs7Ozs7O0lBUXFCQyxTO0FBRW5CLHFCQUFZQyxPQUFaLEVBQXFCQyxRQUFyQixFQUE2QztBQUFBOztBQUFBLFFBQWRDLE9BQWMsdUVBQUosRUFBSTs7QUFBQTs7QUFDM0MsU0FBS0YsT0FBTCxHQUFlQSxPQUFmO0FBQ0EsU0FBS0MsUUFBTCxHQUFnQkEsUUFBaEI7QUFDQSxTQUFLRSxPQUFMLEdBQWUsS0FBZjs7QUFFQSxRQUFNQyxTQUFTUCxhQUFhUSxNQUFiLENBQW9CSCxRQUFRRSxNQUFSLElBQWtCLEVBQXRDLENBQWY7QUFDQSxTQUFLRixPQUFMLEdBQWVJLE9BQU9DLE1BQVAsQ0FBYyxFQUFDQyxRQUFRLElBQVQsRUFBZCxFQUE4Qk4sT0FBOUIsRUFBdUMsRUFBQ0UsY0FBRCxFQUF2QyxDQUFmOztBQUVBLFNBQUtLLFdBQUwsR0FBbUIsS0FBS0EsV0FBTCxDQUFpQkMsSUFBakIsQ0FBc0IsSUFBdEIsQ0FBbkI7QUFDQSxTQUFLUixPQUFMLENBQWFFLE1BQWIsQ0FBb0JPLE9BQXBCLENBQTRCO0FBQUEsYUFBU1gsUUFBUVksZ0JBQVIsQ0FBeUJDLEtBQXpCLEVBQWdDLE1BQUtKLFdBQXJDLENBQVQ7QUFBQSxLQUE1QjtBQUNEOzs7OzhCQUVTO0FBQUE7O0FBQ1IsV0FBS1AsT0FBTCxDQUFhRSxNQUFiLENBQW9CTyxPQUFwQixDQUE0QjtBQUFBLGVBQVMsT0FBS1gsT0FBTCxDQUFhYyxtQkFBYixDQUFpQ0QsS0FBakMsRUFBd0MsT0FBS0osV0FBN0MsQ0FBVDtBQUFBLE9BQTVCO0FBQ0Q7Ozt3QkFFR1AsTyxFQUFTO0FBQ1hJLGFBQU9DLE1BQVAsQ0FBYyxLQUFLTCxPQUFuQixFQUE0QkEsT0FBNUI7QUFDRDs7QUFFRDs7Ozs7OzsyQ0FJdUJhLFMsRUFBV0MsTyxFQUFTO0FBQ3pDLFVBQUlsQixlQUFlaUIsU0FBbkIsRUFBOEI7QUFDNUIsYUFBS2IsT0FBTCxDQUFhTSxNQUFiLEdBQXNCUSxPQUF0QjtBQUNEO0FBQ0Y7OztnQ0FFV0gsSyxFQUFPO0FBQ2pCLFVBQUksQ0FBQyxLQUFLWCxPQUFMLENBQWFNLE1BQWxCLEVBQTBCO0FBQ3hCO0FBQ0Q7O0FBRUQsY0FBUUssTUFBTUksSUFBZDtBQUNBLGFBQUssV0FBTDtBQUNFLGNBQUlKLE1BQU1LLE1BQU4sS0FBaUIsQ0FBckIsRUFBd0I7QUFDdEI7QUFDQSxpQkFBS2YsT0FBTCxHQUFlLElBQWY7QUFDRDtBQUNEO0FBQ0YsYUFBSyxXQUFMO0FBQ0U7QUFDQSxjQUFJVSxNQUFNTSxLQUFOLEtBQWdCLENBQXBCLEVBQXVCO0FBQ3JCO0FBQ0EsaUJBQUtoQixPQUFMLEdBQWUsS0FBZjtBQUNEO0FBQ0QsY0FBSSxDQUFDLEtBQUtBLE9BQVYsRUFBbUI7QUFDakI7QUFDQTtBQUNBLGlCQUFLRixRQUFMLENBQWM7QUFDWmdCLG9CQUFNbkIsVUFETTtBQUVac0Isd0JBQVVQLEtBRkU7QUFHWlEsc0JBQVEsS0FBS2xCLE9BSEQ7QUFJWm1CLDJCQUFhLE9BSkQ7QUFLWkMsc0JBQVFWLE1BQU1VO0FBTEYsYUFBZDtBQU9EO0FBQ0Q7QUFDRixhQUFLLFNBQUw7QUFDRSxlQUFLcEIsT0FBTCxHQUFlLEtBQWY7QUFDQTtBQUNGO0FBNUJBO0FBOEJEOzs7Ozs7a0JBbkVrQkosUyIsImZpbGUiOiJtb3ZlLWlucHV0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgTU9VU0VfRVZFTlRTID0gWydtb3VzZWRvd24nLCAnbW91c2Vtb3ZlJywgJ21vdXNldXAnXTtcbmNvbnN0IEVWRU5UX1RZUEUgPSAncG9pbnRlcm1vdmUnO1xuXG4vKipcbiAqIEhhbW1lci5qcyBzd2FsbG93cyAnbW92ZScgZXZlbnRzIChmb3IgcG9pbnRlci90b3VjaC9tb3VzZSlcbiAqIHdoZW4gdGhlIHBvaW50ZXIgaXMgbm90IGRvd24uIFRoaXMgY2xhc3Mgc2V0cyB1cCBhIGhhbmRsZXJcbiAqIHNwZWNpZmljYWxseSBmb3IgdGhlc2UgZXZlbnRzIHRvIHdvcmsgYXJvdW5kIHRoaXMgbGltaXRhdGlvbi5cbiAqIE5vdGUgdGhhdCB0aGlzIGNvdWxkIGJlIGV4dGVuZGVkIHRvIG1vcmUgaW50ZWxsaWdlbnRseSBoYW5kbGVcbiAqIG1vdmUgZXZlbnRzIGFjcm9zcyBpbnB1dCB0eXBlcywgZS5nLiBzdG9yaW5nIG11bHRpcGxlIHNpbXVsdGFuZW91c1xuICogcG9pbnRlci90b3VjaCBldmVudHMsIGNhbGN1bGF0aW5nIHNwZWVkL2RpcmVjdGlvbiwgZXRjLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNb3ZlSW5wdXQge1xuXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNhbGxiYWNrLCBvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB0aGlzLnByZXNzZWQgPSBmYWxzZTtcblxuICAgIGNvbnN0IGV2ZW50cyA9IE1PVVNFX0VWRU5UUy5jb25jYXQob3B0aW9ucy5ldmVudHMgfHwgW10pO1xuICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe2VuYWJsZTogdHJ1ZX0sIG9wdGlvbnMsIHtldmVudHN9KTtcblxuICAgIHRoaXMuaGFuZGxlRXZlbnQgPSB0aGlzLmhhbmRsZUV2ZW50LmJpbmQodGhpcyk7XG4gICAgdGhpcy5vcHRpb25zLmV2ZW50cy5mb3JFYWNoKGV2ZW50ID0+IGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgdGhpcy5oYW5kbGVFdmVudCkpO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLm9wdGlvbnMuZXZlbnRzLmZvckVhY2goZXZlbnQgPT4gdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIHRoaXMuaGFuZGxlRXZlbnQpKTtcbiAgfVxuXG4gIHNldChvcHRpb25zKSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuYWJsZSB0aGlzIGlucHV0IChiZWdpbiBwcm9jZXNzaW5nIGV2ZW50cylcbiAgICogaWYgdGhlIHNwZWNpZmllZCBldmVudCB0eXBlIGlzIGFtb25nIHRob3NlIGhhbmRsZWQgYnkgdGhpcyBpbnB1dC5cbiAgICovXG4gIHRvZ2dsZUlmRXZlbnRTdXBwb3J0ZWQoZXZlbnRUeXBlLCBlbmFibGVkKSB7XG4gICAgaWYgKEVWRU5UX1RZUEUgPT09IGV2ZW50VHlwZSkge1xuICAgICAgdGhpcy5vcHRpb25zLmVuYWJsZSA9IGVuYWJsZWQ7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlRXZlbnQoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5lbmFibGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICBjYXNlICdtb3VzZWRvd24nOlxuICAgICAgaWYgKGV2ZW50LmJ1dHRvbiA9PT0gMCkge1xuICAgICAgICAvLyBMZWZ0IGJ1dHRvbiBpcyBkb3duXG4gICAgICAgIHRoaXMucHJlc3NlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdtb3VzZW1vdmUnOlxuICAgICAgLy8gTW92ZSBldmVudHMgdXNlIGB3aGljaGAgdG8gdHJhY2sgdGhlIGJ1dHRvbiBiZWluZyBwcmVzc2VkXG4gICAgICBpZiAoZXZlbnQud2hpY2ggIT09IDEpIHtcbiAgICAgICAgLy8gTGVmdCBidXR0b24gaXMgbm90IGRvd25cbiAgICAgICAgdGhpcy5wcmVzc2VkID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMucHJlc3NlZCkge1xuICAgICAgICAvLyBEcmFnIGV2ZW50cyBhcmUgZW1pdHRlZCBieSBoYW1tZXIgYWxyZWFkeVxuICAgICAgICAvLyB3ZSBqdXN0IG5lZWQgdG8gZW1pdCB0aGUgbW92ZSBldmVudCBvbiBob3ZlclxuICAgICAgICB0aGlzLmNhbGxiYWNrKHtcbiAgICAgICAgICB0eXBlOiBFVkVOVF9UWVBFLFxuICAgICAgICAgIHNyY0V2ZW50OiBldmVudCxcbiAgICAgICAgICBpc0Rvd246IHRoaXMucHJlc3NlZCxcbiAgICAgICAgICBwb2ludGVyVHlwZTogJ21vdXNlJyxcbiAgICAgICAgICB0YXJnZXQ6IGV2ZW50LnRhcmdldFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ21vdXNldXAnOlxuICAgICAgdGhpcy5wcmVzc2VkID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgIH1cbiAgfVxufVxuIl19