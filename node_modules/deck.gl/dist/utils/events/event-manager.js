'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _wheelInput = require('./wheel-input');

var _wheelInput2 = _interopRequireDefault(_wheelInput);

var _moveInput = require('./move-input');

var _moveInput2 = _interopRequireDefault(_moveInput);

var _globals = require('../globals');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Hammer.js directly references `document` and `window`,
// which means that importing it in environments without
// those objects throws errors. Therefore, instead of
// directly `import`ing 'hammerjs' and './constants'
// (which imports Hammer.js) we conditionally require it
// depending on support for those globals, and provide mocks
// for environments without `document`/`window`.
function ManagerMock(m) {
  var instance = {};
  var chainedNoop = function chainedNoop() {
    return instance;
  };
  instance.get = function () {
    return null;
  };
  instance.on = chainedNoop;
  instance.off = chainedNoop;
  instance.destroy = chainedNoop;
  instance.emit = chainedNoop;
  return instance;
}

var Manager = _globals.isBrowser ? require('hammerjs').Manager : ManagerMock;

var _ref = _globals.isBrowser ? require('./constants') : {
  BASIC_EVENT_ALIASES: {},
  EVENT_RECOGNIZER_MAP: {},
  GESTURE_EVENT_ALIASES: {}
},
    BASIC_EVENT_ALIASES = _ref.BASIC_EVENT_ALIASES,
    EVENT_RECOGNIZER_MAP = _ref.EVENT_RECOGNIZER_MAP,
    RECOGNIZERS = _ref.RECOGNIZERS,
    GESTURE_EVENT_ALIASES = _ref.GESTURE_EVENT_ALIASES;

/**
 * Single API for subscribing to events about both
 * basic input events (e.g. 'mousemove', 'touchstart', 'wheel')
 * and gestural input (e.g. 'click', 'tap', 'panstart').
 * Delegates event registration and handling to Hammer.js.
 * @param {DOM Element} element         DOM element on which event handlers will be registered.
 * @param {Object} options              Options for instantiation
 * @param {Object} options.events       Map of {event name: handler} to register on init.
 * @param {Object} options.recognizers  Gesture recognizers from Hammer.js to register,
 *                                      as an Array in Hammer.Recognizer format.
 *                                      (http://hammerjs.github.io/api/#hammermanager)
 */


var EventManager = function () {
  function EventManager(element) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, EventManager);

    this.element = element;
    this._onBasicInput = this._onBasicInput.bind(this);
    this.manager = new Manager(element, { recognizers: options.recognizers || RECOGNIZERS }).on('hammer.input', this._onBasicInput);

    this.eventHandlers = [];

    // Handle events not handled by Hammer.js:
    // - mouse wheel
    // - pointer/touch/mouse move
    this._onOtherEvent = this._onOtherEvent.bind(this);
    this.wheelInput = new _wheelInput2.default(element, this._onOtherEvent, { enable: false });
    this.moveInput = new _moveInput2.default(element, this._onOtherEvent, { enable: false });

    // Register all passed events.
    var events = options.events;

    if (events) {
      this.on(events);
    }
  }

  /**
   * Tear down internal event management implementations.
   */


  _createClass(EventManager, [{
    key: 'destroy',
    value: function destroy() {
      this.wheelInput.destroy();
      this.moveInput.destroy();
      this.manager.destroy();
    }

    /**
     * Register an event handler function to be called on `event`.
     * @param {string|Object} event   An event name (String) or map of event names to handlers.
     * @param {Function} [handler]    The function to be called on `event`.
     */

  }, {
    key: 'on',
    value: function on(event, handler) {
      if (typeof event === 'string') {
        this._addEventHandler(event, handler);
      } else {
        // If `event` is a map, call `on()` for each entry.
        for (var eventName in event) {
          this._addEventHandler(eventName, event[eventName]);
        }
      }
    }

    /**
     * Deregister a previously-registered event handler.
     * @param {string|Object} event   An event name (String) or map of event names to handlers
     * @param {Function} [handler]    The function to be called on `event`.
     */

  }, {
    key: 'off',
    value: function off(event, handler) {
      if (typeof event === 'string') {
        this._removeEventHandler(event, handler);
      } else {
        // If `event` is a map, call `off()` for each entry.
        for (var eventName in event) {
          this._removeEventHandler(eventName, event[eventName]);
        }
      }
    }

    /*
     * Enable/disable recognizer for the given event
     */

  }, {
    key: '_toggleRecognizer',
    value: function _toggleRecognizer(name, enabled) {
      var recognizer = this.manager.get(name);
      if (recognizer) {
        recognizer.set({ enable: enabled });
      }
      this.wheelInput.toggleIfEventSupported(name, enabled);
      this.moveInput.toggleIfEventSupported(name, enabled);
    }

    /**
     * Process the event registration for a single event + handler.
     */

  }, {
    key: '_addEventHandler',
    value: function _addEventHandler(event, handler) {
      var wrappedHandler = this._wrapEventHandler(event, handler);
      // Alias to a recognized gesture as necessary.
      var eventAlias = GESTURE_EVENT_ALIASES[event] || event;
      // Get recognizer for this event
      var recognizerName = EVENT_RECOGNIZER_MAP[eventAlias] || eventAlias;
      // Enable recognizer for this event.
      this._toggleRecognizer(recognizerName, true);

      // Save wrapped handler
      this.eventHandlers.push({ event: event, eventAlias: eventAlias, recognizerName: recognizerName, handler: handler, wrappedHandler: wrappedHandler });

      this.manager.on(eventAlias, wrappedHandler);
    }

    /**
     * Process the event deregistration for a single event + handler.
     */

  }, {
    key: '_removeEventHandler',
    value: function _removeEventHandler(event, handler) {
      var eventHandlerRemoved = false;

      // Find saved handler if any.
      for (var i = this.eventHandlers.length; i--;) {
        var entry = this.eventHandlers[i];
        if (entry.event === event && entry.handler === handler) {
          // Deregister event handler.
          this.manager.off(entry.eventAlias, entry.wrappedHandler);
          // Delete saved handler
          this.eventHandlers.splice(i, 1);
          eventHandlerRemoved = true;
        }
      }

      if (eventHandlerRemoved) {
        // Alias to a recognized gesture as necessary.
        var eventAlias = GESTURE_EVENT_ALIASES[event] || event;
        // Get recognizer for this event
        var recognizerName = EVENT_RECOGNIZER_MAP[eventAlias] || eventAlias;
        // Disable recognizer if no more handlers are attached to its events
        var isRecognizerUsed = this.eventHandlers.find(function (entry) {
          return entry.recognizerName === recognizerName;
        });
        if (!isRecognizerUsed) {
          this._toggleRecognizer(recognizerName, false);
        }
      }
    }

    /**
     * Returns an event handler that aliases events and add props before passing
     * to the real handler.
     */

  }, {
    key: '_wrapEventHandler',
    value: function _wrapEventHandler(type, handler) {
      var _this = this;

      return function (event) {
        var element = _this.element;
        var srcEvent = event.srcEvent;


        var center = event.center || {
          x: srcEvent.clientX,
          y: srcEvent.clientY
        };

        // Calculate center relative to the root element
        // TODO/xiaoji - avoid using getBoundingClientRect for perf?
        var rect = element.getBoundingClientRect();
        var offsetCenter = {
          x: center.x - rect.left - element.clientLeft,
          y: center.y - rect.top - element.clientTop
        };

        handler(Object.assign({}, event, {
          type: type,
          center: center,
          offsetCenter: offsetCenter,
          rootElement: element
        }));
      };
    }

    /**
     * Handle basic events using the 'hammer.input' Hammer.js API:
     * Before running Recognizers, Hammer emits a 'hammer.input' event
     * with the basic event info. This function emits all basic events
     * aliased to the "class" of event received.
     * See constants.BASIC_EVENT_CLASSES basic event class definitions.
     */

  }, {
    key: '_onBasicInput',
    value: function _onBasicInput(event) {
      var srcEvent = event.srcEvent;

      var alias = BASIC_EVENT_ALIASES[srcEvent.type];
      if (alias) {
        // fire all events aliased to srcEvent.type
        var emitEvent = Object.assign({}, event, { isDown: true, type: alias });
        this.manager.emit(alias, emitEvent);
      }
    }

    /**
     * Handle events not supported by Hammer.js,
     * and pipe back out through same (Hammer) channel used by other events.
     */

  }, {
    key: '_onOtherEvent',
    value: function _onOtherEvent(event) {
      this.manager.emit(event.type, event);
    }
  }]);

  return EventManager;
}();

exports.default = EventManager;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy91dGlscy9ldmVudHMvZXZlbnQtbWFuYWdlci5qcyJdLCJuYW1lcyI6WyJNYW5hZ2VyTW9jayIsIm0iLCJpbnN0YW5jZSIsImNoYWluZWROb29wIiwiZ2V0Iiwib24iLCJvZmYiLCJkZXN0cm95IiwiZW1pdCIsIk1hbmFnZXIiLCJyZXF1aXJlIiwiQkFTSUNfRVZFTlRfQUxJQVNFUyIsIkVWRU5UX1JFQ09HTklaRVJfTUFQIiwiR0VTVFVSRV9FVkVOVF9BTElBU0VTIiwiUkVDT0dOSVpFUlMiLCJFdmVudE1hbmFnZXIiLCJlbGVtZW50Iiwib3B0aW9ucyIsIl9vbkJhc2ljSW5wdXQiLCJiaW5kIiwibWFuYWdlciIsInJlY29nbml6ZXJzIiwiZXZlbnRIYW5kbGVycyIsIl9vbk90aGVyRXZlbnQiLCJ3aGVlbElucHV0IiwiZW5hYmxlIiwibW92ZUlucHV0IiwiZXZlbnRzIiwiZXZlbnQiLCJoYW5kbGVyIiwiX2FkZEV2ZW50SGFuZGxlciIsImV2ZW50TmFtZSIsIl9yZW1vdmVFdmVudEhhbmRsZXIiLCJuYW1lIiwiZW5hYmxlZCIsInJlY29nbml6ZXIiLCJzZXQiLCJ0b2dnbGVJZkV2ZW50U3VwcG9ydGVkIiwid3JhcHBlZEhhbmRsZXIiLCJfd3JhcEV2ZW50SGFuZGxlciIsImV2ZW50QWxpYXMiLCJyZWNvZ25pemVyTmFtZSIsIl90b2dnbGVSZWNvZ25pemVyIiwicHVzaCIsImV2ZW50SGFuZGxlclJlbW92ZWQiLCJpIiwibGVuZ3RoIiwiZW50cnkiLCJzcGxpY2UiLCJpc1JlY29nbml6ZXJVc2VkIiwiZmluZCIsInR5cGUiLCJzcmNFdmVudCIsImNlbnRlciIsIngiLCJjbGllbnRYIiwieSIsImNsaWVudFkiLCJyZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwib2Zmc2V0Q2VudGVyIiwibGVmdCIsImNsaWVudExlZnQiLCJ0b3AiLCJjbGllbnRUb3AiLCJPYmplY3QiLCJhc3NpZ24iLCJyb290RWxlbWVudCIsImFsaWFzIiwi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LFNBQS9COztBQUtBO0FBQ0E7QUFDQSxZQUFNQyxPQUFPMUMsUUFBUTJDLHFCQUFSLEVBQWI7QUFDQSxZQUFNQyxlQUFlO0FBQ25CTixhQUFHRCxPQUFPQyxDQUFQLEdBQVdJLEtBQUtHLElBQWhCLEdBQXVCN0MsUUFBUThDLFVBRGY7QUFFbkJOLGFBQUdILE9BQU9HLENBQVAsR0FBV0UsS0FBS0ssR0FBaEIsR0FBc0IvQyxRQUFRZ0Q7QUFGZCxTQUFyQjs7QUFLQW5DLGdCQUFRb0MsT0FBT0MsTUFBUCxDQUFjLEVBQWQsRUFBa0J0QyxLQUFsQixFQUF5QjtBQUMvQnVCLG9CQUQrQjtBQUUvQkUsd0JBRitCO0FBRy9CTyxvQ0FIK0I7QUFJL0JPLHVCQUFhbkQ7QUFKa0IsU0FBekIsQ0FBUjtBQU1ELE9BdkJEO0FBd0JEOztBQUVEOzs7Ozs7Ozs7O2tDQU9jWSxLLEVBQU87QUFBQSxVQUNad0IsUUFEWSxHQUNBeEIsS0FEQSxDQUNad0IsUUFEWTs7QUFFbkIsVUFBTWdCLFFBQVF6RCxvQkFBb0J5QyxTQUFTRCxJQUE3QixDQUFkO0FBQ0EsVUFBSWlCLEtBQUosRUFBVztBQUNUO0FBQ0EsWUFBTUMsWUFBWUosT0FBT0MsTUFBUCxDQUFjLEVBQWQsRUFBa0J0QyxLQUFsQixFQUF5QixFQUFDMEMsUUFBUSxJQUFULEVBQWVuQixNQUFNaUIsS0FBckIsRUFBekIsQ0FBbEI7QUFDQSxhQUFLaEQsT0FBTCxDQUFhWixJQUFiLENBQWtCNEQsS0FBbEIsRUFBeUJDLFNBQXpCO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7OztrQ0FJY3pDLEssRUFBTztBQUNuQixXQUFLUixPQUFMLENBQWFaLElBQWIsQ0FBa0JvQixNQUFNdUIsSUFBeEIsRUFBOEJ2QixLQUE5QjtBQUNEOzs7Ozs7a0JBckxrQmIsWSIsImZpbGUiOiJldmVudC1tYW5hZ2VyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFdoZWVsSW5wdXQgZnJvbSAnLi93aGVlbC1pbnB1dCc7XG5pbXBvcnQgTW92ZUlucHV0IGZyb20gJy4vbW92ZS1pbnB1dCc7XG5pbXBvcnQge2lzQnJvd3Nlcn0gZnJvbSAnLi4vZ2xvYmFscyc7XG5cbi8vIEhhbW1lci5qcyBkaXJlY3RseSByZWZlcmVuY2VzIGBkb2N1bWVudGAgYW5kIGB3aW5kb3dgLFxuLy8gd2hpY2ggbWVhbnMgdGhhdCBpbXBvcnRpbmcgaXQgaW4gZW52aXJvbm1lbnRzIHdpdGhvdXRcbi8vIHRob3NlIG9iamVjdHMgdGhyb3dzIGVycm9ycy4gVGhlcmVmb3JlLCBpbnN0ZWFkIG9mXG4vLyBkaXJlY3RseSBgaW1wb3J0YGluZyAnaGFtbWVyanMnIGFuZCAnLi9jb25zdGFudHMnXG4vLyAod2hpY2ggaW1wb3J0cyBIYW1tZXIuanMpIHdlIGNvbmRpdGlvbmFsbHkgcmVxdWlyZSBpdFxuLy8gZGVwZW5kaW5nIG9uIHN1cHBvcnQgZm9yIHRob3NlIGdsb2JhbHMsIGFuZCBwcm92aWRlIG1vY2tzXG4vLyBmb3IgZW52aXJvbm1lbnRzIHdpdGhvdXQgYGRvY3VtZW50YC9gd2luZG93YC5cbmZ1bmN0aW9uIE1hbmFnZXJNb2NrKG0pIHtcbiAgY29uc3QgaW5zdGFuY2UgPSB7fTtcbiAgY29uc3QgY2hhaW5lZE5vb3AgPSAoKSA9PiBpbnN0YW5jZTtcbiAgaW5zdGFuY2UuZ2V0ID0gKCkgPT4gbnVsbDtcbiAgaW5zdGFuY2Uub24gPSBjaGFpbmVkTm9vcDtcbiAgaW5zdGFuY2Uub2ZmID0gY2hhaW5lZE5vb3A7XG4gIGluc3RhbmNlLmRlc3Ryb3kgPSBjaGFpbmVkTm9vcDtcbiAgaW5zdGFuY2UuZW1pdCA9IGNoYWluZWROb29wO1xuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbmNvbnN0IE1hbmFnZXIgPSBpc0Jyb3dzZXIgPyByZXF1aXJlKCdoYW1tZXJqcycpLk1hbmFnZXIgOiBNYW5hZ2VyTW9jaztcbmNvbnN0IHtcbiAgQkFTSUNfRVZFTlRfQUxJQVNFUyxcbiAgRVZFTlRfUkVDT0dOSVpFUl9NQVAsXG4gIFJFQ09HTklaRVJTLFxuICBHRVNUVVJFX0VWRU5UX0FMSUFTRVNcbn0gPSBpc0Jyb3dzZXIgPyByZXF1aXJlKCcuL2NvbnN0YW50cycpIDoge1xuICBCQVNJQ19FVkVOVF9BTElBU0VTOiB7fSxcbiAgRVZFTlRfUkVDT0dOSVpFUl9NQVA6IHt9LFxuICBHRVNUVVJFX0VWRU5UX0FMSUFTRVM6IHt9XG59O1xuXG4vKipcbiAqIFNpbmdsZSBBUEkgZm9yIHN1YnNjcmliaW5nIHRvIGV2ZW50cyBhYm91dCBib3RoXG4gKiBiYXNpYyBpbnB1dCBldmVudHMgKGUuZy4gJ21vdXNlbW92ZScsICd0b3VjaHN0YXJ0JywgJ3doZWVsJylcbiAqIGFuZCBnZXN0dXJhbCBpbnB1dCAoZS5nLiAnY2xpY2snLCAndGFwJywgJ3BhbnN0YXJ0JykuXG4gKiBEZWxlZ2F0ZXMgZXZlbnQgcmVnaXN0cmF0aW9uIGFuZCBoYW5kbGluZyB0byBIYW1tZXIuanMuXG4gKiBAcGFyYW0ge0RPTSBFbGVtZW50fSBlbGVtZW50ICAgICAgICAgRE9NIGVsZW1lbnQgb24gd2hpY2ggZXZlbnQgaGFuZGxlcnMgd2lsbCBiZSByZWdpc3RlcmVkLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgICAgICAgICAgICAgIE9wdGlvbnMgZm9yIGluc3RhbnRpYXRpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLmV2ZW50cyAgICAgICBNYXAgb2Yge2V2ZW50IG5hbWU6IGhhbmRsZXJ9IHRvIHJlZ2lzdGVyIG9uIGluaXQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5yZWNvZ25pemVycyAgR2VzdHVyZSByZWNvZ25pemVycyBmcm9tIEhhbW1lci5qcyB0byByZWdpc3RlcixcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcyBhbiBBcnJheSBpbiBIYW1tZXIuUmVjb2duaXplciBmb3JtYXQuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGh0dHA6Ly9oYW1tZXJqcy5naXRodWIuaW8vYXBpLyNoYW1tZXJtYW5hZ2VyKVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFdmVudE1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuX29uQmFzaWNJbnB1dCA9IHRoaXMuX29uQmFzaWNJbnB1dC5iaW5kKHRoaXMpO1xuICAgIHRoaXMubWFuYWdlciA9IG5ldyBNYW5hZ2VyKGVsZW1lbnQsIHtyZWNvZ25pemVyczogb3B0aW9ucy5yZWNvZ25pemVycyB8fCBSRUNPR05JWkVSU30pXG4gICAgICAub24oJ2hhbW1lci5pbnB1dCcsIHRoaXMuX29uQmFzaWNJbnB1dCk7XG5cbiAgICB0aGlzLmV2ZW50SGFuZGxlcnMgPSBbXTtcblxuICAgIC8vIEhhbmRsZSBldmVudHMgbm90IGhhbmRsZWQgYnkgSGFtbWVyLmpzOlxuICAgIC8vIC0gbW91c2Ugd2hlZWxcbiAgICAvLyAtIHBvaW50ZXIvdG91Y2gvbW91c2UgbW92ZVxuICAgIHRoaXMuX29uT3RoZXJFdmVudCA9IHRoaXMuX29uT3RoZXJFdmVudC5iaW5kKHRoaXMpO1xuICAgIHRoaXMud2hlZWxJbnB1dCA9IG5ldyBXaGVlbElucHV0KGVsZW1lbnQsIHRoaXMuX29uT3RoZXJFdmVudCwge2VuYWJsZTogZmFsc2V9KTtcbiAgICB0aGlzLm1vdmVJbnB1dCA9IG5ldyBNb3ZlSW5wdXQoZWxlbWVudCwgdGhpcy5fb25PdGhlckV2ZW50LCB7ZW5hYmxlOiBmYWxzZX0pO1xuXG4gICAgLy8gUmVnaXN0ZXIgYWxsIHBhc3NlZCBldmVudHMuXG4gICAgY29uc3Qge2V2ZW50c30gPSBvcHRpb25zO1xuICAgIGlmIChldmVudHMpIHtcbiAgICAgIHRoaXMub24oZXZlbnRzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGVhciBkb3duIGludGVybmFsIGV2ZW50IG1hbmFnZW1lbnQgaW1wbGVtZW50YXRpb25zLlxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLndoZWVsSW5wdXQuZGVzdHJveSgpO1xuICAgIHRoaXMubW92ZUlucHV0LmRlc3Ryb3koKTtcbiAgICB0aGlzLm1hbmFnZXIuZGVzdHJveSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGFuIGV2ZW50IGhhbmRsZXIgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIGBldmVudGAuXG4gICAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gZXZlbnQgICBBbiBldmVudCBuYW1lIChTdHJpbmcpIG9yIG1hcCBvZiBldmVudCBuYW1lcyB0byBoYW5kbGVycy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2hhbmRsZXJdICAgIFRoZSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb24gYGV2ZW50YC5cbiAgICovXG4gIG9uKGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgaWYgKHR5cGVvZiBldmVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuX2FkZEV2ZW50SGFuZGxlcihldmVudCwgaGFuZGxlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIGBldmVudGAgaXMgYSBtYXAsIGNhbGwgYG9uKClgIGZvciBlYWNoIGVudHJ5LlxuICAgICAgZm9yIChjb25zdCBldmVudE5hbWUgaW4gZXZlbnQpIHtcbiAgICAgICAgdGhpcy5fYWRkRXZlbnRIYW5kbGVyKGV2ZW50TmFtZSwgZXZlbnRbZXZlbnROYW1lXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXIgYSBwcmV2aW91c2x5LXJlZ2lzdGVyZWQgZXZlbnQgaGFuZGxlci5cbiAgICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBldmVudCAgIEFuIGV2ZW50IG5hbWUgKFN0cmluZykgb3IgbWFwIG9mIGV2ZW50IG5hbWVzIHRvIGhhbmRsZXJzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtoYW5kbGVyXSAgICBUaGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIGBldmVudGAuXG4gICAqL1xuICBvZmYoZXZlbnQsIGhhbmRsZXIpIHtcbiAgICBpZiAodHlwZW9mIGV2ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5fcmVtb3ZlRXZlbnRIYW5kbGVyKGV2ZW50LCBoYW5kbGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgYGV2ZW50YCBpcyBhIG1hcCwgY2FsbCBgb2ZmKClgIGZvciBlYWNoIGVudHJ5LlxuICAgICAgZm9yIChjb25zdCBldmVudE5hbWUgaW4gZXZlbnQpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlRXZlbnRIYW5kbGVyKGV2ZW50TmFtZSwgZXZlbnRbZXZlbnROYW1lXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLypcbiAgICogRW5hYmxlL2Rpc2FibGUgcmVjb2duaXplciBmb3IgdGhlIGdpdmVuIGV2ZW50XG4gICAqL1xuICBfdG9nZ2xlUmVjb2duaXplcihuYW1lLCBlbmFibGVkKSB7XG4gICAgY29uc3QgcmVjb2duaXplciA9IHRoaXMubWFuYWdlci5nZXQobmFtZSk7XG4gICAgaWYgKHJlY29nbml6ZXIpIHtcbiAgICAgIHJlY29nbml6ZXIuc2V0KHtlbmFibGU6IGVuYWJsZWR9KTtcbiAgICB9XG4gICAgdGhpcy53aGVlbElucHV0LnRvZ2dsZUlmRXZlbnRTdXBwb3J0ZWQobmFtZSwgZW5hYmxlZCk7XG4gICAgdGhpcy5tb3ZlSW5wdXQudG9nZ2xlSWZFdmVudFN1cHBvcnRlZChuYW1lLCBlbmFibGVkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9jZXNzIHRoZSBldmVudCByZWdpc3RyYXRpb24gZm9yIGEgc2luZ2xlIGV2ZW50ICsgaGFuZGxlci5cbiAgICovXG4gIF9hZGRFdmVudEhhbmRsZXIoZXZlbnQsIGhhbmRsZXIpIHtcbiAgICBjb25zdCB3cmFwcGVkSGFuZGxlciA9IHRoaXMuX3dyYXBFdmVudEhhbmRsZXIoZXZlbnQsIGhhbmRsZXIpO1xuICAgIC8vIEFsaWFzIHRvIGEgcmVjb2duaXplZCBnZXN0dXJlIGFzIG5lY2Vzc2FyeS5cbiAgICBjb25zdCBldmVudEFsaWFzID0gR0VTVFVSRV9FVkVOVF9BTElBU0VTW2V2ZW50XSB8fCBldmVudDtcbiAgICAvLyBHZXQgcmVjb2duaXplciBmb3IgdGhpcyBldmVudFxuICAgIGNvbnN0IHJlY29nbml6ZXJOYW1lID0gRVZFTlRfUkVDT0dOSVpFUl9NQVBbZXZlbnRBbGlhc10gfHwgZXZlbnRBbGlhcztcbiAgICAvLyBFbmFibGUgcmVjb2duaXplciBmb3IgdGhpcyBldmVudC5cbiAgICB0aGlzLl90b2dnbGVSZWNvZ25pemVyKHJlY29nbml6ZXJOYW1lLCB0cnVlKTtcblxuICAgIC8vIFNhdmUgd3JhcHBlZCBoYW5kbGVyXG4gICAgdGhpcy5ldmVudEhhbmRsZXJzLnB1c2goe2V2ZW50LCBldmVudEFsaWFzLCByZWNvZ25pemVyTmFtZSwgaGFuZGxlciwgd3JhcHBlZEhhbmRsZXJ9KTtcblxuICAgIHRoaXMubWFuYWdlci5vbihldmVudEFsaWFzLCB3cmFwcGVkSGFuZGxlcik7XG4gIH1cblxuICAvKipcbiAgICogUHJvY2VzcyB0aGUgZXZlbnQgZGVyZWdpc3RyYXRpb24gZm9yIGEgc2luZ2xlIGV2ZW50ICsgaGFuZGxlci5cbiAgICovXG4gIF9yZW1vdmVFdmVudEhhbmRsZXIoZXZlbnQsIGhhbmRsZXIpIHtcbiAgICBsZXQgZXZlbnRIYW5kbGVyUmVtb3ZlZCA9IGZhbHNlO1xuXG4gICAgLy8gRmluZCBzYXZlZCBoYW5kbGVyIGlmIGFueS5cbiAgICBmb3IgKGxldCBpID0gdGhpcy5ldmVudEhhbmRsZXJzLmxlbmd0aDsgaS0tOykge1xuICAgICAgY29uc3QgZW50cnkgPSB0aGlzLmV2ZW50SGFuZGxlcnNbaV07XG4gICAgICBpZiAoZW50cnkuZXZlbnQgPT09IGV2ZW50ICYmIGVudHJ5LmhhbmRsZXIgPT09IGhhbmRsZXIpIHtcbiAgICAgICAgLy8gRGVyZWdpc3RlciBldmVudCBoYW5kbGVyLlxuICAgICAgICB0aGlzLm1hbmFnZXIub2ZmKGVudHJ5LmV2ZW50QWxpYXMsIGVudHJ5LndyYXBwZWRIYW5kbGVyKTtcbiAgICAgICAgLy8gRGVsZXRlIHNhdmVkIGhhbmRsZXJcbiAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgZXZlbnRIYW5kbGVyUmVtb3ZlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50SGFuZGxlclJlbW92ZWQpIHtcbiAgICAgIC8vIEFsaWFzIHRvIGEgcmVjb2duaXplZCBnZXN0dXJlIGFzIG5lY2Vzc2FyeS5cbiAgICAgIGNvbnN0IGV2ZW50QWxpYXMgPSBHRVNUVVJFX0VWRU5UX0FMSUFTRVNbZXZlbnRdIHx8IGV2ZW50O1xuICAgICAgLy8gR2V0IHJlY29nbml6ZXIgZm9yIHRoaXMgZXZlbnRcbiAgICAgIGNvbnN0IHJlY29nbml6ZXJOYW1lID0gRVZFTlRfUkVDT0dOSVpFUl9NQVBbZXZlbnRBbGlhc10gfHwgZXZlbnRBbGlhcztcbiAgICAgIC8vIERpc2FibGUgcmVjb2duaXplciBpZiBubyBtb3JlIGhhbmRsZXJzIGFyZSBhdHRhY2hlZCB0byBpdHMgZXZlbnRzXG4gICAgICBjb25zdCBpc1JlY29nbml6ZXJVc2VkID0gdGhpcy5ldmVudEhhbmRsZXJzLmZpbmQoXG4gICAgICAgIGVudHJ5ID0+IGVudHJ5LnJlY29nbml6ZXJOYW1lID09PSByZWNvZ25pemVyTmFtZVxuICAgICAgKTtcbiAgICAgIGlmICghaXNSZWNvZ25pemVyVXNlZCkge1xuICAgICAgICB0aGlzLl90b2dnbGVSZWNvZ25pemVyKHJlY29nbml6ZXJOYW1lLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gZXZlbnQgaGFuZGxlciB0aGF0IGFsaWFzZXMgZXZlbnRzIGFuZCBhZGQgcHJvcHMgYmVmb3JlIHBhc3NpbmdcbiAgICogdG8gdGhlIHJlYWwgaGFuZGxlci5cbiAgICovXG4gIF93cmFwRXZlbnRIYW5kbGVyKHR5cGUsIGhhbmRsZXIpIHtcbiAgICByZXR1cm4gZXZlbnQgPT4ge1xuICAgICAgY29uc3Qge2VsZW1lbnR9ID0gdGhpcztcbiAgICAgIGNvbnN0IHtzcmNFdmVudH0gPSBldmVudDtcblxuICAgICAgY29uc3QgY2VudGVyID0gZXZlbnQuY2VudGVyIHx8IHtcbiAgICAgICAgeDogc3JjRXZlbnQuY2xpZW50WCxcbiAgICAgICAgeTogc3JjRXZlbnQuY2xpZW50WVxuICAgICAgfTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIGNlbnRlciByZWxhdGl2ZSB0byB0aGUgcm9vdCBlbGVtZW50XG4gICAgICAvLyBUT0RPL3hpYW9qaSAtIGF2b2lkIHVzaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBmb3IgcGVyZj9cbiAgICAgIGNvbnN0IHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3Qgb2Zmc2V0Q2VudGVyID0ge1xuICAgICAgICB4OiBjZW50ZXIueCAtIHJlY3QubGVmdCAtIGVsZW1lbnQuY2xpZW50TGVmdCxcbiAgICAgICAgeTogY2VudGVyLnkgLSByZWN0LnRvcCAtIGVsZW1lbnQuY2xpZW50VG9wXG4gICAgICB9O1xuXG4gICAgICBoYW5kbGVyKE9iamVjdC5hc3NpZ24oe30sIGV2ZW50LCB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIGNlbnRlcixcbiAgICAgICAgb2Zmc2V0Q2VudGVyLFxuICAgICAgICByb290RWxlbWVudDogZWxlbWVudFxuICAgICAgfSkpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIGJhc2ljIGV2ZW50cyB1c2luZyB0aGUgJ2hhbW1lci5pbnB1dCcgSGFtbWVyLmpzIEFQSTpcbiAgICogQmVmb3JlIHJ1bm5pbmcgUmVjb2duaXplcnMsIEhhbW1lciBlbWl0cyBhICdoYW1tZXIuaW5wdXQnIGV2ZW50XG4gICAqIHdpdGggdGhlIGJhc2ljIGV2ZW50IGluZm8uIFRoaXMgZnVuY3Rpb24gZW1pdHMgYWxsIGJhc2ljIGV2ZW50c1xuICAgKiBhbGlhc2VkIHRvIHRoZSBcImNsYXNzXCIgb2YgZXZlbnQgcmVjZWl2ZWQuXG4gICAqIFNlZSBjb25zdGFudHMuQkFTSUNfRVZFTlRfQ0xBU1NFUyBiYXNpYyBldmVudCBjbGFzcyBkZWZpbml0aW9ucy5cbiAgICovXG4gIF9vbkJhc2ljSW5wdXQoZXZlbnQpIHtcbiAgICBjb25zdCB7c3JjRXZlbnR9ID0gZXZlbnQ7XG4gICAgY29uc3QgYWxpYXMgPSBCQVNJQ19FVkVOVF9BTElBU0VTW3NyY0V2ZW50LnR5cGVdO1xuICAgIGlmIChhbGlhcykge1xuICAgICAgLy8gZmlyZSBhbGwgZXZlbnRzIGFsaWFzZWQgdG8gc3JjRXZlbnQudHlwZVxuICAgICAgY29uc3QgZW1pdEV2ZW50ID0gT2JqZWN0LmFzc2lnbih7fSwgZXZlbnQsIHtpc0Rvd246IHRydWUsIHR5cGU6IGFsaWFzfSk7XG4gICAgICB0aGlzLm1hbmFnZXIuZW1pdChhbGlhcywgZW1pdEV2ZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIGV2ZW50cyBub3Qgc3VwcG9ydGVkIGJ5IEhhbW1lci5qcyxcbiAgICogYW5kIHBpcGUgYmFjayBvdXQgdGhyb3VnaCBzYW1lIChIYW1tZXIpIGNoYW5uZWwgdXNlZCBieSBvdGhlciBldmVudHMuXG4gICAqL1xuICBfb25PdGhlckV2ZW50KGV2ZW50KSB7XG4gICAgdGhpcy5tYW5hZ2VyLmVtaXQoZXZlbnQudHlwZSwgZXZlbnQpO1xuICB9XG5cbn1cbiJdfQ==