'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); // TODO - THESE UTILITIES COULD BE IMPORTED FROM WEB_MERCATOR_VIEWPORT


exports.projectFlat = projectFlat;
exports.unprojectFlat = unprojectFlat;
exports.calculateDistanceScales = calculateDistanceScales;
exports.getFov = getFov;
exports.getClippingPlanes = getClippingPlanes;
exports.makeProjectionMatrixFromMercatorParams = makeProjectionMatrixFromMercatorParams;
exports.makeUncenteredViewMatrixFromMercatorParams = makeUncenteredViewMatrixFromMercatorParams;

var _perspective = require('gl-mat4/perspective');

var _perspective2 = _interopRequireDefault(_perspective);

var _scale = require('gl-mat4/scale');

var _scale2 = _interopRequireDefault(_scale);

var _translate = require('gl-mat4/translate');

var _translate2 = _interopRequireDefault(_translate);

var _rotateX = require('gl-mat4/rotateX');

var _rotateX2 = _interopRequireDefault(_rotateX);

var _rotateZ = require('gl-mat4/rotateZ');

var _rotateZ2 = _interopRequireDefault(_rotateZ);

var _distance = require('gl-vec2/distance');

var _distance2 = _interopRequireDefault(_distance);

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// CONSTANTS
var PI = Math.PI;
var PI_4 = PI / 4;
var DEGREES_TO_RADIANS = PI / 180;
var RADIANS_TO_DEGREES = 180 / PI;
var TILE_SIZE = 512;
var WORLD_SCALE = TILE_SIZE;

var METERS_PER_DEGREE_AT_EQUATOR = 111000; // Approximately 111km per degree at equator

// Helper, avoids low-precision 32 bit matrices from gl-matrix mat4.create()
function createMat4() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}

/**
 * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.
 * Performs the nonlinear part of the web mercator projection.
 * Remaining projection is done with 4x4 matrices which also handles
 * perspective.
 *
 * @param {Array} lngLat - [lng, lat] coordinates
 *   Specifies a point on the sphere to project onto the map.
 * @return {Array} [x,y] coordinates.
 */
function projectFlat(_ref, scale) {
  var _ref2 = _slicedToArray(_ref, 2),
      lng = _ref2[0],
      lat = _ref2[1];

  scale = scale * WORLD_SCALE;
  var lambda2 = lng * DEGREES_TO_RADIANS;
  var phi2 = lat * DEGREES_TO_RADIANS;
  var x = scale * (lambda2 + PI) / (2 * PI);
  var y = scale * (PI - Math.log(Math.tan(PI_4 + phi2 * 0.5))) / (2 * PI);
  return [x, y];
}

/**
 * Unproject world point [x,y] on map onto {lat, lon} on sphere
 *
 * @param {object|Vector} xy - object with {x,y} members
 *  representing point on projected map plane
 * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.
 *   Has toArray method if you need a GeoJSON Array.
 *   Per cartographic tradition, lat and lon are specified as degrees.
 */
function unprojectFlat(_ref3, scale) {
  var _ref4 = _slicedToArray(_ref3, 2),
      x = _ref4[0],
      y = _ref4[1];

  scale = scale * WORLD_SCALE;
  var lambda2 = x / scale * (2 * PI) - PI;
  var phi2 = 2 * (Math.atan(Math.exp(PI - y / scale * (2 * PI))) - PI_4);
  return [lambda2 * RADIANS_TO_DEGREES, phi2 * RADIANS_TO_DEGREES];
}

/**
 * Calculate distance scales in meters around current lat/lon, both for
 * degrees and pixels.
 * In mercator projection mode, the distance scales vary significantly
 * with latitude.
 */
function calculateDistanceScales(_ref5) {
  var latitude = _ref5.latitude,
      longitude = _ref5.longitude,
      zoom = _ref5.zoom,
      scale = _ref5.scale;

  // Calculate scale from zoom if not provided
  scale = scale !== undefined ? scale : Math.pow(2, zoom);

  (0, _assert2.default)(!isNaN(latitude) && !isNaN(longitude) && !isNaN(scale));

  var latCosine = Math.cos(latitude * Math.PI / 180);

  var metersPerDegree = METERS_PER_DEGREE_AT_EQUATOR * latCosine;

  // Calculate number of pixels occupied by one degree longitude
  // around current lat/lon
  var pixelsPerDegreeX = (0, _distance2.default)(projectFlat([longitude + 0.5, latitude], scale), projectFlat([longitude - 0.5, latitude], scale));
  // Calculate number of pixels occupied by one degree latitude
  // around current lat/lon
  var pixelsPerDegreeY = (0, _distance2.default)(projectFlat([longitude, latitude + 0.5], scale), projectFlat([longitude, latitude - 0.5], scale));

  var pixelsPerMeterX = pixelsPerDegreeX / metersPerDegree;
  var pixelsPerMeterY = pixelsPerDegreeY / metersPerDegree;
  var pixelsPerMeterZ = (pixelsPerMeterX + pixelsPerMeterY) / 2;
  // const pixelsPerMeter = [pixelsPerMeterX, pixelsPerMeterY, pixelsPerMeterZ];

  var worldSize = TILE_SIZE * scale;
  var altPixelsPerMeter = worldSize / (4e7 * latCosine);
  var pixelsPerMeter = [altPixelsPerMeter, altPixelsPerMeter, altPixelsPerMeter];
  var metersPerPixel = [1 / altPixelsPerMeter, 1 / altPixelsPerMeter, 1 / pixelsPerMeterZ];

  var pixelsPerDegree = [pixelsPerDegreeX, pixelsPerDegreeY, pixelsPerMeterZ];
  var degreesPerPixel = [1 / pixelsPerDegreeX, 1 / pixelsPerDegreeY, 1 / pixelsPerMeterZ];

  // Main results, used for converting meters to latlng deltas and scaling offsets
  return {
    pixelsPerMeter: pixelsPerMeter,
    metersPerPixel: metersPerPixel,
    pixelsPerDegree: pixelsPerDegree,
    degreesPerPixel: degreesPerPixel
  };
}

// ATTRIBUTION:
// view and projection matrix creation is intentionally kept compatible with
// mapbox-gl's implementation to ensure that seamless interoperation
// with mapbox and react-map-gl. See: https://github.com/mapbox/mapbox-gl-js

// Variable fov (in radians)
function getFov(_ref6) {
  var height = _ref6.height,
      altitude = _ref6.altitude;

  return 2 * Math.atan(height / 2 / altitude);
}

function getClippingPlanes(_ref7) {
  var altitude = _ref7.altitude,
      pitch = _ref7.pitch;

  // Find the distance from the center point to the center top
  // in altitude units using law of sines.
  var pitchRadians = pitch * DEGREES_TO_RADIANS;
  var halfFov = Math.atan(0.5 / altitude);
  var topHalfSurfaceDistance = Math.sin(halfFov) * altitude / Math.sin(Math.PI / 2 - pitchRadians - halfFov);

  // Calculate z value of the farthest fragment that should be rendered.
  var farZ = Math.cos(Math.PI / 2 - pitchRadians) * topHalfSurfaceDistance + altitude;

  return { farZ: farZ, nearZ: 0.1 };
}

// PROJECTION MATRIX: PROJECTS FROM CAMERA (VIEW) SPACE TO CLIPSPACE
function makeProjectionMatrixFromMercatorParams(_ref8) {
  var width = _ref8.width,
      height = _ref8.height,
      pitch = _ref8.pitch,
      altitude = _ref8.altitude,
      _ref8$farZMultiplier = _ref8.farZMultiplier,
      farZMultiplier = _ref8$farZMultiplier === undefined ? 10 : _ref8$farZMultiplier;

  var _getClippingPlanes = getClippingPlanes({ altitude: altitude, pitch: pitch }),
      nearZ = _getClippingPlanes.nearZ,
      farZ = _getClippingPlanes.farZ;

  var fov = getFov({ height: height, altitude: altitude });

  var projectionMatrix = (0, _perspective2.default)(createMat4(), fov, // fov in radians
  width / height, // aspect ratio
  nearZ, // near plane
  farZ * farZMultiplier // far plane
  );

  return projectionMatrix;
}

function makeUncenteredViewMatrixFromMercatorParams(_ref9) {
  var width = _ref9.width,
      height = _ref9.height,
      longitude = _ref9.longitude,
      latitude = _ref9.latitude,
      zoom = _ref9.zoom,
      pitch = _ref9.pitch,
      bearing = _ref9.bearing,
      altitude = _ref9.altitude,
      center = _ref9.center;

  // VIEW MATRIX: PROJECTS FROM VIRTUAL PIXELS TO CAMERA SPACE
  // Note: As usual, matrix operation orders should be read in reverse
  // since vectors will be multiplied from the right during transformation
  var vm = createMat4();

  // Move camera to altitude
  (0, _translate2.default)(vm, vm, [0, 0, -altitude]);

  // After the rotateX, z values are in pixel units. Convert them to
  // altitude units. 1 altitude unit = the screen height.
  (0, _scale2.default)(vm, vm, [1, -1, 1 / height]);

  // Rotate by bearing, and then by pitch (which tilts the view)
  (0, _rotateX2.default)(vm, vm, pitch * DEGREES_TO_RADIANS);
  (0, _rotateZ2.default)(vm, vm, -bearing * DEGREES_TO_RADIANS);

  return vm;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy92aWV3cG9ydHMvd2ViLW1lcmNhdG9yLXV0aWxzLmpzIl0sIm5hbWVzIjpbInByb2plY3RGbGF0IiwidW5wcm9qZWN0RmxhdCIsImNhbGN1bGF0ZURpc3RhbmNlU2NhbGVzIiwiZ2V0Rm92IiwiZ2V0Q2xpcHBpbmdQbGFuZXMiLCJtYWtlUHJvamVjdGlvbk1hdHJpeEZyb21NZXJjYXRvclBhcmFtcyIsIm1ha2VVbmNlbnRlcmVkVmlld01hdHJpeEZyb21NZXJjYXRvclBhcmFtcyIsIlBJIiwiTWF0aCIsIlBJXzQiLCJERUdSRUVTX1RPX1JBRElBTlMiLCJSQURJQU5TX1RPX0RFR1JFRVMiLCJUSUxFX1NJWkUiLCJXT1JMRF9TQ0FMRSIsIk1FVEVSU19QRVJfREVHUkVFX0FUX0VRVUFUT1IiLCJjcmVhdGVNYXQ0Iiwic2NhbGUiLCJsbmciLCJsYXQiLCJsYW1iZGEyIiwicGhpMiIsIngiLCJ5IiwibG9nIiwidGFuIiwiYXRhbiIsImV4cCIsImxhdGl0dWRlIiwibG9uZ2l0dWRlIiwiem9vbSIsInVuZGVmaW5lZCIsInBvdyIsImlzTmFOIiwibGF0Q29zaW5lIiwiY29zIiwibWV0ZXJzUGVyRGVncmVlIiwicGl4ZWxzUGVyRGVncmVlWCIsInBpeGVsc1BlckRlZ3JlZVkiLCJwaXhlbHNQZXJNZXRlclgiLCJwaXhlbHNQZXJNZXRlclkiLCJwaXhlbHNQZXJNZXRlcloiLCJ3b3JsZFNpemUiLCJhbHRQaXhlbHNQZXJNZXRlciIsInBpeGVsc1Blck1ldGVyIiwibWV0ZXJzUGVyUGl4ZWwiLCJwaXhlbHNQZXJEZWdyZWUiLCJkZWdyZWVzUGVyUGl4ZWwiLCJoZWlnaHQiLCJhbHRpdHVkZSIsInBpdGNoIiwicGl0Y2hSYWRpYW5zIiwiaGFsZkZvdiIsInRvcEhhbGZTdXJmYWNlRGlzdGFuY2UiLCJzaW4iLCJmYXJaIiwibmVhcloiLCJ3aWR0aCIsImZhclpNdWx0aXBsaWVyIiwiZm92IiwicHJvamVjdGlvbk1hdHJpeCIsImJlYXJpbmciLCJjZW50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QUFPb0QsRUFBUDtBQUNEIiwiZmlsZSI6IndlYi1tZXJjYXRvci11dGlscy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIFRPRE8gLSBUSEVTRSBVVElMSVRJRVMgQ09VTEQgQkUgSU1QT1JURUQgRlJPTSBXRUJfTUVSQ0FUT1JfVklFV1BPUlRcbmltcG9ydCBtYXQ0X3BlcnNwZWN0aXZlIGZyb20gJ2dsLW1hdDQvcGVyc3BlY3RpdmUnO1xuaW1wb3J0IG1hdDRfc2NhbGUgZnJvbSAnZ2wtbWF0NC9zY2FsZSc7XG5pbXBvcnQgbWF0NF90cmFuc2xhdGUgZnJvbSAnZ2wtbWF0NC90cmFuc2xhdGUnO1xuaW1wb3J0IG1hdDRfcm90YXRlWCBmcm9tICdnbC1tYXQ0L3JvdGF0ZVgnO1xuaW1wb3J0IG1hdDRfcm90YXRlWiBmcm9tICdnbC1tYXQ0L3JvdGF0ZVonO1xuaW1wb3J0IHZlYzJfZGlzdGFuY2UgZnJvbSAnZ2wtdmVjMi9kaXN0YW5jZSc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5cbi8vIENPTlNUQU5UU1xuY29uc3QgUEkgPSBNYXRoLlBJO1xuY29uc3QgUElfNCA9IFBJIC8gNDtcbmNvbnN0IERFR1JFRVNfVE9fUkFESUFOUyA9IFBJIC8gMTgwO1xuY29uc3QgUkFESUFOU19UT19ERUdSRUVTID0gMTgwIC8gUEk7XG5jb25zdCBUSUxFX1NJWkUgPSA1MTI7XG5jb25zdCBXT1JMRF9TQ0FMRSA9IFRJTEVfU0laRTtcblxuY29uc3QgTUVURVJTX1BFUl9ERUdSRUVfQVRfRVFVQVRPUiA9IDExMTAwMDsgLy8gQXBwcm94aW1hdGVseSAxMTFrbSBwZXIgZGVncmVlIGF0IGVxdWF0b3JcblxuLy8gSGVscGVyLCBhdm9pZHMgbG93LXByZWNpc2lvbiAzMiBiaXQgbWF0cmljZXMgZnJvbSBnbC1tYXRyaXggbWF0NC5jcmVhdGUoKVxuZnVuY3Rpb24gY3JlYXRlTWF0NCgpIHtcbiAgcmV0dXJuIFsxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxXTtcbn1cblxuLyoqXG4gKiBQcm9qZWN0IFtsbmcsbGF0XSBvbiBzcGhlcmUgb250byBbeCx5XSBvbiA1MTIqNTEyIE1lcmNhdG9yIFpvb20gMCB0aWxlLlxuICogUGVyZm9ybXMgdGhlIG5vbmxpbmVhciBwYXJ0IG9mIHRoZSB3ZWIgbWVyY2F0b3IgcHJvamVjdGlvbi5cbiAqIFJlbWFpbmluZyBwcm9qZWN0aW9uIGlzIGRvbmUgd2l0aCA0eDQgbWF0cmljZXMgd2hpY2ggYWxzbyBoYW5kbGVzXG4gKiBwZXJzcGVjdGl2ZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBsbmdMYXQgLSBbbG5nLCBsYXRdIGNvb3JkaW5hdGVzXG4gKiAgIFNwZWNpZmllcyBhIHBvaW50IG9uIHRoZSBzcGhlcmUgdG8gcHJvamVjdCBvbnRvIHRoZSBtYXAuXG4gKiBAcmV0dXJuIHtBcnJheX0gW3gseV0gY29vcmRpbmF0ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm9qZWN0RmxhdChbbG5nLCBsYXRdLCBzY2FsZSkge1xuICBzY2FsZSA9IHNjYWxlICogV09STERfU0NBTEU7XG4gIGNvbnN0IGxhbWJkYTIgPSBsbmcgKiBERUdSRUVTX1RPX1JBRElBTlM7XG4gIGNvbnN0IHBoaTIgPSBsYXQgKiBERUdSRUVTX1RPX1JBRElBTlM7XG4gIGNvbnN0IHggPSBzY2FsZSAqIChsYW1iZGEyICsgUEkpIC8gKDIgKiBQSSk7XG4gIGNvbnN0IHkgPSBzY2FsZSAqIChQSSAtIE1hdGgubG9nKE1hdGgudGFuKFBJXzQgKyBwaGkyICogMC41KSkpIC8gKDIgKiBQSSk7XG4gIHJldHVybiBbeCwgeV07XG59XG5cbi8qKlxuICogVW5wcm9qZWN0IHdvcmxkIHBvaW50IFt4LHldIG9uIG1hcCBvbnRvIHtsYXQsIGxvbn0gb24gc3BoZXJlXG4gKlxuICogQHBhcmFtIHtvYmplY3R8VmVjdG9yfSB4eSAtIG9iamVjdCB3aXRoIHt4LHl9IG1lbWJlcnNcbiAqICByZXByZXNlbnRpbmcgcG9pbnQgb24gcHJvamVjdGVkIG1hcCBwbGFuZVxuICogQHJldHVybiB7R2VvQ29vcmRpbmF0ZXN9IC0gb2JqZWN0IHdpdGgge2xhdCxsb259IG9mIHBvaW50IG9uIHNwaGVyZS5cbiAqICAgSGFzIHRvQXJyYXkgbWV0aG9kIGlmIHlvdSBuZWVkIGEgR2VvSlNPTiBBcnJheS5cbiAqICAgUGVyIGNhcnRvZ3JhcGhpYyB0cmFkaXRpb24sIGxhdCBhbmQgbG9uIGFyZSBzcGVjaWZpZWQgYXMgZGVncmVlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVucHJvamVjdEZsYXQoW3gsIHldLCBzY2FsZSkge1xuICBzY2FsZSA9IHNjYWxlICogV09STERfU0NBTEU7XG4gIGNvbnN0IGxhbWJkYTIgPSAoeCAvIHNjYWxlKSAqICgyICogUEkpIC0gUEk7XG4gIGNvbnN0IHBoaTIgPSAyICogKE1hdGguYXRhbihNYXRoLmV4cChQSSAtICh5IC8gc2NhbGUpICogKDIgKiBQSSkpKSAtIFBJXzQpO1xuICByZXR1cm4gW2xhbWJkYTIgKiBSQURJQU5TX1RPX0RFR1JFRVMsIHBoaTIgKiBSQURJQU5TX1RPX0RFR1JFRVNdO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBkaXN0YW5jZSBzY2FsZXMgaW4gbWV0ZXJzIGFyb3VuZCBjdXJyZW50IGxhdC9sb24sIGJvdGggZm9yXG4gKiBkZWdyZWVzIGFuZCBwaXhlbHMuXG4gKiBJbiBtZXJjYXRvciBwcm9qZWN0aW9uIG1vZGUsIHRoZSBkaXN0YW5jZSBzY2FsZXMgdmFyeSBzaWduaWZpY2FudGx5XG4gKiB3aXRoIGxhdGl0dWRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlRGlzdGFuY2VTY2FsZXMoe2xhdGl0dWRlLCBsb25naXR1ZGUsIHpvb20sIHNjYWxlfSkge1xuICAvLyBDYWxjdWxhdGUgc2NhbGUgZnJvbSB6b29tIGlmIG5vdCBwcm92aWRlZFxuICBzY2FsZSA9IHNjYWxlICE9PSB1bmRlZmluZWQgPyBzY2FsZSA6IE1hdGgucG93KDIsIHpvb20pO1xuXG4gIGFzc2VydCghaXNOYU4obGF0aXR1ZGUpICYmICFpc05hTihsb25naXR1ZGUpICYmICFpc05hTihzY2FsZSkpO1xuXG4gIGNvbnN0IGxhdENvc2luZSA9IE1hdGguY29zKGxhdGl0dWRlICogTWF0aC5QSSAvIDE4MCk7XG5cbiAgY29uc3QgbWV0ZXJzUGVyRGVncmVlID0gTUVURVJTX1BFUl9ERUdSRUVfQVRfRVFVQVRPUiAqIGxhdENvc2luZTtcblxuICAvLyBDYWxjdWxhdGUgbnVtYmVyIG9mIHBpeGVscyBvY2N1cGllZCBieSBvbmUgZGVncmVlIGxvbmdpdHVkZVxuICAvLyBhcm91bmQgY3VycmVudCBsYXQvbG9uXG4gIGNvbnN0IHBpeGVsc1BlckRlZ3JlZVggPSB2ZWMyX2Rpc3RhbmNlKFxuICAgIHByb2plY3RGbGF0KFtsb25naXR1ZGUgKyAwLjUsIGxhdGl0dWRlXSwgc2NhbGUpLFxuICAgIHByb2plY3RGbGF0KFtsb25naXR1ZGUgLSAwLjUsIGxhdGl0dWRlXSwgc2NhbGUpXG4gICk7XG4gIC8vIENhbGN1bGF0ZSBudW1iZXIgb2YgcGl4ZWxzIG9jY3VwaWVkIGJ5IG9uZSBkZWdyZWUgbGF0aXR1ZGVcbiAgLy8gYXJvdW5kIGN1cnJlbnQgbGF0L2xvblxuICBjb25zdCBwaXhlbHNQZXJEZWdyZWVZID0gdmVjMl9kaXN0YW5jZShcbiAgICBwcm9qZWN0RmxhdChbbG9uZ2l0dWRlLCBsYXRpdHVkZSArIDAuNV0sIHNjYWxlKSxcbiAgICBwcm9qZWN0RmxhdChbbG9uZ2l0dWRlLCBsYXRpdHVkZSAtIDAuNV0sIHNjYWxlKVxuICApO1xuXG4gIGNvbnN0IHBpeGVsc1Blck1ldGVyWCA9IHBpeGVsc1BlckRlZ3JlZVggLyBtZXRlcnNQZXJEZWdyZWU7XG4gIGNvbnN0IHBpeGVsc1Blck1ldGVyWSA9IHBpeGVsc1BlckRlZ3JlZVkgLyBtZXRlcnNQZXJEZWdyZWU7XG4gIGNvbnN0IHBpeGVsc1Blck1ldGVyWiA9IChwaXhlbHNQZXJNZXRlclggKyBwaXhlbHNQZXJNZXRlclkpIC8gMjtcbiAgLy8gY29uc3QgcGl4ZWxzUGVyTWV0ZXIgPSBbcGl4ZWxzUGVyTWV0ZXJYLCBwaXhlbHNQZXJNZXRlclksIHBpeGVsc1Blck1ldGVyWl07XG5cbiAgY29uc3Qgd29ybGRTaXplID0gVElMRV9TSVpFICogc2NhbGU7XG4gIGNvbnN0IGFsdFBpeGVsc1Blck1ldGVyID0gd29ybGRTaXplIC8gKDRlNyAqIGxhdENvc2luZSk7XG4gIGNvbnN0IHBpeGVsc1Blck1ldGVyID0gW2FsdFBpeGVsc1Blck1ldGVyLCBhbHRQaXhlbHNQZXJNZXRlciwgYWx0UGl4ZWxzUGVyTWV0ZXJdO1xuICBjb25zdCBtZXRlcnNQZXJQaXhlbCA9IFsxIC8gYWx0UGl4ZWxzUGVyTWV0ZXIsIDEgLyBhbHRQaXhlbHNQZXJNZXRlciwgMSAvIHBpeGVsc1Blck1ldGVyWl07XG5cbiAgY29uc3QgcGl4ZWxzUGVyRGVncmVlID0gW3BpeGVsc1BlckRlZ3JlZVgsIHBpeGVsc1BlckRlZ3JlZVksIHBpeGVsc1Blck1ldGVyWl07XG4gIGNvbnN0IGRlZ3JlZXNQZXJQaXhlbCA9IFsxIC8gcGl4ZWxzUGVyRGVncmVlWCwgMSAvIHBpeGVsc1BlckRlZ3JlZVksIDEgLyBwaXhlbHNQZXJNZXRlclpdO1xuXG4gIC8vIE1haW4gcmVzdWx0cywgdXNlZCBmb3IgY29udmVydGluZyBtZXRlcnMgdG8gbGF0bG5nIGRlbHRhcyBhbmQgc2NhbGluZyBvZmZzZXRzXG4gIHJldHVybiB7XG4gICAgcGl4ZWxzUGVyTWV0ZXIsXG4gICAgbWV0ZXJzUGVyUGl4ZWwsXG4gICAgcGl4ZWxzUGVyRGVncmVlLFxuICAgIGRlZ3JlZXNQZXJQaXhlbFxuICB9O1xufVxuXG4vLyBBVFRSSUJVVElPTjpcbi8vIHZpZXcgYW5kIHByb2plY3Rpb24gbWF0cml4IGNyZWF0aW9uIGlzIGludGVudGlvbmFsbHkga2VwdCBjb21wYXRpYmxlIHdpdGhcbi8vIG1hcGJveC1nbCdzIGltcGxlbWVudGF0aW9uIHRvIGVuc3VyZSB0aGF0IHNlYW1sZXNzIGludGVyb3BlcmF0aW9uXG4vLyB3aXRoIG1hcGJveCBhbmQgcmVhY3QtbWFwLWdsLiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9tYXBib3gvbWFwYm94LWdsLWpzXG5cbi8vIFZhcmlhYmxlIGZvdiAoaW4gcmFkaWFucylcbmV4cG9ydCBmdW5jdGlvbiBnZXRGb3Yoe2hlaWdodCwgYWx0aXR1ZGV9KSB7XG4gIHJldHVybiAyICogTWF0aC5hdGFuKChoZWlnaHQgLyAyKSAvIGFsdGl0dWRlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldENsaXBwaW5nUGxhbmVzKHthbHRpdHVkZSwgcGl0Y2h9KSB7XG4gIC8vIEZpbmQgdGhlIGRpc3RhbmNlIGZyb20gdGhlIGNlbnRlciBwb2ludCB0byB0aGUgY2VudGVyIHRvcFxuICAvLyBpbiBhbHRpdHVkZSB1bml0cyB1c2luZyBsYXcgb2Ygc2luZXMuXG4gIGNvbnN0IHBpdGNoUmFkaWFucyA9IHBpdGNoICogREVHUkVFU19UT19SQURJQU5TO1xuICBjb25zdCBoYWxmRm92ID0gTWF0aC5hdGFuKDAuNSAvIGFsdGl0dWRlKTtcbiAgY29uc3QgdG9wSGFsZlN1cmZhY2VEaXN0YW5jZSA9XG4gICAgTWF0aC5zaW4oaGFsZkZvdikgKiBhbHRpdHVkZSAvIE1hdGguc2luKE1hdGguUEkgLyAyIC0gcGl0Y2hSYWRpYW5zIC0gaGFsZkZvdik7XG5cbiAgLy8gQ2FsY3VsYXRlIHogdmFsdWUgb2YgdGhlIGZhcnRoZXN0IGZyYWdtZW50IHRoYXQgc2hvdWxkIGJlIHJlbmRlcmVkLlxuICBjb25zdCBmYXJaID0gTWF0aC5jb3MoTWF0aC5QSSAvIDIgLSBwaXRjaFJhZGlhbnMpICogdG9wSGFsZlN1cmZhY2VEaXN0YW5jZSArIGFsdGl0dWRlO1xuXG4gIHJldHVybiB7ZmFyWiwgbmVhclo6IDAuMX07XG59XG5cbi8vIFBST0pFQ1RJT04gTUFUUklYOiBQUk9KRUNUUyBGUk9NIENBTUVSQSAoVklFVykgU1BBQ0UgVE8gQ0xJUFNQQUNFXG5leHBvcnQgZnVuY3Rpb24gbWFrZVByb2plY3Rpb25NYXRyaXhGcm9tTWVyY2F0b3JQYXJhbXMoe1xuICB3aWR0aCxcbiAgaGVpZ2h0LFxuICBwaXRjaCxcbiAgYWx0aXR1ZGUsXG4gIGZhclpNdWx0aXBsaWVyID0gMTBcbn0pIHtcbiAgY29uc3Qge25lYXJaLCBmYXJafSA9IGdldENsaXBwaW5nUGxhbmVzKHthbHRpdHVkZSwgcGl0Y2h9KTtcbiAgY29uc3QgZm92ID0gZ2V0Rm92KHtoZWlnaHQsIGFsdGl0dWRlfSk7XG5cbiAgY29uc3QgcHJvamVjdGlvbk1hdHJpeCA9IG1hdDRfcGVyc3BlY3RpdmUoXG4gICAgY3JlYXRlTWF0NCgpLFxuICAgIGZvdiwgICAgICAgICAgICAgIC8vIGZvdiBpbiByYWRpYW5zXG4gICAgd2lkdGggLyBoZWlnaHQsICAgLy8gYXNwZWN0IHJhdGlvXG4gICAgbmVhclosICAgICAgICAgICAgLy8gbmVhciBwbGFuZVxuICAgIGZhclogKiBmYXJaTXVsdGlwbGllciAvLyBmYXIgcGxhbmVcbiAgKTtcblxuICByZXR1cm4gcHJvamVjdGlvbk1hdHJpeDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VVbmNlbnRlcmVkVmlld01hdHJpeEZyb21NZXJjYXRvclBhcmFtcyh7XG4gIHdpZHRoLFxuICBoZWlnaHQsXG4gIGxvbmdpdHVkZSxcbiAgbGF0aXR1ZGUsXG4gIHpvb20sXG4gIHBpdGNoLFxuICBiZWFyaW5nLFxuICBhbHRpdHVkZSxcbiAgY2VudGVyXG59KSB7XG4gIC8vIFZJRVcgTUFUUklYOiBQUk9KRUNUUyBGUk9NIFZJUlRVQUwgUElYRUxTIFRPIENBTUVSQSBTUEFDRVxuICAvLyBOb3RlOiBBcyB1c3VhbCwgbWF0cml4IG9wZXJhdGlvbiBvcmRlcnMgc2hvdWxkIGJlIHJlYWQgaW4gcmV2ZXJzZVxuICAvLyBzaW5jZSB2ZWN0b3JzIHdpbGwgYmUgbXVsdGlwbGllZCBmcm9tIHRoZSByaWdodCBkdXJpbmcgdHJhbnNmb3JtYXRpb25cbiAgY29uc3Qgdm0gPSBjcmVhdGVNYXQ0KCk7XG5cbiAgLy8gTW92ZSBjYW1lcmEgdG8gYWx0aXR1ZGVcbiAgbWF0NF90cmFuc2xhdGUodm0sIHZtLCBbMCwgMCwgLWFsdGl0dWRlXSk7XG5cbiAgLy8gQWZ0ZXIgdGhlIHJvdGF0ZVgsIHogdmFsdWVzIGFyZSBpbiBwaXhlbCB1bml0cy4gQ29udmVydCB0aGVtIHRvXG4gIC8vIGFsdGl0dWRlIHVuaXRzLiAxIGFsdGl0dWRlIHVuaXQgPSB0aGUgc2NyZWVuIGhlaWdodC5cbiAgbWF0NF9zY2FsZSh2bSwgdm0sIFsxLCAtMSwgMSAvIGhlaWdodF0pO1xuXG4gIC8vIFJvdGF0ZSBieSBiZWFyaW5nLCBhbmQgdGhlbiBieSBwaXRjaCAod2hpY2ggdGlsdHMgdGhlIHZpZXcpXG4gIG1hdDRfcm90YXRlWCh2bSwgdm0sIHBpdGNoICogREVHUkVFU19UT19SQURJQU5TKTtcbiAgbWF0NF9yb3RhdGVaKHZtLCB2bSwgLWJlYXJpbmcgKiBERUdSRUVTX1RPX1JBRElBTlMpO1xuXG4gIHJldHVybiB2bTtcbn1cbiJdfQ==