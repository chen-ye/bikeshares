"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

exports.default = "const float TILE_SIZE = 512.0;\nconst float PI = 3.1415926536;\nconst float WORLD_SCALE = TILE_SIZE / (PI * 2.0);\n\n// ref: lib/constants.js\nconst float PROJECT_IDENTITY = 0.;\nconst float PROJECT_MERCATOR = 1.;\nconst float PROJECT_MERCATOR_OFFSETS = 2.;\n\nuniform float projectionMode;\nuniform float projectionScale;\nuniform vec4 projectionCenter;\nuniform vec3 projectionPixelsPerUnit;\n\nuniform mat4 modelMatrix;\nuniform mat4 projectionMatrix;\n\n//\n// Scaling offsets\n//\n\n// the scalar version of project_scale is for scaling the z component only\nfloat project_scale(float meters) {\n  return meters * projectionPixelsPerUnit.z;\n}\n\nvec2 project_scale(vec2 meters) {\n  return meters * projectionPixelsPerUnit.xy;\n}\n\nvec3 project_scale(vec3 meters) {\n  return vec3(\n    project_scale(meters.xy),\n    project_scale(meters.z)\n  );\n}\n\nvec4 project_scale(vec4 meters) {\n  return vec4(\n    project_scale(meters.xyz),\n    meters.w\n  );\n}\n\n//\n// Projecting positions\n//\n\n// non-linear projection: lnglats => unit tile [0-1, 0-1]\nvec2 project_mercator_(vec2 lnglat) {\n  return vec2(\n    radians(lnglat.x) + PI,\n    PI - log(tan_fp32(PI * 0.25 + radians(lnglat.y) * 0.5))\n  );\n}\n\nvec4 project_position(vec4 position) {\n\n  if (projectionMode == PROJECT_MERCATOR) {\n    return vec4(\n      project_mercator_(position.xy) * WORLD_SCALE * projectionScale,\n      project_scale(position.z),\n      position.w\n    );\n  }\n\n  // Apply model matrix\n  vec4 position_modelspace = modelMatrix * position;\n  return project_scale(position_modelspace);\n}\n\nvec3 project_position(vec3 position) {\n  vec4 projected_position = project_position(vec4(position, 1.0));\n  return projected_position.xyz;\n}\n\nvec2 project_position(vec2 position) {\n  vec4 projected_position = project_position(vec4(position, 0.0, 1.0));\n  return projected_position.xy;\n}\n\nvec4 project_to_clipspace(vec4 position) {\n  if (projectionMode == PROJECT_MERCATOR_OFFSETS) {\n    position.w *= projectionPixelsPerUnit.z;\n  }\n  return projectionMatrix * position + projectionCenter;\n}\n\n// Backwards compatibility\n\nfloat scale(float position) {\n  return project_scale(position);\n}\n\nvec2 scale(vec2 position) {\n  return project_scale(position);\n}\n\nvec3 scale(vec3 position) {\n  return project_scale(position);\n}\n\nvec4 scale(vec4 position) {\n  return project_scale(position);\n}\n\nvec2 preproject(vec2 position) {\n  return project_position(position);\n}\n\nvec3 preproject(vec3 position) {\n  return project_position(position);\n}\n\nvec4 preproject(vec4 position) {\n  return project_position(position);\n}\n\nvec4 project(vec4 position) {\n  return project_to_clipspace(position);\n}\n";
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9zaGFkZXJsaWIvcHJvamVjdC9wcm9qZWN0Lmdsc2wuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJwcm9qZWN0Lmdsc2wuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuZXhwb3J0IGRlZmF1bHQgYFxcXG5jb25zdCBmbG9hdCBUSUxFX1NJWkUgPSA1MTIuMDtcbmNvbnN0IGZsb2F0IFBJID0gMy4xNDE1OTI2NTM2O1xuY29uc3QgZmxvYXQgV09STERfU0NBTEUgPSBUSUxFX1NJWkUgLyAoUEkgKiAyLjApO1xuXG4vLyByZWY6IGxpYi9jb25zdGFudHMuanNcbmNvbnN0IGZsb2F0IFBST0pFQ1RfSURFTlRJVFkgPSAwLjtcbmNvbnN0IGZsb2F0IFBST0pFQ1RfTUVSQ0FUT1IgPSAxLjtcbmNvbnN0IGZsb2F0IFBST0pFQ1RfTUVSQ0FUT1JfT0ZGU0VUUyA9IDIuO1xuXG51bmlmb3JtIGZsb2F0IHByb2plY3Rpb25Nb2RlO1xudW5pZm9ybSBmbG9hdCBwcm9qZWN0aW9uU2NhbGU7XG51bmlmb3JtIHZlYzQgcHJvamVjdGlvbkNlbnRlcjtcbnVuaWZvcm0gdmVjMyBwcm9qZWN0aW9uUGl4ZWxzUGVyVW5pdDtcblxudW5pZm9ybSBtYXQ0IG1vZGVsTWF0cml4O1xudW5pZm9ybSBtYXQ0IHByb2plY3Rpb25NYXRyaXg7XG5cbi8vXG4vLyBTY2FsaW5nIG9mZnNldHNcbi8vXG5cbi8vIHRoZSBzY2FsYXIgdmVyc2lvbiBvZiBwcm9qZWN0X3NjYWxlIGlzIGZvciBzY2FsaW5nIHRoZSB6IGNvbXBvbmVudCBvbmx5XG5mbG9hdCBwcm9qZWN0X3NjYWxlKGZsb2F0IG1ldGVycykge1xuICByZXR1cm4gbWV0ZXJzICogcHJvamVjdGlvblBpeGVsc1BlclVuaXQuejtcbn1cblxudmVjMiBwcm9qZWN0X3NjYWxlKHZlYzIgbWV0ZXJzKSB7XG4gIHJldHVybiBtZXRlcnMgKiBwcm9qZWN0aW9uUGl4ZWxzUGVyVW5pdC54eTtcbn1cblxudmVjMyBwcm9qZWN0X3NjYWxlKHZlYzMgbWV0ZXJzKSB7XG4gIHJldHVybiB2ZWMzKFxuICAgIHByb2plY3Rfc2NhbGUobWV0ZXJzLnh5KSxcbiAgICBwcm9qZWN0X3NjYWxlKG1ldGVycy56KVxuICApO1xufVxuXG52ZWM0IHByb2plY3Rfc2NhbGUodmVjNCBtZXRlcnMpIHtcbiAgcmV0dXJuIHZlYzQoXG4gICAgcHJvamVjdF9zY2FsZShtZXRlcnMueHl6KSxcbiAgICBtZXRlcnMud1xuICApO1xufVxuXG4vL1xuLy8gUHJvamVjdGluZyBwb3NpdGlvbnNcbi8vXG5cbi8vIG5vbi1saW5lYXIgcHJvamVjdGlvbjogbG5nbGF0cyA9PiB1bml0IHRpbGUgWzAtMSwgMC0xXVxudmVjMiBwcm9qZWN0X21lcmNhdG9yXyh2ZWMyIGxuZ2xhdCkge1xuICByZXR1cm4gdmVjMihcbiAgICByYWRpYW5zKGxuZ2xhdC54KSArIFBJLFxuICAgIFBJIC0gbG9nKHRhbl9mcDMyKFBJICogMC4yNSArIHJhZGlhbnMobG5nbGF0LnkpICogMC41KSlcbiAgKTtcbn1cblxudmVjNCBwcm9qZWN0X3Bvc2l0aW9uKHZlYzQgcG9zaXRpb24pIHtcblxuICBpZiAocHJvamVjdGlvbk1vZGUgPT0gUFJPSkVDVF9NRVJDQVRPUikge1xuICAgIHJldHVybiB2ZWM0KFxuICAgICAgcHJvamVjdF9tZXJjYXRvcl8ocG9zaXRpb24ueHkpICogV09STERfU0NBTEUgKiBwcm9qZWN0aW9uU2NhbGUsXG4gICAgICBwcm9qZWN0X3NjYWxlKHBvc2l0aW9uLnopLFxuICAgICAgcG9zaXRpb24ud1xuICAgICk7XG4gIH1cblxuICAvLyBBcHBseSBtb2RlbCBtYXRyaXhcbiAgdmVjNCBwb3NpdGlvbl9tb2RlbHNwYWNlID0gbW9kZWxNYXRyaXggKiBwb3NpdGlvbjtcbiAgcmV0dXJuIHByb2plY3Rfc2NhbGUocG9zaXRpb25fbW9kZWxzcGFjZSk7XG59XG5cbnZlYzMgcHJvamVjdF9wb3NpdGlvbih2ZWMzIHBvc2l0aW9uKSB7XG4gIHZlYzQgcHJvamVjdGVkX3Bvc2l0aW9uID0gcHJvamVjdF9wb3NpdGlvbih2ZWM0KHBvc2l0aW9uLCAxLjApKTtcbiAgcmV0dXJuIHByb2plY3RlZF9wb3NpdGlvbi54eXo7XG59XG5cbnZlYzIgcHJvamVjdF9wb3NpdGlvbih2ZWMyIHBvc2l0aW9uKSB7XG4gIHZlYzQgcHJvamVjdGVkX3Bvc2l0aW9uID0gcHJvamVjdF9wb3NpdGlvbih2ZWM0KHBvc2l0aW9uLCAwLjAsIDEuMCkpO1xuICByZXR1cm4gcHJvamVjdGVkX3Bvc2l0aW9uLnh5O1xufVxuXG52ZWM0IHByb2plY3RfdG9fY2xpcHNwYWNlKHZlYzQgcG9zaXRpb24pIHtcbiAgaWYgKHByb2plY3Rpb25Nb2RlID09IFBST0pFQ1RfTUVSQ0FUT1JfT0ZGU0VUUykge1xuICAgIHBvc2l0aW9uLncgKj0gcHJvamVjdGlvblBpeGVsc1BlclVuaXQuejtcbiAgfVxuICByZXR1cm4gcHJvamVjdGlvbk1hdHJpeCAqIHBvc2l0aW9uICsgcHJvamVjdGlvbkNlbnRlcjtcbn1cblxuLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblxuZmxvYXQgc2NhbGUoZmxvYXQgcG9zaXRpb24pIHtcbiAgcmV0dXJuIHByb2plY3Rfc2NhbGUocG9zaXRpb24pO1xufVxuXG52ZWMyIHNjYWxlKHZlYzIgcG9zaXRpb24pIHtcbiAgcmV0dXJuIHByb2plY3Rfc2NhbGUocG9zaXRpb24pO1xufVxuXG52ZWMzIHNjYWxlKHZlYzMgcG9zaXRpb24pIHtcbiAgcmV0dXJuIHByb2plY3Rfc2NhbGUocG9zaXRpb24pO1xufVxuXG52ZWM0IHNjYWxlKHZlYzQgcG9zaXRpb24pIHtcbiAgcmV0dXJuIHByb2plY3Rfc2NhbGUocG9zaXRpb24pO1xufVxuXG52ZWMyIHByZXByb2plY3QodmVjMiBwb3NpdGlvbikge1xuICByZXR1cm4gcHJvamVjdF9wb3NpdGlvbihwb3NpdGlvbik7XG59XG5cbnZlYzMgcHJlcHJvamVjdCh2ZWMzIHBvc2l0aW9uKSB7XG4gIHJldHVybiBwcm9qZWN0X3Bvc2l0aW9uKHBvc2l0aW9uKTtcbn1cblxudmVjNCBwcmVwcm9qZWN0KHZlYzQgcG9zaXRpb24pIHtcbiAgcmV0dXJuIHByb2plY3RfcG9zaXRpb24ocG9zaXRpb24pO1xufVxuXG52ZWM0IHByb2plY3QodmVjNCBwb3NpdGlvbikge1xuICByZXR1cm4gcHJvamVjdF90b19jbGlwc3BhY2UocG9zaXRpb24pO1xufVxuYDtcbiJdfQ==