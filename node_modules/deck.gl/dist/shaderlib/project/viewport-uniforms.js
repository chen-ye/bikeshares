'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); // Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* global window */


exports.getUniformsFromViewport = getUniformsFromViewport;

var _invert = require('gl-mat4/invert');

var _invert2 = _interopRequireDefault(_invert);

var _multiply = require('gl-mat4/multiply');

var _multiply2 = _interopRequireDefault(_multiply);

var _transformMat = require('gl-vec4/transformMat4');

var _transformMat2 = _interopRequireDefault(_transformMat);

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

var _constants = require('../../lib/constants');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function fp64ify(a) {
  var hiPart = Math.fround(a);
  var loPart = a - hiPart;
  return [hiPart, loPart];
}

// To quickly set a vector to zero
var ZERO_VECTOR = [0, 0, 0, 0];
// 4x4 matrix that drops 4th component of vector
var VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];
var IDENTITY_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];

// The code that utilizes Matrix4 does the same calculation as their mat4 counterparts,
// has lower performance but provides error checking.
// Uncomment when debugging
function calculateMatrixAndOffset(_ref) {
  var projectionMode = _ref.projectionMode,
      positionOrigin = _ref.positionOrigin,
      viewport = _ref.viewport;
  var viewMatrixUncentered = viewport.viewMatrixUncentered,
      projectionMatrix = viewport.projectionMatrix;
  var viewMatrix = viewport.viewMatrix,
      viewProjectionMatrix = viewport.viewProjectionMatrix;

  var projectionCenter = void 0;

  switch (projectionMode) {

    case _constants.COORDINATE_SYSTEM.IDENTITY:
    case _constants.COORDINATE_SYSTEM.LNGLAT:
      projectionCenter = ZERO_VECTOR;
      break;

    // TODO: make lighitng work for meter offset mode
    case _constants.COORDINATE_SYSTEM.METER_OFFSETS:
      // Calculate transformed projectionCenter (in 64 bit precision)
      // This is the key to offset mode precision (avoids doing this
      // addition in 32 bit precision)
      var positionPixels = viewport.projectFlat(positionOrigin);
      // projectionCenter = new Matrix4(viewProjectionMatrix)
      //   .transformVector([positionPixels[0], positionPixels[1], 0.0, 1.0]);
      projectionCenter = (0, _transformMat2.default)([], [positionPixels[0], positionPixels[1], 0.0, 1.0], viewProjectionMatrix);

      // Always apply uncentered projection matrix if available (shader adds center)
      // Zero out 4th coordinate ("after" model matrix) - avoids further translations
      // viewMatrix = new Matrix4(viewMatrixUncentered || viewMatrix)
      //   .multiplyRight(VECTOR_TO_POINT_MATRIX);
      viewMatrix = (0, _multiply2.default)([], viewMatrixUncentered || viewMatrix, VECTOR_TO_POINT_MATRIX);
      viewProjectionMatrix = (0, _multiply2.default)([], projectionMatrix, viewMatrix);
      break;

    default:
      throw new Error('Unknown projection mode');
  }

  var viewMatrixInv = (0, _invert2.default)([], viewMatrix) || viewMatrix;
  var cameraPos = [viewMatrixInv[12], viewMatrixInv[13], viewMatrixInv[14]];

  return {
    viewMatrix: viewMatrix,
    viewProjectionMatrix: viewProjectionMatrix,
    projectionCenter: projectionCenter,
    cameraPos: cameraPos
  };
}

/**
 * Returns uniforms for shaders based on current projection
 * includes: projection matrix suitable for shaders
 *
 * TODO - Ensure this works with any viewport, not just WebMercatorViewports
 *
 * @param {WebMercatorViewport} viewport -
 * @return {Float32Array} - 4x4 projection matrix that can be used in shaders
 */
function getUniformsFromViewport() {
  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      viewport = _ref2.viewport,
      _ref2$modelMatrix = _ref2.modelMatrix,
      modelMatrix = _ref2$modelMatrix === undefined ? null : _ref2$modelMatrix,
      _ref2$projectionMode = _ref2.projectionMode,
      projectionMode = _ref2$projectionMode === undefined ? _constants.COORDINATE_SYSTEM.LNGLAT : _ref2$projectionMode,
      _ref2$positionOrigin = _ref2.positionOrigin,
      positionOrigin = _ref2$positionOrigin === undefined ? [0, 0] : _ref2$positionOrigin;

  if (!viewport) {
    return {};
  }

  (0, _assert2.default)(viewport.scale, 'Viewport scale missing');

  var _calculateMatrixAndOf = calculateMatrixAndOffset({ projectionMode: projectionMode, positionOrigin: positionOrigin, viewport: viewport }),
      projectionCenter = _calculateMatrixAndOf.projectionCenter,
      viewProjectionMatrix = _calculateMatrixAndOf.viewProjectionMatrix,
      cameraPos = _calculateMatrixAndOf.cameraPos;

  // Calculate projection pixels per unit


  var _viewport$getDistance = viewport.getDistanceScales(),
      pixelsPerMeter = _viewport$getDistance.pixelsPerMeter;

  (0, _assert2.default)(pixelsPerMeter, 'Viewport missing pixelsPerMeter');

  // "Float64Array"
  // Transpose the projection matrix to column major for GLSL.
  var glProjectionMatrixFP64 = new Float32Array(32);
  for (var i = 0; i < 4; ++i) {
    for (var j = 0; j < 4; ++j) {
      var _fp64ify = fp64ify(viewProjectionMatrix[j * 4 + i]);

      var _fp64ify2 = _slicedToArray(_fp64ify, 2);

      glProjectionMatrixFP64[(i * 4 + j) * 2] = _fp64ify2[0];
      glProjectionMatrixFP64[(i * 4 + j) * 2 + 1] = _fp64ify2[1];
    }
  }

  var devicePixelRatio = window && window.devicePixelRatio || 1;

  return {
    // Projection mode values
    projectionMode: projectionMode,
    projectionCenter: projectionCenter,

    // Screen size
    viewportSize: [viewport.width * devicePixelRatio, viewport.height * devicePixelRatio],
    devicePixelRatio: devicePixelRatio,

    // Main projection matrices
    modelMatrix: new Float32Array(modelMatrix || IDENTITY_MATRIX),
    // viewMatrix: new Float32Array(viewMatrix),
    projectionMatrix: new Float32Array(viewProjectionMatrix),
    projectionFP64: glProjectionMatrixFP64,

    projectionPixelsPerUnit: pixelsPerMeter,
    projectionScale: viewport.scale, // This is the mercator scale (2 ** zoom)
    projectionScaleFP64: fp64ify(viewport.scale), // Deprecated?

    // This is for lighting calculations
    cameraPos: new Float32Array(cameraPos)
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9zaGFkZXJsaWIvcHJvamVjdC92aWV3cG9ydC11bmlmb3Jtcy5qcyJdLCJuYW1lcyI6WyJnZXRVbmlmb3Jtc0Zyb21WaWV3cG9ydCIsImZwNjRpZnkiLCJhIiwiaGlQYXJ0IiwiTWF0aCIsImZyb3VuZCIsImxvUGFydCIsIlpFUk9fVkVDVE9SIiwiVkVDVE9SX1RPX1BPSU5UX01BVFJJWCIsIklERU5USVRZX01BVFJJWCIsImNhbGN1bGF0ZU1hdHJpeEFuZE9mZnNldCIsInByb2plY3Rpb25Nb2RlIiwicG9zaXRpb25PcmlnaW4iLCJ2aWV3cG9ydCIsInZpZXdNYXRyaXhVbmNlbnRlcmVkIiwicHJvamVjdGlvbk1hdHJpeCIsInZpZXdNYXRyaXgiLCJ2aWV3UHJvamVjdGlvbk1hdHJpeCIsInByb2plY3Rpb25DZW50ZXIiLCJJREVOVElUWSIsIkxOR0xBVCIsIk1FVEVSX09GRlNFVFMiLCJwb3NpdGlvblBpeGVscyIsInByb2plY3RGbGF0IiwiRXJyb3IiLCJ2aWV3TWF0cml4SW52IiwiY2FtZXJhUG9zIiwibW9kZWxNYXRyaXgiLCJzY2FsZSIsImdldERpc3RhbmNlU2NhbGVzIiwicGl4ZWxzUGVyTWV0ZXIiLCJnbFByb2plY3Rpb25NYXRyaXhGUDY0IiwiRmxvYXQzMkFycmF5IiwiaSIsImoiLCJkZXZpY2VQaXhlbFJhdGlvIiwid2luZG93Iiwidmlld3BvcnRTaXplIiwid2lkdGgiLCJoZWlnaHQiLCJwcm9qZWN0aW9uRlA2NCIsInByb2plY3Rpb25QaXhlbHNQZXJVbml0IiwicHJvamVjdGlvblNjYWxlIiwicHJvamVjdGlvblNjYWxlRlA2NCJdLCJtYXBwaW5ncyI6Ijs7Ozs7O3lwQkFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O1FBbUZnQkEsdUIsR0FBQUEsdUI7O0FBbEZoQjs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFFQTs7OztBQUNBOzs7O0FBRUEsU0FBU0MsT0FBVCxDQUFpQkMsQ0FBakIsRUFBb0I7QUFDbEIsTUFBTUMsU0FBU0MsS0FBS0MsTUFBTCxDQUFZSCxDQUFaLENBQWY7QUFDQSxNQUFNSSxTQUFTSixJQUFJQyxNQUFuQjtBQUNBLFNBQU8sQ0FBQ0EsTUFBRCxFQUFTRyxNQUFULENBQVA7QUFDRDs7QUFFRDtBQUNBLElBQU1DLGNBQWMsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLENBQXBCO0FBQ0E7QUFDQSxJQUFNQyx5QkFBeUIsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixFQUFtQixDQUFuQixFQUFzQixDQUF0QixFQUF5QixDQUF6QixFQUE0QixDQUE1QixFQUErQixDQUEvQixFQUFrQyxDQUFsQyxFQUFxQyxDQUFyQyxFQUF3QyxDQUF4QyxFQUEyQyxDQUEzQyxFQUE4QyxDQUE5QyxDQUEvQjtBQUNBLElBQU1DLGtCQUFrQixDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLEVBQW1CLENBQW5CLEVBQXNCLENBQXRCLEVBQXlCLENBQXpCLEVBQTRCLENBQTVCLEVBQStCLENBQS9CLEVBQWtDLENBQWxDLEVBQXFDLENBQXJDLEVBQXdDLENBQXhDLEVBQTJDLENBQTNDLEVBQThDLENBQTlDLENBQXhCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVNDLHdCQUFULE9BSUc7QUFBQSxNQUhEQyxjQUdDLFFBSERBLGNBR0M7QUFBQSxNQUZEQyxjQUVDLFFBRkRBLGNBRUM7QUFBQSxNQUREQyxRQUNDLFFBRERBLFFBQ0M7QUFBQSxNQUNNQyxvQkFETixHQUNnREQsUUFEaEQsQ0FDTUMsb0JBRE47QUFBQSxNQUM0QkMsZ0JBRDVCLEdBQ2dERixRQURoRCxDQUM0QkUsZ0JBRDVCO0FBQUEsTUFFSUMsVUFGSixHQUV3Q0gsUUFGeEMsQ0FFSUcsVUFGSjtBQUFBLE1BRWdCQyxvQkFGaEIsR0FFd0NKLFFBRnhDLENBRWdCSSxvQkFGaEI7O0FBR0QsTUFBSUMseUJBQUo7O0FBRUEsVUFBUVAsY0FBUjs7QUFFQSxTQUFLLDZCQUFrQlEsUUFBdkI7QUFDQSxTQUFLLDZCQUFrQkMsTUFBdkI7QUFDRUYseUJBQW1CWCxXQUFuQjtBQUNBOztBQUVGO0FBQ0EsU0FBSyw2QkFBa0JjLGFBQXZCO0FBQ0U7QUFDQTtBQUNBO0FBQ0EsVUFBTUMsaUJBQWlCVCxTQUFTVSxXQUFULENBQXFCWCxjQUFyQixDQUF2QjtBQUNBO0FBQ0E7QUFDQU0seUJBQW1CLDRCQUFtQixFQUFuQixFQUNqQixDQUFDSSxlQUFlLENBQWYsQ0FBRCxFQUFvQkEsZUFBZSxDQUFmLENBQXBCLEVBQXVDLEdBQXZDLEVBQTRDLEdBQTVDLENBRGlCLEVBRWpCTCxvQkFGaUIsQ0FBbkI7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQUQsbUJBQWEsd0JBQWMsRUFBZCxFQUFrQkYsd0JBQXdCRSxVQUExQyxFQUFzRFIsc0JBQXRELENBQWI7QUFDQVMsNkJBQXVCLHdCQUFjLEVBQWQsRUFBa0JGLGdCQUFsQixFQUFvQ0MsVUFBcEMsQ0FBdkI7QUFDQTs7QUFFRjtBQUNFLFlBQU0sSUFBSVEsS0FBSixDQUFVLHlCQUFWLENBQU47QUE1QkY7O0FBK0JBLE1BQU1DLGdCQUFnQixzQkFBWSxFQUFaLEVBQWdCVCxVQUFoQixLQUErQkEsVUFBckQ7QUFDQSxNQUFNVSxZQUFZLENBQUNELGNBQWMsRUFBZCxDQUFELEVBQW9CQSxjQUFjLEVBQWQsQ0FBcEIsRUFBdUNBLGNBQWMsRUFBZCxDQUF2QyxDQUFsQjs7QUFFQSxTQUFPO0FBQ0xULDBCQURLO0FBRUxDLDhDQUZLO0FBR0xDLHNDQUhLO0FBSUxRO0FBSkssR0FBUDtBQU1EOztBQUVEOzs7Ozs7Ozs7QUFTTyxTQUFTMUIsdUJBQVQsR0FLQztBQUFBLGtGQUFKLEVBQUk7QUFBQSxNQUpOYSxRQUlNLFNBSk5BLFFBSU07QUFBQSxnQ0FITmMsV0FHTTtBQUFBLE1BSE5BLFdBR00scUNBSFEsSUFHUjtBQUFBLG1DQUZOaEIsY0FFTTtBQUFBLE1BRk5BLGNBRU0sd0NBRlcsNkJBQWtCUyxNQUU3QjtBQUFBLG1DQUROUixjQUNNO0FBQUEsTUFETkEsY0FDTSx3Q0FEVyxDQUFDLENBQUQsRUFBSSxDQUFKLENBQ1g7O0FBQ04sTUFBSSxDQUFDQyxRQUFMLEVBQWU7QUFDYixXQUFPLEVBQVA7QUFDRDs7QUFFRCx3QkFBT0EsU0FBU2UsS0FBaEIsRUFBdUIsd0JBQXZCOztBQUxNLDhCQVFKbEIseUJBQXlCLEVBQUNDLDhCQUFELEVBQWlCQyw4QkFBakIsRUFBaUNDLGtCQUFqQyxFQUF6QixDQVJJO0FBQUEsTUFPQ0ssZ0JBUEQseUJBT0NBLGdCQVBEO0FBQUEsTUFPbUJELG9CQVBuQix5QkFPbUJBLG9CQVBuQjtBQUFBLE1BT3lDUyxTQVB6Qyx5QkFPeUNBLFNBUHpDOztBQVVOOzs7QUFWTSw4QkFXbUJiLFNBQVNnQixpQkFBVCxFQVhuQjtBQUFBLE1BV0NDLGNBWEQseUJBV0NBLGNBWEQ7O0FBWU4sd0JBQU9BLGNBQVAsRUFBdUIsaUNBQXZCOztBQUVBO0FBQ0E7QUFDQSxNQUFNQyx5QkFBeUIsSUFBSUMsWUFBSixDQUFpQixFQUFqQixDQUEvQjtBQUNBLE9BQUssSUFBSUMsSUFBSSxDQUFiLEVBQWdCQSxJQUFJLENBQXBCLEVBQXVCLEVBQUVBLENBQXpCLEVBQTRCO0FBQzFCLFNBQUssSUFBSUMsSUFBSSxDQUFiLEVBQWdCQSxJQUFJLENBQXBCLEVBQXVCLEVBQUVBLENBQXpCLEVBQTRCO0FBQUEscUJBSXRCakMsUUFBUWdCLHFCQUFxQmlCLElBQUksQ0FBSixHQUFRRCxDQUE3QixDQUFSLENBSnNCOztBQUFBOztBQUV4QkYsNkJBQXVCLENBQUNFLElBQUksQ0FBSixHQUFRQyxDQUFULElBQWMsQ0FBckMsQ0FGd0I7QUFHeEJILDZCQUF1QixDQUFDRSxJQUFJLENBQUosR0FBUUMsQ0FBVCxJQUFjLENBQWQsR0FBa0IsQ0FBekMsQ0FId0I7QUFLM0I7QUFDRjs7QUFFRCxNQUFNQyxtQkFBb0JDLFVBQVVBLE9BQU9ELGdCQUFsQixJQUF1QyxDQUFoRTs7QUFFQSxTQUFPO0FBQ0w7QUFDQXhCLGtDQUZLO0FBR0xPLHNDQUhLOztBQUtMO0FBQ0FtQixrQkFBYyxDQUFDeEIsU0FBU3lCLEtBQVQsR0FBaUJILGdCQUFsQixFQUFvQ3RCLFNBQVMwQixNQUFULEdBQWtCSixnQkFBdEQsQ0FOVDtBQU9MQSxzQ0FQSzs7QUFTTDtBQUNBUixpQkFBYSxJQUFJSyxZQUFKLENBQWlCTCxlQUFlbEIsZUFBaEMsQ0FWUjtBQVdMO0FBQ0FNLHNCQUFrQixJQUFJaUIsWUFBSixDQUFpQmYsb0JBQWpCLENBWmI7QUFhTHVCLG9CQUFnQlQsc0JBYlg7O0FBZUxVLDZCQUF5QlgsY0FmcEI7QUFnQkxZLHFCQUFpQjdCLFNBQVNlLEtBaEJyQixFQWdCNEI7QUFDakNlLHlCQUFxQjFDLFFBQVFZLFNBQVNlLEtBQWpCLENBakJoQixFQWlCeUM7O0FBRTlDO0FBQ0FGLGVBQVcsSUFBSU0sWUFBSixDQUFpQk4sU0FBakI7QUFwQk4sR0FBUDtBQXNCRCIsImZpbGUiOiJ2aWV3cG9ydC11bmlmb3Jtcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG4vKiBnbG9iYWwgd2luZG93ICovXG5pbXBvcnQgbWF0NF9pbnZlcnQgZnJvbSAnZ2wtbWF0NC9pbnZlcnQnO1xuaW1wb3J0IG1hdDRfbXVsdGlwbHkgZnJvbSAnZ2wtbWF0NC9tdWx0aXBseSc7XG5pbXBvcnQgdmVjNF90cmFuc2Zvcm1NYXQ0IGZyb20gJ2dsLXZlYzQvdHJhbnNmb3JtTWF0NCc7XG5cbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcbmltcG9ydCB7Q09PUkRJTkFURV9TWVNURU19IGZyb20gJy4uLy4uL2xpYi9jb25zdGFudHMnO1xuXG5mdW5jdGlvbiBmcDY0aWZ5KGEpIHtcbiAgY29uc3QgaGlQYXJ0ID0gTWF0aC5mcm91bmQoYSk7XG4gIGNvbnN0IGxvUGFydCA9IGEgLSBoaVBhcnQ7XG4gIHJldHVybiBbaGlQYXJ0LCBsb1BhcnRdO1xufVxuXG4vLyBUbyBxdWlja2x5IHNldCBhIHZlY3RvciB0byB6ZXJvXG5jb25zdCBaRVJPX1ZFQ1RPUiA9IFswLCAwLCAwLCAwXTtcbi8vIDR4NCBtYXRyaXggdGhhdCBkcm9wcyA0dGggY29tcG9uZW50IG9mIHZlY3RvclxuY29uc3QgVkVDVE9SX1RPX1BPSU5UX01BVFJJWCA9IFsxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAwXTtcbmNvbnN0IElERU5USVRZX01BVFJJWCA9IFsxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxXTtcblxuLy8gVGhlIGNvZGUgdGhhdCB1dGlsaXplcyBNYXRyaXg0IGRvZXMgdGhlIHNhbWUgY2FsY3VsYXRpb24gYXMgdGhlaXIgbWF0NCBjb3VudGVycGFydHMsXG4vLyBoYXMgbG93ZXIgcGVyZm9ybWFuY2UgYnV0IHByb3ZpZGVzIGVycm9yIGNoZWNraW5nLlxuLy8gVW5jb21tZW50IHdoZW4gZGVidWdnaW5nXG5mdW5jdGlvbiBjYWxjdWxhdGVNYXRyaXhBbmRPZmZzZXQoe1xuICBwcm9qZWN0aW9uTW9kZSxcbiAgcG9zaXRpb25PcmlnaW4sXG4gIHZpZXdwb3J0XG59KSB7XG4gIGNvbnN0IHt2aWV3TWF0cml4VW5jZW50ZXJlZCwgcHJvamVjdGlvbk1hdHJpeH0gPSB2aWV3cG9ydDtcbiAgbGV0IHt2aWV3TWF0cml4LCB2aWV3UHJvamVjdGlvbk1hdHJpeH0gPSB2aWV3cG9ydDtcbiAgbGV0IHByb2plY3Rpb25DZW50ZXI7XG5cbiAgc3dpdGNoIChwcm9qZWN0aW9uTW9kZSkge1xuXG4gIGNhc2UgQ09PUkRJTkFURV9TWVNURU0uSURFTlRJVFk6XG4gIGNhc2UgQ09PUkRJTkFURV9TWVNURU0uTE5HTEFUOlxuICAgIHByb2plY3Rpb25DZW50ZXIgPSBaRVJPX1ZFQ1RPUjtcbiAgICBicmVhaztcblxuICAvLyBUT0RPOiBtYWtlIGxpZ2hpdG5nIHdvcmsgZm9yIG1ldGVyIG9mZnNldCBtb2RlXG4gIGNhc2UgQ09PUkRJTkFURV9TWVNURU0uTUVURVJfT0ZGU0VUUzpcbiAgICAvLyBDYWxjdWxhdGUgdHJhbnNmb3JtZWQgcHJvamVjdGlvbkNlbnRlciAoaW4gNjQgYml0IHByZWNpc2lvbilcbiAgICAvLyBUaGlzIGlzIHRoZSBrZXkgdG8gb2Zmc2V0IG1vZGUgcHJlY2lzaW9uIChhdm9pZHMgZG9pbmcgdGhpc1xuICAgIC8vIGFkZGl0aW9uIGluIDMyIGJpdCBwcmVjaXNpb24pXG4gICAgY29uc3QgcG9zaXRpb25QaXhlbHMgPSB2aWV3cG9ydC5wcm9qZWN0RmxhdChwb3NpdGlvbk9yaWdpbik7XG4gICAgLy8gcHJvamVjdGlvbkNlbnRlciA9IG5ldyBNYXRyaXg0KHZpZXdQcm9qZWN0aW9uTWF0cml4KVxuICAgIC8vICAgLnRyYW5zZm9ybVZlY3RvcihbcG9zaXRpb25QaXhlbHNbMF0sIHBvc2l0aW9uUGl4ZWxzWzFdLCAwLjAsIDEuMF0pO1xuICAgIHByb2plY3Rpb25DZW50ZXIgPSB2ZWM0X3RyYW5zZm9ybU1hdDQoW10sXG4gICAgICBbcG9zaXRpb25QaXhlbHNbMF0sIHBvc2l0aW9uUGl4ZWxzWzFdLCAwLjAsIDEuMF0sXG4gICAgICB2aWV3UHJvamVjdGlvbk1hdHJpeCk7XG5cbiAgICAvLyBBbHdheXMgYXBwbHkgdW5jZW50ZXJlZCBwcm9qZWN0aW9uIG1hdHJpeCBpZiBhdmFpbGFibGUgKHNoYWRlciBhZGRzIGNlbnRlcilcbiAgICAvLyBaZXJvIG91dCA0dGggY29vcmRpbmF0ZSAoXCJhZnRlclwiIG1vZGVsIG1hdHJpeCkgLSBhdm9pZHMgZnVydGhlciB0cmFuc2xhdGlvbnNcbiAgICAvLyB2aWV3TWF0cml4ID0gbmV3IE1hdHJpeDQodmlld01hdHJpeFVuY2VudGVyZWQgfHwgdmlld01hdHJpeClcbiAgICAvLyAgIC5tdWx0aXBseVJpZ2h0KFZFQ1RPUl9UT19QT0lOVF9NQVRSSVgpO1xuICAgIHZpZXdNYXRyaXggPSBtYXQ0X211bHRpcGx5KFtdLCB2aWV3TWF0cml4VW5jZW50ZXJlZCB8fCB2aWV3TWF0cml4LCBWRUNUT1JfVE9fUE9JTlRfTUFUUklYKTtcbiAgICB2aWV3UHJvamVjdGlvbk1hdHJpeCA9IG1hdDRfbXVsdGlwbHkoW10sIHByb2plY3Rpb25NYXRyaXgsIHZpZXdNYXRyaXgpO1xuICAgIGJyZWFrO1xuXG4gIGRlZmF1bHQ6XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHByb2plY3Rpb24gbW9kZScpO1xuICB9XG5cbiAgY29uc3Qgdmlld01hdHJpeEludiA9IG1hdDRfaW52ZXJ0KFtdLCB2aWV3TWF0cml4KSB8fCB2aWV3TWF0cml4O1xuICBjb25zdCBjYW1lcmFQb3MgPSBbdmlld01hdHJpeEludlsxMl0sIHZpZXdNYXRyaXhJbnZbMTNdLCB2aWV3TWF0cml4SW52WzE0XV07XG5cbiAgcmV0dXJuIHtcbiAgICB2aWV3TWF0cml4LFxuICAgIHZpZXdQcm9qZWN0aW9uTWF0cml4LFxuICAgIHByb2plY3Rpb25DZW50ZXIsXG4gICAgY2FtZXJhUG9zXG4gIH07XG59XG5cbi8qKlxuICogUmV0dXJucyB1bmlmb3JtcyBmb3Igc2hhZGVycyBiYXNlZCBvbiBjdXJyZW50IHByb2plY3Rpb25cbiAqIGluY2x1ZGVzOiBwcm9qZWN0aW9uIG1hdHJpeCBzdWl0YWJsZSBmb3Igc2hhZGVyc1xuICpcbiAqIFRPRE8gLSBFbnN1cmUgdGhpcyB3b3JrcyB3aXRoIGFueSB2aWV3cG9ydCwgbm90IGp1c3QgV2ViTWVyY2F0b3JWaWV3cG9ydHNcbiAqXG4gKiBAcGFyYW0ge1dlYk1lcmNhdG9yVmlld3BvcnR9IHZpZXdwb3J0IC1cbiAqIEByZXR1cm4ge0Zsb2F0MzJBcnJheX0gLSA0eDQgcHJvamVjdGlvbiBtYXRyaXggdGhhdCBjYW4gYmUgdXNlZCBpbiBzaGFkZXJzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRVbmlmb3Jtc0Zyb21WaWV3cG9ydCh7XG4gIHZpZXdwb3J0LFxuICBtb2RlbE1hdHJpeCA9IG51bGwsXG4gIHByb2plY3Rpb25Nb2RlID0gQ09PUkRJTkFURV9TWVNURU0uTE5HTEFULFxuICBwb3NpdGlvbk9yaWdpbiA9IFswLCAwXVxufSA9IHt9KSB7XG4gIGlmICghdmlld3BvcnQpIHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICBhc3NlcnQodmlld3BvcnQuc2NhbGUsICdWaWV3cG9ydCBzY2FsZSBtaXNzaW5nJyk7XG5cbiAgY29uc3Qge3Byb2plY3Rpb25DZW50ZXIsIHZpZXdQcm9qZWN0aW9uTWF0cml4LCBjYW1lcmFQb3N9ID1cbiAgICBjYWxjdWxhdGVNYXRyaXhBbmRPZmZzZXQoe3Byb2plY3Rpb25Nb2RlLCBwb3NpdGlvbk9yaWdpbiwgdmlld3BvcnR9KTtcblxuICAvLyBDYWxjdWxhdGUgcHJvamVjdGlvbiBwaXhlbHMgcGVyIHVuaXRcbiAgY29uc3Qge3BpeGVsc1Blck1ldGVyfSA9IHZpZXdwb3J0LmdldERpc3RhbmNlU2NhbGVzKCk7XG4gIGFzc2VydChwaXhlbHNQZXJNZXRlciwgJ1ZpZXdwb3J0IG1pc3NpbmcgcGl4ZWxzUGVyTWV0ZXInKTtcblxuICAvLyBcIkZsb2F0NjRBcnJheVwiXG4gIC8vIFRyYW5zcG9zZSB0aGUgcHJvamVjdGlvbiBtYXRyaXggdG8gY29sdW1uIG1ham9yIGZvciBHTFNMLlxuICBjb25zdCBnbFByb2plY3Rpb25NYXRyaXhGUDY0ID0gbmV3IEZsb2F0MzJBcnJheSgzMik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgKytpKSB7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCA0OyArK2opIHtcbiAgICAgIFtcbiAgICAgICAgZ2xQcm9qZWN0aW9uTWF0cml4RlA2NFsoaSAqIDQgKyBqKSAqIDJdLFxuICAgICAgICBnbFByb2plY3Rpb25NYXRyaXhGUDY0WyhpICogNCArIGopICogMiArIDFdXG4gICAgICBdID0gZnA2NGlmeSh2aWV3UHJvamVjdGlvbk1hdHJpeFtqICogNCArIGldKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBkZXZpY2VQaXhlbFJhdGlvID0gKHdpbmRvdyAmJiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbykgfHwgMTtcblxuICByZXR1cm4ge1xuICAgIC8vIFByb2plY3Rpb24gbW9kZSB2YWx1ZXNcbiAgICBwcm9qZWN0aW9uTW9kZSxcbiAgICBwcm9qZWN0aW9uQ2VudGVyLFxuXG4gICAgLy8gU2NyZWVuIHNpemVcbiAgICB2aWV3cG9ydFNpemU6IFt2aWV3cG9ydC53aWR0aCAqIGRldmljZVBpeGVsUmF0aW8sIHZpZXdwb3J0LmhlaWdodCAqIGRldmljZVBpeGVsUmF0aW9dLFxuICAgIGRldmljZVBpeGVsUmF0aW8sXG5cbiAgICAvLyBNYWluIHByb2plY3Rpb24gbWF0cmljZXNcbiAgICBtb2RlbE1hdHJpeDogbmV3IEZsb2F0MzJBcnJheShtb2RlbE1hdHJpeCB8fCBJREVOVElUWV9NQVRSSVgpLFxuICAgIC8vIHZpZXdNYXRyaXg6IG5ldyBGbG9hdDMyQXJyYXkodmlld01hdHJpeCksXG4gICAgcHJvamVjdGlvbk1hdHJpeDogbmV3IEZsb2F0MzJBcnJheSh2aWV3UHJvamVjdGlvbk1hdHJpeCksXG4gICAgcHJvamVjdGlvbkZQNjQ6IGdsUHJvamVjdGlvbk1hdHJpeEZQNjQsXG5cbiAgICBwcm9qZWN0aW9uUGl4ZWxzUGVyVW5pdDogcGl4ZWxzUGVyTWV0ZXIsXG4gICAgcHJvamVjdGlvblNjYWxlOiB2aWV3cG9ydC5zY2FsZSwgLy8gVGhpcyBpcyB0aGUgbWVyY2F0b3Igc2NhbGUgKDIgKiogem9vbSlcbiAgICBwcm9qZWN0aW9uU2NhbGVGUDY0OiBmcDY0aWZ5KHZpZXdwb3J0LnNjYWxlKSwgLy8gRGVwcmVjYXRlZD9cblxuICAgIC8vIFRoaXMgaXMgZm9yIGxpZ2h0aW5nIGNhbGN1bGF0aW9uc1xuICAgIGNhbWVyYVBvczogbmV3IEZsb2F0MzJBcnJheShjYW1lcmFQb3MpXG4gIH07XG59XG4iXX0=