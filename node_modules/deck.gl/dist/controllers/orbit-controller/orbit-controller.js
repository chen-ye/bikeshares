'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _orbitViewport = require('./orbit-viewport');

var _orbitViewport2 = _interopRequireDefault(_orbitViewport);

var _orbitControls = require('./orbit-controls');

var _orbitControls2 = _interopRequireDefault(_orbitControls);

var _eventManager = require('../../utils/events/event-manager');

var _eventManager2 = _interopRequireDefault(_eventManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var propTypes = {
  /* Viewport properties */
  lookAt: _propTypes2.default.arrayOf(_propTypes2.default.number), // target position
  distance: _propTypes2.default.number, // distance from camera to the target
  rotationX: _propTypes2.default.number, // rotation around X axis
  rotationY: _propTypes2.default.number, // rotation around Y axis
  translationX: _propTypes2.default.number, // translation x in screen space
  translationY: _propTypes2.default.number, // translation y in screen space
  zoom: _propTypes2.default.number, // scale in screen space
  minZoom: _propTypes2.default.number,
  maxZoom: _propTypes2.default.number,
  fov: _propTypes2.default.number, // field of view
  near: _propTypes2.default.number,
  far: _propTypes2.default.number,
  width: _propTypes2.default.number.isRequired, // viewport width in pixels
  height: _propTypes2.default.number.isRequired, // viewport height in pixels

  /* Model properties */
  bounds: _propTypes2.default.object, // bounds in the shape of {minX, minY, minZ, maxX, maxY, maxZ}

  /* Callbacks */
  onViewportChange: _propTypes2.default.func.isRequired,

  /* Controls */
  orbitControls: _propTypes2.default.object
};

var defaultProps = {
  lookAt: [0, 0, 0],
  rotationX: 0,
  rotationY: 0,
  translationX: 0,
  translationY: 0,
  distance: 10,
  zoom: 1,
  minZoom: 0,
  maxZoom: Infinity,
  fov: 50,
  near: 1,
  far: 1000
};

/*
 * Maps mouse interaction to a deck.gl Viewport
 */

var OrbitController = function (_React$Component) {
  _inherits(OrbitController, _React$Component);

  _createClass(OrbitController, null, [{
    key: 'getViewport',


    // Returns a deck.gl Viewport instance, to be used with the DeckGL component
    value: function getViewport(viewport) {
      return new _orbitViewport2.default(viewport);
    }
  }]);

  function OrbitController(props) {
    _classCallCheck(this, OrbitController);

    var _this = _possibleConstructorReturn(this, (OrbitController.__proto__ || Object.getPrototypeOf(OrbitController)).call(this, props));

    _this.state = {
      // Whether the cursor is down
      isDragging: false
    };

    _this._orbitControls = props.orbitControls || new _orbitControls2.default();
    return _this;
  }

  _createClass(OrbitController, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var eventCanvas = this.refs.eventCanvas;


      var eventManager = new _eventManager2.default(eventCanvas);
      this._eventManager = eventManager;

      this._orbitControls.setOptions(Object.assign({}, this.props, {
        onStateChange: this._onInteractiveStateChange.bind(this),
        eventManager: eventManager
      }));
    }
  }, {
    key: 'componentWillUpdate',
    value: function componentWillUpdate(nextProps) {
      this._orbitControls.setOptions(nextProps);
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      if (this._eventManager) {
        // Must destroy because hammer adds event listeners to window
        this._eventManager.destroy();
      }
    }
  }, {
    key: '_onInteractiveStateChange',
    value: function _onInteractiveStateChange(_ref) {
      var _ref$isDragging = _ref.isDragging,
          isDragging = _ref$isDragging === undefined ? false : _ref$isDragging;

      if (isDragging !== this.state.isDragging) {
        this.setState({ isDragging: isDragging });
      }
    }
  }, {
    key: 'render',
    value: function render() {
      return (0, _react.createElement)('div', {
        ref: 'eventCanvas'
      }, this.props.children);
    }
  }]);

  return OrbitController;
}(_react2.default.Component);

exports.default = OrbitController;


OrbitController.propTypes = propTypes;
OrbitController.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb250cm9sbGVycy9vcmJpdC1jb250cm9sbGVyL29yYml0LWNvbnRyb2xsZXIuanMiXSwibmFtZXMiOlsicHJvcFR5cGVzIiwibG9va0F0IiwiYXJyYXlPZiIsIm51bWJlciIsImRpc3RhbmNlIiwicm90YXRpb25YIiwicm90YXRpb25ZIiwidHJhbnNsYXRpb25YIiwidHJhbnNsYXRpb25ZIiwiem9vbSIsIm1pblpvb20iLCJtYXhab29tIiwiZm92IiwibmVhciIsImZhciIsIndpZHRoIiwiaXNSZXF1aXJlZCIsImhlaWdodCIsImJvdW5kcyIsIm9iamVjdCIsIm9uVmlld3BvcnRDaGFuZ2UiLCJmdW5jIiwib3JiaXRDb250cm9scyIsImRlZmF1bHRQcm9wcyIsIkluZmluaXR5IiwiT3JiaXRDb250cm9sbGVyIiwidmlld3BvcnQiLCJwcm9wcyIsInN0YXRlIiwiaXNEcmFnZ2luZyIsIl9vcmJpdENvbnRyb2xzIiwiZXZlbnRDYW52YXMiLCJyZWZzIiwiZXZlbnRNYW5hZ2VyIiwiX2V2ZW50TWFuYWdlciIsInNldE9wdGlvbnMiLCJPYmplY3QiLCJhc3NpZ24iLCJvblN0YXRlQ2hhbmdlIiwiX29uSW50ZXJhY3RpdmVTdGF0ZUNoYW5nZSIsImJpbmQiLCJuZXh0UHJvcHMiLCJkZXN0cm95Iiwic2V0U3RhdGUiLCJyZWYiLCJjaGlsZHJlbiIsIkNvbXBvbmVudCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUVBOzs7Ozs7Ozs7Ozs7QUFFQSxJQUFNQSxZQUFZO0FBQ2hCO0FBQ0FDLFVBQVEsb0JBQVVDLE9BQVYsQ0FBa0Isb0JBQVVDLE1BQTVCLENBRlEsRUFFNkI7QUFDN0NDLFlBQVUsb0JBQVVELE1BSEosRUFHWTtBQUM1QkUsYUFBVyxvQkFBVUYsTUFKTCxFQUlhO0FBQzdCRyxhQUFXLG9CQUFVSCxNQUxMLEVBS2E7QUFDN0JJLGdCQUFjLG9CQUFVSixNQU5SLEVBTWdCO0FBQ2hDSyxnQkFBYyxvQkFBVUwsTUFQUixFQU9nQjtBQUNoQ00sUUFBTSxvQkFBVU4sTUFSQSxFQVFRO0FBQ3hCTyxXQUFTLG9CQUFVUCxNQVRIO0FBVWhCUSxXQUFTLG9CQUFVUixNQVZIO0FBV2hCUyxPQUFLLG9CQUFVVCxNQVhDLEVBV087QUFDdkJVLFFBQU0sb0JBQVVWLE1BWkE7QUFhaEJXLE9BQUssb0JBQVVYLE1BYkM7QUFjaEJZLFNBQU8sb0JBQVVaLE1BQVYsQ0FBaUJhLFVBZFIsRUFjb0I7QUFDcENDLFVBQVEsb0JBQVVkLE1BQVYsQ0FBaUJhLFVBZlQsRUFlcUI7O0FBRXJDO0FBQ0FFLFVBQVEsb0JBQVVDLE1BbEJGLEVBa0JVOztBQUUxQjtBQUNBQyxvQkFBa0Isb0JBQVVDLElBQVYsQ0FBZUwsVUFyQmpCOztBQXVCaEI7QUFDQU0saUJBQWUsb0JBQVVIO0FBeEJULENBQWxCOztBQTJCQSxJQUFNSSxlQUFlO0FBQ25CdEIsVUFBUSxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxDQURXO0FBRW5CSSxhQUFXLENBRlE7QUFHbkJDLGFBQVcsQ0FIUTtBQUluQkMsZ0JBQWMsQ0FKSztBQUtuQkMsZ0JBQWMsQ0FMSztBQU1uQkosWUFBVSxFQU5TO0FBT25CSyxRQUFNLENBUGE7QUFRbkJDLFdBQVMsQ0FSVTtBQVNuQkMsV0FBU2EsUUFUVTtBQVVuQlosT0FBSyxFQVZjO0FBV25CQyxRQUFNLENBWGE7QUFZbkJDLE9BQUs7QUFaYyxDQUFyQjs7QUFlQTs7OztJQUdxQlcsZTs7Ozs7OztBQUVuQjtnQ0FDbUJDLFEsRUFBVTtBQUMzQixhQUFPLDRCQUFrQkEsUUFBbEIsQ0FBUDtBQUNEOzs7QUFFRCwyQkFBWUMsS0FBWixFQUFtQjtBQUFBOztBQUFBLGtJQUNYQSxLQURXOztBQUdqQixVQUFLQyxLQUFMLEdBQWE7QUFDWDtBQUNBQyxrQkFBWTtBQUZELEtBQWI7O0FBS0EsVUFBS0MsY0FBTCxHQUFzQkgsTUFBTUwsYUFBTixJQUF1Qiw2QkFBN0M7QUFSaUI7QUFTbEI7Ozs7d0NBRW1CO0FBQUEsVUFDWFMsV0FEVyxHQUNJLEtBQUtDLElBRFQsQ0FDWEQsV0FEVzs7O0FBR2xCLFVBQU1FLGVBQWUsMkJBQWlCRixXQUFqQixDQUFyQjtBQUNBLFdBQUtHLGFBQUwsR0FBcUJELFlBQXJCOztBQUVBLFdBQUtILGNBQUwsQ0FBb0JLLFVBQXBCLENBQStCQyxPQUFPQyxNQUFQLENBQWMsRUFBZCxFQUFrQixLQUFLVixLQUF2QixFQUE4QjtBQUMzRFcsdUJBQWUsS0FBS0MseUJBQUwsQ0FBK0JDLElBQS9CLENBQW9DLElBQXBDLENBRDRDO0FBRTNEUDtBQUYyRCxPQUE5QixDQUEvQjtBQUlEOzs7d0NBRW1CUSxTLEVBQVc7QUFDN0IsV0FBS1gsY0FBTCxDQUFvQkssVUFBcEIsQ0FBK0JNLFNBQS9CO0FBQ0Q7OzsyQ0FFc0I7QUFDckIsVUFBSSxLQUFLUCxhQUFULEVBQXdCO0FBQ3RCO0FBQ0EsYUFBS0EsYUFBTCxDQUFtQlEsT0FBbkI7QUFDRDtBQUNGOzs7b0RBRStDO0FBQUEsaUNBQXJCYixVQUFxQjtBQUFBLFVBQXJCQSxVQUFxQixtQ0FBUixLQUFROztBQUM5QyxVQUFJQSxlQUFlLEtBQUtELEtBQUwsQ0FBV0MsVUFBOUIsRUFBMEM7QUFDeEMsYUFBS2MsUUFBTCxDQUFjLEVBQUNkLHNCQUFELEVBQWQ7QUFDRDtBQUNGOzs7NkJBRVE7QUFDUCxhQUNFLDBCQUFjLEtBQWQsRUFBcUI7QUFDbkJlLGFBQUs7QUFEYyxPQUFyQixFQUVHLEtBQUtqQixLQUFMLENBQVdrQixRQUZkLENBREY7QUFLRDs7OztFQXJEMEMsZ0JBQU1DLFM7O2tCQUE5QnJCLGU7OztBQXdEckJBLGdCQUFnQnpCLFNBQWhCLEdBQTRCQSxTQUE1QjtBQUNBeUIsZ0JBQWdCRixZQUFoQixHQUErQkEsWUFBL0IiLCJmaWxlIjoib3JiaXQtY29udHJvbGxlci5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwge2NyZWF0ZUVsZW1lbnR9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgT3JiaXRWaWV3cG9ydCBmcm9tICcuL29yYml0LXZpZXdwb3J0JztcbmltcG9ydCBPcmJpdENvbnRyb2xzIGZyb20gJy4vb3JiaXQtY29udHJvbHMnO1xuXG5pbXBvcnQgRXZlbnRNYW5hZ2VyIGZyb20gJy4uLy4uL3V0aWxzL2V2ZW50cy9ldmVudC1tYW5hZ2VyJztcblxuY29uc3QgcHJvcFR5cGVzID0ge1xuICAvKiBWaWV3cG9ydCBwcm9wZXJ0aWVzICovXG4gIGxvb2tBdDogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLm51bWJlciksIC8vIHRhcmdldCBwb3NpdGlvblxuICBkaXN0YW5jZTogUHJvcFR5cGVzLm51bWJlciwgLy8gZGlzdGFuY2UgZnJvbSBjYW1lcmEgdG8gdGhlIHRhcmdldFxuICByb3RhdGlvblg6IFByb3BUeXBlcy5udW1iZXIsIC8vIHJvdGF0aW9uIGFyb3VuZCBYIGF4aXNcbiAgcm90YXRpb25ZOiBQcm9wVHlwZXMubnVtYmVyLCAvLyByb3RhdGlvbiBhcm91bmQgWSBheGlzXG4gIHRyYW5zbGF0aW9uWDogUHJvcFR5cGVzLm51bWJlciwgLy8gdHJhbnNsYXRpb24geCBpbiBzY3JlZW4gc3BhY2VcbiAgdHJhbnNsYXRpb25ZOiBQcm9wVHlwZXMubnVtYmVyLCAvLyB0cmFuc2xhdGlvbiB5IGluIHNjcmVlbiBzcGFjZVxuICB6b29tOiBQcm9wVHlwZXMubnVtYmVyLCAvLyBzY2FsZSBpbiBzY3JlZW4gc3BhY2VcbiAgbWluWm9vbTogUHJvcFR5cGVzLm51bWJlcixcbiAgbWF4Wm9vbTogUHJvcFR5cGVzLm51bWJlcixcbiAgZm92OiBQcm9wVHlwZXMubnVtYmVyLCAvLyBmaWVsZCBvZiB2aWV3XG4gIG5lYXI6IFByb3BUeXBlcy5udW1iZXIsXG4gIGZhcjogUHJvcFR5cGVzLm51bWJlcixcbiAgd2lkdGg6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCwgLy8gdmlld3BvcnQgd2lkdGggaW4gcGl4ZWxzXG4gIGhlaWdodDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLCAvLyB2aWV3cG9ydCBoZWlnaHQgaW4gcGl4ZWxzXG5cbiAgLyogTW9kZWwgcHJvcGVydGllcyAqL1xuICBib3VuZHM6IFByb3BUeXBlcy5vYmplY3QsIC8vIGJvdW5kcyBpbiB0aGUgc2hhcGUgb2Yge21pblgsIG1pblksIG1pblosIG1heFgsIG1heFksIG1heFp9XG5cbiAgLyogQ2FsbGJhY2tzICovXG4gIG9uVmlld3BvcnRDaGFuZ2U6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG5cbiAgLyogQ29udHJvbHMgKi9cbiAgb3JiaXRDb250cm9sczogUHJvcFR5cGVzLm9iamVjdFxufTtcblxuY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICBsb29rQXQ6IFswLCAwLCAwXSxcbiAgcm90YXRpb25YOiAwLFxuICByb3RhdGlvblk6IDAsXG4gIHRyYW5zbGF0aW9uWDogMCxcbiAgdHJhbnNsYXRpb25ZOiAwLFxuICBkaXN0YW5jZTogMTAsXG4gIHpvb206IDEsXG4gIG1pblpvb206IDAsXG4gIG1heFpvb206IEluZmluaXR5LFxuICBmb3Y6IDUwLFxuICBuZWFyOiAxLFxuICBmYXI6IDEwMDBcbn07XG5cbi8qXG4gKiBNYXBzIG1vdXNlIGludGVyYWN0aW9uIHRvIGEgZGVjay5nbCBWaWV3cG9ydFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBPcmJpdENvbnRyb2xsZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXG4gIC8vIFJldHVybnMgYSBkZWNrLmdsIFZpZXdwb3J0IGluc3RhbmNlLCB0byBiZSB1c2VkIHdpdGggdGhlIERlY2tHTCBjb21wb25lbnRcbiAgc3RhdGljIGdldFZpZXdwb3J0KHZpZXdwb3J0KSB7XG4gICAgcmV0dXJuIG5ldyBPcmJpdFZpZXdwb3J0KHZpZXdwb3J0KTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIC8vIFdoZXRoZXIgdGhlIGN1cnNvciBpcyBkb3duXG4gICAgICBpc0RyYWdnaW5nOiBmYWxzZVxuICAgIH07XG5cbiAgICB0aGlzLl9vcmJpdENvbnRyb2xzID0gcHJvcHMub3JiaXRDb250cm9scyB8fCBuZXcgT3JiaXRDb250cm9scygpO1xuICB9XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgY29uc3Qge2V2ZW50Q2FudmFzfSA9IHRoaXMucmVmcztcblxuICAgIGNvbnN0IGV2ZW50TWFuYWdlciA9IG5ldyBFdmVudE1hbmFnZXIoZXZlbnRDYW52YXMpO1xuICAgIHRoaXMuX2V2ZW50TWFuYWdlciA9IGV2ZW50TWFuYWdlcjtcblxuICAgIHRoaXMuX29yYml0Q29udHJvbHMuc2V0T3B0aW9ucyhPYmplY3QuYXNzaWduKHt9LCB0aGlzLnByb3BzLCB7XG4gICAgICBvblN0YXRlQ2hhbmdlOiB0aGlzLl9vbkludGVyYWN0aXZlU3RhdGVDaGFuZ2UuYmluZCh0aGlzKSxcbiAgICAgIGV2ZW50TWFuYWdlclxuICAgIH0pKTtcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVcGRhdGUobmV4dFByb3BzKSB7XG4gICAgdGhpcy5fb3JiaXRDb250cm9scy5zZXRPcHRpb25zKG5leHRQcm9wcyk7XG4gIH1cblxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICBpZiAodGhpcy5fZXZlbnRNYW5hZ2VyKSB7XG4gICAgICAvLyBNdXN0IGRlc3Ryb3kgYmVjYXVzZSBoYW1tZXIgYWRkcyBldmVudCBsaXN0ZW5lcnMgdG8gd2luZG93XG4gICAgICB0aGlzLl9ldmVudE1hbmFnZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgfVxuXG4gIF9vbkludGVyYWN0aXZlU3RhdGVDaGFuZ2Uoe2lzRHJhZ2dpbmcgPSBmYWxzZX0pIHtcbiAgICBpZiAoaXNEcmFnZ2luZyAhPT0gdGhpcy5zdGF0ZS5pc0RyYWdnaW5nKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtpc0RyYWdnaW5nfSk7XG4gICAgfVxuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiAoXG4gICAgICBjcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICAgIHJlZjogJ2V2ZW50Q2FudmFzJ1xuICAgICAgfSwgdGhpcy5wcm9wcy5jaGlsZHJlbilcbiAgICApO1xuICB9XG59XG5cbk9yYml0Q29udHJvbGxlci5wcm9wVHlwZXMgPSBwcm9wVHlwZXM7XG5PcmJpdENvbnRyb2xsZXIuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuIl19