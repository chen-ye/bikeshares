'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Copyright (c) 2015 Uber Technologies, Inc.

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

var _orbitState = require('./orbit-state');

var _orbitState2 = _interopRequireDefault(_orbitState);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// EVENT HANDLING PARAMETERS
var ZOOM_ACCEL = 0.01;

var EVENT_TYPES = {
  WHEEL: ['wheel'],
  PAN: ['panstart', 'panmove', 'panend'],
  PINCH: ['pinchstart', 'pinchmove', 'pinchend'],
  DOUBLE_TAP: ['doubletap']
};

var OrbitControls = function () {
  /**
   * @classdesc
   * A class that handles events and updates mercator style viewport parameters
   */
  function OrbitControls() {
    _classCallCheck(this, OrbitControls);

    this._state = {
      isDragging: false
    };
    this.handleEvent = this.handleEvent.bind(this);
  }

  /**
   * Callback for events
   * @param {hammer.Event} event
   */


  _createClass(OrbitControls, [{
    key: 'handleEvent',
    value: function handleEvent(event) {
      this.orbitState = new _orbitState2.default(Object.assign({}, this.orbitStateProps, this._state));

      switch (event.type) {
        case 'panstart':
          return this._onPanStart(event);
        case 'panmove':
          return this._onPan(event);
        case 'panend':
          return this._onPanEnd(event);
        case 'pinchstart':
          return this._onPinchStart(event);
        case 'pinch':
          return this._onPinch(event);
        case 'pinchend':
          return this._onPinchEnd(event);
        case 'doubletap':
          return this._onDoubleTap(event);
        case 'wheel':
          return this._onWheel(event);
        default:
          return false;
      }
    }

    /* Event utils */
    // Event object: http://hammerjs.github.io/api/#event-object

  }, {
    key: 'getCenter',
    value: function getCenter(event) {
      var _event$offsetCenter = event.offsetCenter,
          x = _event$offsetCenter.x,
          y = _event$offsetCenter.y;

      return [x, y];
    }
  }, {
    key: 'isFunctionKeyPressed',
    value: function isFunctionKeyPressed(event) {
      var srcEvent = event.srcEvent;

      return Boolean(srcEvent.metaKey || srcEvent.altKey || srcEvent.ctrlKey || srcEvent.shiftKey);
    }
  }, {
    key: 'setState',
    value: function setState(newState) {
      Object.assign(this._state, newState);
      if (this.onStateChange) {
        this.onStateChange(this._state);
      }
    }

    /* Callback util */
    // formats map state and invokes callback function

  }, {
    key: 'updateViewport',
    value: function updateViewport(newOrbitState) {
      var extraState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var oldViewport = this.orbitState.getViewportProps();
      var newViewport = newOrbitState.getViewportProps();

      if (this.onViewportChange && Object.keys(newViewport).some(function (key) {
        return oldViewport[key] !== newViewport[key];
      })) {
        // Viewport has changed
        this.onViewportChange(newViewport);
      }

      this.setState(Object.assign({}, newOrbitState.getInteractiveState(), extraState));
    }

    /**
     * Extract interactivity options
     */

  }, {
    key: 'setOptions',
    value: function setOptions(options) {
      var onViewportChange = options.onViewportChange,
          _options$onStateChang = options.onStateChange,
          onStateChange = _options$onStateChang === undefined ? this.onStateChange : _options$onStateChang,
          _options$eventManager = options.eventManager,
          eventManager = _options$eventManager === undefined ? this.eventManager : _options$eventManager,
          _options$scrollZoom = options.scrollZoom,
          scrollZoom = _options$scrollZoom === undefined ? true : _options$scrollZoom,
          _options$dragPan = options.dragPan,
          dragPan = _options$dragPan === undefined ? true : _options$dragPan,
          _options$dragRotate = options.dragRotate,
          dragRotate = _options$dragRotate === undefined ? true : _options$dragRotate,
          _options$doubleClickZ = options.doubleClickZoom,
          doubleClickZoom = _options$doubleClickZ === undefined ? true : _options$doubleClickZ,
          _options$touchZoomRot = options.touchZoomRotate,
          touchZoomRotate = _options$touchZoomRot === undefined ? true : _options$touchZoomRot;

      this.onViewportChange = onViewportChange;
      this.onStateChange = onStateChange;
      this.orbitStateProps = options;
      if (this.eventManager !== eventManager) {
        // EventManager has changed
        this.eventManager = eventManager;
        this._events = {};
      }

      // Register/unregister events
      this.toggleEvents(EVENT_TYPES.WHEEL, scrollZoom);
      this.toggleEvents(EVENT_TYPES.PAN, dragPan || dragRotate);
      this.toggleEvents(EVENT_TYPES.PINCH, touchZoomRotate);
      this.toggleEvents(EVENT_TYPES.DOUBLE_TAP, doubleClickZoom);

      this.scrollZoom = scrollZoom;
      this.dragPan = dragPan;
      this.dragRotate = dragRotate;
      this.doubleClickZoom = doubleClickZoom;
      this.touchZoomRotate = touchZoomRotate;
    }
  }, {
    key: 'toggleEvents',
    value: function toggleEvents(eventNames, enabled) {
      var _this = this;

      if (this.eventManager) {
        eventNames.forEach(function (eventName) {
          if (_this._events[eventName] !== enabled) {
            _this._events[eventName] = enabled;
            if (enabled) {
              _this.eventManager.on(eventName, _this.handleEvent);
            } else {
              _this.eventManager.off(eventName, _this.handleEvent);
            }
          }
        });
      }
    }

    /* Event handlers */
    // Default handler for the `panstart` event.

  }, {
    key: '_onPanStart',
    value: function _onPanStart(event) {
      var pos = this.getCenter(event);
      var newOrbitState = this.orbitState.panStart({ pos: pos }).rotateStart({ pos: pos });
      return this.updateViewport(newOrbitState, { isDragging: true });
    }

    // Default handler for the `panmove` event.

  }, {
    key: '_onPan',
    value: function _onPan(event) {
      return this.isFunctionKeyPressed(event) ? this._onPanMove(event) : this._onPanRotate(event);
    }

    // Default handler for the `panend` event.

  }, {
    key: '_onPanEnd',
    value: function _onPanEnd(event) {
      var newOrbitState = this.orbitState.panEnd().rotateEnd();
      return this.updateViewport(newOrbitState, { isDragging: false });
    }

    // Default handler for panning to move.
    // Called by `_onPan` when panning without function key pressed.

  }, {
    key: '_onPanMove',
    value: function _onPanMove(event) {
      if (!this.dragPan) {
        return false;
      }
      var pos = this.getCenter(event);
      var newOrbitState = this.orbitState.pan({ pos: pos });
      return this.updateViewport(newOrbitState);
    }

    // Default handler for panning to rotate.
    // Called by `_onPan` when panning with function key pressed.

  }, {
    key: '_onPanRotate',
    value: function _onPanRotate(event) {
      if (!this.dragRotate) {
        return false;
      }

      var deltaX = event.deltaX,
          deltaY = event.deltaY;

      var _orbitState$getViewpo = this.orbitState.getViewportProps(),
          width = _orbitState$getViewpo.width,
          height = _orbitState$getViewpo.height;

      var deltaScaleX = deltaX / width;
      var deltaScaleY = deltaY / height;

      var newOrbitState = this.orbitState.rotate({ deltaScaleX: deltaScaleX, deltaScaleY: deltaScaleY });
      return this.updateViewport(newOrbitState);
    }

    // Default handler for the `wheel` event.

  }, {
    key: '_onWheel',
    value: function _onWheel(event) {
      if (!this.scrollZoom) {
        return false;
      }
      event.srcEvent.preventDefault();

      var pos = this.getCenter(event);
      var delta = event.delta;

      // Map wheel delta to relative scale

      var scale = 2 / (1 + Math.exp(-Math.abs(delta * ZOOM_ACCEL)));
      if (delta < 0 && scale !== 0) {
        scale = 1 / scale;
      }

      var newOrbitState = this.orbitState.zoom({ pos: pos, scale: scale });
      return this.updateViewport(newOrbitState);
    }

    // Default handler for the `pinchstart` event.

  }, {
    key: '_onPinchStart',
    value: function _onPinchStart(event) {
      var pos = this.getCenter(event);
      var newOrbitState = this.orbitState.zoomStart({ pos: pos });
      return this.updateViewport(newOrbitState, { isDragging: true });
    }

    // Default handler for the `pinch` event.

  }, {
    key: '_onPinch',
    value: function _onPinch(event) {
      if (!this.touchZoomRotate) {
        return false;
      }
      var pos = this.getCenter(event);
      var scale = event.scale;

      var newOrbitState = this.orbitState.zoom({ pos: pos, scale: scale });
      return this.updateViewport(newOrbitState);
    }

    // Default handler for the `pinchend` event.

  }, {
    key: '_onPinchEnd',
    value: function _onPinchEnd(event) {
      var newOrbitState = this.orbitState.zoomEnd();
      return this.updateViewport(newOrbitState, { isDragging: false });
    }

    // Default handler for the `doubletap` event.

  }, {
    key: '_onDoubleTap',
    value: function _onDoubleTap(event) {
      if (!this.doubleClickZoom) {
        return false;
      }
      var pos = this.getCenter(event);
      var isZoomOut = this.isFunctionKeyPressed(event);

      var newOrbitState = this.orbitState.zoom({ pos: pos, scale: isZoomOut ? 0.5 : 2 });
      return this.updateViewport(newOrbitState);
    }
  }]);

  return OrbitControls;
}();

exports.default = OrbitControls;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb250cm9sbGVycy9vcmJpdC1jb250cm9sbGVyL29yYml0LWNvbnRyb2xzLmpzIl0sIm5hbWVzIjpbIlpPT01fQUNDRUwiLCJFVkVOVF9UWVBFUyIsIldIRUVMIiwiUEFOIiwiUElOQ0giLCJET1VCTEVfVEFQIiwiT3JiaXRDb250cm9scyIsIl9zdGF0ZSIsImlzRHJhZ2dpbmciLCJoYW5kbGVFdmVudCIsImJpbmQiLCJldmVudCIsIm9yYml0U3RhdGUiLCJPYmplY3QiLCJhc3NpZ24iLCJvcmJpdFN0YXRlUHJvcHMiLCJ0eXBlIiwiX29uUGFuU3RhcnQiLCJfb25QYW4iLCJfb25QYW5FbmQiLCJfb25QaW5jaFN0YXJ0IiwiX29uUGluY2giLCJfb25QaW5jaEVuZCIsIl9vbkRvdWJsZVRhcCIsIl9vbldoZWVsIiwib2Zmc2V0Q2VudGVyIiwieCIsInkiLCJzcmNFdmVudCIsIkJvb2xlYW4iLCJtZXRhS2V5IiwiYWx0S2V5IiwiY3RybEtleSIsInNoaWZ0S2V5IiwibmV3U3RhdGUiLCJvblN0YXRlQ2hhbmdlIiwibmV3T3JiaXRTdGF0ZSIsImV4dHJhU3RhdGUiLCJvbGRWaWV3cG9ydCIsImdldFZpZXdwb3J0UHJvcHMiLCJuZXdWaWV3cG9ydCIsIm9uVmlld3BvcnRDaGFuZ2UiLCJrZXlzIiwic29tZSIsImtleSIsInNldFN0YXRlIiwiZ2V0SW50ZXJhY3RpdmVTdGF0ZSIsIm9wdGlvbnMiLCJldmVudE1hbmFnZXIiLCJzY3JvbGxab29tIiwiZHJhZ1BhbiIsImRyYWdSb3RhdGUiLCJkb3VibGVDbGlja1pvb20iLCJ0b3VjaFpvb21Sb3RhdGUiLCJfZXZlbnRzIiwidG9nZ2xlRXZlbnRzIiwiZXZlbnROYW1lcyIsImVuYWJsZWQiLCJmb3JFYWNoIiwiZXZlbnROYW1lIiwib24iLCJvZmYiLCJwb3MiLCJnZXRDZW50ZXIiLCJwYW5TdGFydCIsInJvdGF0ZVN0YXJ0IiwidXBkYXRlVmlld3BvcnQiLCJpc0Z1bmN0aW9uS2V5UHJlc3NlZCIsIl9vblBhbk1vdmUiLCJfb25QYW5Sb3RhdGUiLCJwYW5FbmQiLCJyb3RhdGVFbmQiLCJwYW4iLCJkZWx0YVgiLCJkZWx0YVkiLCJ3aWR0aCIsImhlaWdodCIsImRlbHRhU2NhbGVYIiwiZGVsdGFTY2FsZVkiLCJyb3RhdGUiLCJwcmV2ZW50RGVmYXVsdCIsImRlbHRhIiwic2NhbGUiLCJNYXRoIiwiZXhwIiwiYWJzIiwiem9vbSIsInpvb21TdGFydCIsInpvb21FbmQiLCJpc1pvb21PdXQiXSwibWFwcGluZ3MiOiI7Ozs7OztxakJBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FBRUE7QUFDQSxJQUFNQSxhQUFhLElBQW5COztBQUVBLElBQU1DLGNBQWM7QUFDbEJDLFNBQU8sQ0FBQyxPQUFELENBRFc7QUFFbEJDLE9BQUssQ0FBQyxVQUFELEVBQWEsU0FBYixFQUF3QixRQUF4QixDQUZhO0FBR2xCQyxTQUFPLENBQUMsWUFBRCxFQUFlLFdBQWYsRUFBNEIsVUFBNUIsQ0FIVztBQUlsQkMsY0FBWSxDQUFDLFdBQUQ7QUFKTSxDQUFwQjs7SUFPcUJDLGE7QUFDbkI7Ozs7QUFJQSwyQkFBYztBQUFBOztBQUNaLFNBQUtDLE1BQUwsR0FBYztBQUNaQyxrQkFBWTtBQURBLEtBQWQ7QUFHQSxTQUFLQyxXQUFMLEdBQW1CLEtBQUtBLFdBQUwsQ0FBaUJDLElBQWpCLENBQXNCLElBQXRCLENBQW5CO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O2dDQUlZQyxLLEVBQU87QUFDakIsV0FBS0MsVUFBTCxHQUFrQix5QkFBZUMsT0FBT0MsTUFBUCxDQUFjLEVBQWQsRUFBa0IsS0FBS0MsZUFBdkIsRUFBd0MsS0FBS1IsTUFBN0MsQ0FBZixDQUFsQjs7QUFFQSxjQUFRSSxNQUFNSyxJQUFkO0FBQ0EsYUFBSyxVQUFMO0FBQ0UsaUJBQU8sS0FBS0MsV0FBTCxDQUFpQk4sS0FBakIsQ0FBUDtBQUNGLGFB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WixHQUFrQixDQUEvQixFQUFyQixDQUF0QjtBQUNBLGFBQU8sS0FBS3ZCLGNBQUwsQ0FBb0I5QixhQUFwQixDQUFQO0FBQ0Q7Ozs7OztrQkFwT2tCOUIsYSIsImZpbGUiOiJvcmJpdC1jb250cm9scy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCBPcmJpdFN0YXRlIGZyb20gJy4vb3JiaXQtc3RhdGUnO1xuXG4vLyBFVkVOVCBIQU5ETElORyBQQVJBTUVURVJTXG5jb25zdCBaT09NX0FDQ0VMID0gMC4wMTtcblxuY29uc3QgRVZFTlRfVFlQRVMgPSB7XG4gIFdIRUVMOiBbJ3doZWVsJ10sXG4gIFBBTjogWydwYW5zdGFydCcsICdwYW5tb3ZlJywgJ3BhbmVuZCddLFxuICBQSU5DSDogWydwaW5jaHN0YXJ0JywgJ3BpbmNobW92ZScsICdwaW5jaGVuZCddLFxuICBET1VCTEVfVEFQOiBbJ2RvdWJsZXRhcCddXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBPcmJpdENvbnRyb2xzIHtcbiAgLyoqXG4gICAqIEBjbGFzc2Rlc2NcbiAgICogQSBjbGFzcyB0aGF0IGhhbmRsZXMgZXZlbnRzIGFuZCB1cGRhdGVzIG1lcmNhdG9yIHN0eWxlIHZpZXdwb3J0IHBhcmFtZXRlcnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX3N0YXRlID0ge1xuICAgICAgaXNEcmFnZ2luZzogZmFsc2VcbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlRXZlbnQgPSB0aGlzLmhhbmRsZUV2ZW50LmJpbmQodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGJhY2sgZm9yIGV2ZW50c1xuICAgKiBAcGFyYW0ge2hhbW1lci5FdmVudH0gZXZlbnRcbiAgICovXG4gIGhhbmRsZUV2ZW50KGV2ZW50KSB7XG4gICAgdGhpcy5vcmJpdFN0YXRlID0gbmV3IE9yYml0U3RhdGUoT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcmJpdFN0YXRlUHJvcHMsIHRoaXMuX3N0YXRlKSk7XG5cbiAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICBjYXNlICdwYW5zdGFydCc6XG4gICAgICByZXR1cm4gdGhpcy5fb25QYW5TdGFydChldmVudCk7XG4gICAgY2FzZSAncGFubW92ZSc6XG4gICAgICByZXR1cm4gdGhpcy5fb25QYW4oZXZlbnQpO1xuICAgIGNhc2UgJ3BhbmVuZCc6XG4gICAgICByZXR1cm4gdGhpcy5fb25QYW5FbmQoZXZlbnQpO1xuICAgIGNhc2UgJ3BpbmNoc3RhcnQnOlxuICAgICAgcmV0dXJuIHRoaXMuX29uUGluY2hTdGFydChldmVudCk7XG4gICAgY2FzZSAncGluY2gnOlxuICAgICAgcmV0dXJuIHRoaXMuX29uUGluY2goZXZlbnQpO1xuICAgIGNhc2UgJ3BpbmNoZW5kJzpcbiAgICAgIHJldHVybiB0aGlzLl9vblBpbmNoRW5kKGV2ZW50KTtcbiAgICBjYXNlICdkb3VibGV0YXAnOlxuICAgICAgcmV0dXJuIHRoaXMuX29uRG91YmxlVGFwKGV2ZW50KTtcbiAgICBjYXNlICd3aGVlbCc6XG4gICAgICByZXR1cm4gdGhpcy5fb25XaGVlbChldmVudCk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKiBFdmVudCB1dGlscyAqL1xuICAvLyBFdmVudCBvYmplY3Q6IGh0dHA6Ly9oYW1tZXJqcy5naXRodWIuaW8vYXBpLyNldmVudC1vYmplY3RcbiAgZ2V0Q2VudGVyKGV2ZW50KSB7XG4gICAgY29uc3Qge29mZnNldENlbnRlcjoge3gsIHl9fSA9IGV2ZW50O1xuICAgIHJldHVybiBbeCwgeV07XG4gIH1cblxuICBpc0Z1bmN0aW9uS2V5UHJlc3NlZChldmVudCkge1xuICAgIGNvbnN0IHtzcmNFdmVudH0gPSBldmVudDtcbiAgICByZXR1cm4gQm9vbGVhbihzcmNFdmVudC5tZXRhS2V5IHx8IHNyY0V2ZW50LmFsdEtleSB8fFxuICAgICAgc3JjRXZlbnQuY3RybEtleSB8fCBzcmNFdmVudC5zaGlmdEtleSk7XG4gIH1cblxuICBzZXRTdGF0ZShuZXdTdGF0ZSkge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcy5fc3RhdGUsIG5ld1N0YXRlKTtcbiAgICBpZiAodGhpcy5vblN0YXRlQ2hhbmdlKSB7XG4gICAgICB0aGlzLm9uU3RhdGVDaGFuZ2UodGhpcy5fc3RhdGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qIENhbGxiYWNrIHV0aWwgKi9cbiAgLy8gZm9ybWF0cyBtYXAgc3RhdGUgYW5kIGludm9rZXMgY2FsbGJhY2sgZnVuY3Rpb25cbiAgdXBkYXRlVmlld3BvcnQobmV3T3JiaXRTdGF0ZSwgZXh0cmFTdGF0ZSA9IHt9KSB7XG4gICAgY29uc3Qgb2xkVmlld3BvcnQgPSB0aGlzLm9yYml0U3RhdGUuZ2V0Vmlld3BvcnRQcm9wcygpO1xuICAgIGNvbnN0IG5ld1ZpZXdwb3J0ID0gbmV3T3JiaXRTdGF0ZS5nZXRWaWV3cG9ydFByb3BzKCk7XG5cbiAgICBpZiAodGhpcy5vblZpZXdwb3J0Q2hhbmdlICYmXG4gICAgICBPYmplY3Qua2V5cyhuZXdWaWV3cG9ydCkuc29tZShrZXkgPT4gb2xkVmlld3BvcnRba2V5XSAhPT0gbmV3Vmlld3BvcnRba2V5XSkpIHtcbiAgICAgIC8vIFZpZXdwb3J0IGhhcyBjaGFuZ2VkXG4gICAgICB0aGlzLm9uVmlld3BvcnRDaGFuZ2UobmV3Vmlld3BvcnQpO1xuICAgIH1cblxuICAgIHRoaXMuc2V0U3RhdGUoT2JqZWN0LmFzc2lnbih7fSwgbmV3T3JiaXRTdGF0ZS5nZXRJbnRlcmFjdGl2ZVN0YXRlKCksIGV4dHJhU3RhdGUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRyYWN0IGludGVyYWN0aXZpdHkgb3B0aW9uc1xuICAgKi9cbiAgc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgY29uc3Qge1xuICAgICAgb25WaWV3cG9ydENoYW5nZSxcbiAgICAgIG9uU3RhdGVDaGFuZ2UgPSB0aGlzLm9uU3RhdGVDaGFuZ2UsXG4gICAgICBldmVudE1hbmFnZXIgPSB0aGlzLmV2ZW50TWFuYWdlcixcbiAgICAgIHNjcm9sbFpvb20gPSB0cnVlLFxuICAgICAgZHJhZ1BhbiA9IHRydWUsXG4gICAgICBkcmFnUm90YXRlID0gdHJ1ZSxcbiAgICAgIGRvdWJsZUNsaWNrWm9vbSA9IHRydWUsXG4gICAgICB0b3VjaFpvb21Sb3RhdGUgPSB0cnVlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdGhpcy5vblZpZXdwb3J0Q2hhbmdlID0gb25WaWV3cG9ydENoYW5nZTtcbiAgICB0aGlzLm9uU3RhdGVDaGFuZ2UgPSBvblN0YXRlQ2hhbmdlO1xuICAgIHRoaXMub3JiaXRTdGF0ZVByb3BzID0gb3B0aW9ucztcbiAgICBpZiAodGhpcy5ldmVudE1hbmFnZXIgIT09IGV2ZW50TWFuYWdlcikge1xuICAgICAgLy8gRXZlbnRNYW5hZ2VyIGhhcyBjaGFuZ2VkXG4gICAgICB0aGlzLmV2ZW50TWFuYWdlciA9IGV2ZW50TWFuYWdlcjtcbiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIH1cblxuICAgIC8vIFJlZ2lzdGVyL3VucmVnaXN0ZXIgZXZlbnRzXG4gICAgdGhpcy50b2dnbGVFdmVudHMoRVZFTlRfVFlQRVMuV0hFRUwsIHNjcm9sbFpvb20pO1xuICAgIHRoaXMudG9nZ2xlRXZlbnRzKEVWRU5UX1RZUEVTLlBBTiwgZHJhZ1BhbiB8fCBkcmFnUm90YXRlKTtcbiAgICB0aGlzLnRvZ2dsZUV2ZW50cyhFVkVOVF9UWVBFUy5QSU5DSCwgdG91Y2hab29tUm90YXRlKTtcbiAgICB0aGlzLnRvZ2dsZUV2ZW50cyhFVkVOVF9UWVBFUy5ET1VCTEVfVEFQLCBkb3VibGVDbGlja1pvb20pO1xuXG4gICAgdGhpcy5zY3JvbGxab29tID0gc2Nyb2xsWm9vbTtcbiAgICB0aGlzLmRyYWdQYW4gPSBkcmFnUGFuO1xuICAgIHRoaXMuZHJhZ1JvdGF0ZSA9IGRyYWdSb3RhdGU7XG4gICAgdGhpcy5kb3VibGVDbGlja1pvb20gPSBkb3VibGVDbGlja1pvb207XG4gICAgdGhpcy50b3VjaFpvb21Sb3RhdGUgPSB0b3VjaFpvb21Sb3RhdGU7XG4gIH1cblxuICB0b2dnbGVFdmVudHMoZXZlbnROYW1lcywgZW5hYmxlZCkge1xuICAgIGlmICh0aGlzLmV2ZW50TWFuYWdlcikge1xuICAgICAgZXZlbnROYW1lcy5mb3JFYWNoKGV2ZW50TmFtZSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9ldmVudHNbZXZlbnROYW1lXSAhPT0gZW5hYmxlZCkge1xuICAgICAgICAgIHRoaXMuX2V2ZW50c1tldmVudE5hbWVdID0gZW5hYmxlZDtcbiAgICAgICAgICBpZiAoZW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5ldmVudE1hbmFnZXIub24oZXZlbnROYW1lLCB0aGlzLmhhbmRsZUV2ZW50KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5ldmVudE1hbmFnZXIub2ZmKGV2ZW50TmFtZSwgdGhpcy5oYW5kbGVFdmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKiBFdmVudCBoYW5kbGVycyAqL1xuICAvLyBEZWZhdWx0IGhhbmRsZXIgZm9yIHRoZSBgcGFuc3RhcnRgIGV2ZW50LlxuICBfb25QYW5TdGFydChldmVudCkge1xuICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0Q2VudGVyKGV2ZW50KTtcbiAgICBjb25zdCBuZXdPcmJpdFN0YXRlID0gdGhpcy5vcmJpdFN0YXRlLnBhblN0YXJ0KHtwb3N9KS5yb3RhdGVTdGFydCh7cG9zfSk7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlVmlld3BvcnQobmV3T3JiaXRTdGF0ZSwge2lzRHJhZ2dpbmc6IHRydWV9KTtcbiAgfVxuXG4gIC8vIERlZmF1bHQgaGFuZGxlciBmb3IgdGhlIGBwYW5tb3ZlYCBldmVudC5cbiAgX29uUGFuKGV2ZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNGdW5jdGlvbktleVByZXNzZWQoZXZlbnQpID8gdGhpcy5fb25QYW5Nb3ZlKGV2ZW50KSA6IHRoaXMuX29uUGFuUm90YXRlKGV2ZW50KTtcbiAgfVxuXG4gIC8vIERlZmF1bHQgaGFuZGxlciBmb3IgdGhlIGBwYW5lbmRgIGV2ZW50LlxuICBfb25QYW5FbmQoZXZlbnQpIHtcbiAgICBjb25zdCBuZXdPcmJpdFN0YXRlID0gdGhpcy5vcmJpdFN0YXRlLnBhbkVuZCgpLnJvdGF0ZUVuZCgpO1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZVZpZXdwb3J0KG5ld09yYml0U3RhdGUsIHtpc0RyYWdnaW5nOiBmYWxzZX0pO1xuICB9XG5cbiAgLy8gRGVmYXVsdCBoYW5kbGVyIGZvciBwYW5uaW5nIHRvIG1vdmUuXG4gIC8vIENhbGxlZCBieSBgX29uUGFuYCB3aGVuIHBhbm5pbmcgd2l0aG91dCBmdW5jdGlvbiBrZXkgcHJlc3NlZC5cbiAgX29uUGFuTW92ZShldmVudCkge1xuICAgIGlmICghdGhpcy5kcmFnUGFuKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0Q2VudGVyKGV2ZW50KTtcbiAgICBjb25zdCBuZXdPcmJpdFN0YXRlID0gdGhpcy5vcmJpdFN0YXRlLnBhbih7cG9zfSk7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlVmlld3BvcnQobmV3T3JiaXRTdGF0ZSk7XG4gIH1cblxuICAvLyBEZWZhdWx0IGhhbmRsZXIgZm9yIHBhbm5pbmcgdG8gcm90YXRlLlxuICAvLyBDYWxsZWQgYnkgYF9vblBhbmAgd2hlbiBwYW5uaW5nIHdpdGggZnVuY3Rpb24ga2V5IHByZXNzZWQuXG4gIF9vblBhblJvdGF0ZShldmVudCkge1xuICAgIGlmICghdGhpcy5kcmFnUm90YXRlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3Qge2RlbHRhWCwgZGVsdGFZfSA9IGV2ZW50O1xuICAgIGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IHRoaXMub3JiaXRTdGF0ZS5nZXRWaWV3cG9ydFByb3BzKCk7XG5cbiAgICBjb25zdCBkZWx0YVNjYWxlWCA9IGRlbHRhWCAvIHdpZHRoO1xuICAgIGNvbnN0IGRlbHRhU2NhbGVZID0gZGVsdGFZIC8gaGVpZ2h0O1xuXG4gICAgY29uc3QgbmV3T3JiaXRTdGF0ZSA9IHRoaXMub3JiaXRTdGF0ZS5yb3RhdGUoe2RlbHRhU2NhbGVYLCBkZWx0YVNjYWxlWX0pO1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZVZpZXdwb3J0KG5ld09yYml0U3RhdGUpO1xuICB9XG5cbiAgLy8gRGVmYXVsdCBoYW5kbGVyIGZvciB0aGUgYHdoZWVsYCBldmVudC5cbiAgX29uV2hlZWwoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuc2Nyb2xsWm9vbSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBldmVudC5zcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgY29uc3QgcG9zID0gdGhpcy5nZXRDZW50ZXIoZXZlbnQpO1xuICAgIGNvbnN0IHtkZWx0YX0gPSBldmVudDtcblxuICAgIC8vIE1hcCB3aGVlbCBkZWx0YSB0byByZWxhdGl2ZSBzY2FsZVxuICAgIGxldCBzY2FsZSA9IDIgLyAoMSArIE1hdGguZXhwKC1NYXRoLmFicyhkZWx0YSAqIFpPT01fQUNDRUwpKSk7XG4gICAgaWYgKGRlbHRhIDwgMCAmJiBzY2FsZSAhPT0gMCkge1xuICAgICAgc2NhbGUgPSAxIC8gc2NhbGU7XG4gICAgfVxuXG4gICAgY29uc3QgbmV3T3JiaXRTdGF0ZSA9IHRoaXMub3JiaXRTdGF0ZS56b29tKHtwb3MsIHNjYWxlfSk7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlVmlld3BvcnQobmV3T3JiaXRTdGF0ZSk7XG4gIH1cblxuICAvLyBEZWZhdWx0IGhhbmRsZXIgZm9yIHRoZSBgcGluY2hzdGFydGAgZXZlbnQuXG4gIF9vblBpbmNoU3RhcnQoZXZlbnQpIHtcbiAgICBjb25zdCBwb3MgPSB0aGlzLmdldENlbnRlcihldmVudCk7XG4gICAgY29uc3QgbmV3T3JiaXRTdGF0ZSA9IHRoaXMub3JiaXRTdGF0ZS56b29tU3RhcnQoe3Bvc30pO1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZVZpZXdwb3J0KG5ld09yYml0U3RhdGUsIHtpc0RyYWdnaW5nOiB0cnVlfSk7XG4gIH1cblxuICAvLyBEZWZhdWx0IGhhbmRsZXIgZm9yIHRoZSBgcGluY2hgIGV2ZW50LlxuICBfb25QaW5jaChldmVudCkge1xuICAgIGlmICghdGhpcy50b3VjaFpvb21Sb3RhdGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgcG9zID0gdGhpcy5nZXRDZW50ZXIoZXZlbnQpO1xuICAgIGNvbnN0IHtzY2FsZX0gPSBldmVudDtcbiAgICBjb25zdCBuZXdPcmJpdFN0YXRlID0gdGhpcy5vcmJpdFN0YXRlLnpvb20oe3Bvcywgc2NhbGV9KTtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVWaWV3cG9ydChuZXdPcmJpdFN0YXRlKTtcbiAgfVxuXG4gIC8vIERlZmF1bHQgaGFuZGxlciBmb3IgdGhlIGBwaW5jaGVuZGAgZXZlbnQuXG4gIF9vblBpbmNoRW5kKGV2ZW50KSB7XG4gICAgY29uc3QgbmV3T3JiaXRTdGF0ZSA9IHRoaXMub3JiaXRTdGF0ZS56b29tRW5kKCk7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlVmlld3BvcnQobmV3T3JiaXRTdGF0ZSwge2lzRHJhZ2dpbmc6IGZhbHNlfSk7XG4gIH1cblxuICAvLyBEZWZhdWx0IGhhbmRsZXIgZm9yIHRoZSBgZG91YmxldGFwYCBldmVudC5cbiAgX29uRG91YmxlVGFwKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmRvdWJsZUNsaWNrWm9vbSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBwb3MgPSB0aGlzLmdldENlbnRlcihldmVudCk7XG4gICAgY29uc3QgaXNab29tT3V0ID0gdGhpcy5pc0Z1bmN0aW9uS2V5UHJlc3NlZChldmVudCk7XG5cbiAgICBjb25zdCBuZXdPcmJpdFN0YXRlID0gdGhpcy5vcmJpdFN0YXRlLnpvb20oe3Bvcywgc2NhbGU6IGlzWm9vbU91dCA/IDAuNSA6IDJ9KTtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVWaWV3cG9ydChuZXdPcmJpdFN0YXRlKTtcbiAgfVxufVxuIl19