'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _orbitViewport = require('./orbit-viewport');

var _orbitViewport2 = _interopRequireDefault(_orbitViewport);

var _add = require('gl-vec3/add');

var _add2 = _interopRequireDefault(_add);

var _scale = require('gl-vec3/scale');

var _scale2 = _interopRequireDefault(_scale);

var _lerp = require('gl-vec3/lerp');

var _lerp2 = _interopRequireDefault(_lerp);

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var defaultState = {
  lookAt: [0, 0, 0],
  rotationX: 0,
  rotationY: 0,
  fov: 50,
  near: 1,
  far: 100,
  translationX: 0,
  translationY: 0,
  zoom: 1
};

var defaultConstraints = {
  minZoom: 0,
  maxZoom: Infinity
};

/* Helpers */

// Whether number is between bounds
function inRange(x, min, max) {
  return x >= min && x <= max;
}
// Constrain number between bounds
function clamp(x, min, max) {
  return x < min ? min : x > max ? max : x;
}
// Get ratio of x on domain
function interpolate(x, domain0, domain1) {
  if (domain0 === domain1) {
    return x === domain0 ? 0 : Infinity;
  }
  return (x - domain0) / (domain1 - domain0);
}

function ensureFinite(value, fallbackValue) {
  return Number.isFinite(value) ? value : fallbackValue;
}

var OrbitState = function () {
  function OrbitState(_ref) {
    var width = _ref.width,
        height = _ref.height,
        distance = _ref.distance,
        rotationX = _ref.rotationX,
        rotationY = _ref.rotationY,
        bounds = _ref.bounds,
        lookAt = _ref.lookAt,
        fov = _ref.fov,
        near = _ref.near,
        far = _ref.far,
        translationX = _ref.translationX,
        translationY = _ref.translationY,
        zoom = _ref.zoom,
        minZoom = _ref.minZoom,
        maxZoom = _ref.maxZoom,
        startPanPos = _ref.startPanPos,
        startPanTranslation = _ref.startPanTranslation,
        startRotateCenter = _ref.startRotateCenter,
        startRotateViewport = _ref.startRotateViewport,
        startZoomPos = _ref.startZoomPos,
        startZoom = _ref.startZoom;

    _classCallCheck(this, OrbitState);

    (0, _assert2.default)(Number.isFinite(width), '`width` must be supplied');
    (0, _assert2.default)(Number.isFinite(height), '`height` must be supplied');
    (0, _assert2.default)(Number.isFinite(distance), '`distance` must be supplied');

    this._viewportProps = this._applyConstraints({
      width: width,
      height: height,
      distance: distance,
      rotationX: ensureFinite(rotationX, defaultState.rotationX),
      rotationY: ensureFinite(rotationY, defaultState.rotationY),

      bounds: bounds,
      lookAt: lookAt || defaultState.lookAt,

      fov: ensureFinite(fov, defaultState.fov),
      near: ensureFinite(near, defaultState.near),
      far: ensureFinite(far, defaultState.far),
      translationX: ensureFinite(translationX, defaultState.translationX),
      translationY: ensureFinite(translationY, defaultState.translationY),
      zoom: ensureFinite(zoom, defaultState.zoom),

      minZoom: ensureFinite(minZoom, defaultConstraints.minZoom),
      maxZoom: ensureFinite(maxZoom, defaultConstraints.maxZoom)
    });

    this._interactiveState = {
      startPanPos: startPanPos,
      startPanTranslation: startPanTranslation,
      startRotateCenter: startRotateCenter,
      startRotateViewport: startRotateViewport,
      startZoomPos: startZoomPos,
      startZoom: startZoom
    };
  }

  /* Public API */

  _createClass(OrbitState, [{
    key: 'getViewportProps',
    value: function getViewportProps() {
      return this._viewportProps;
    }
  }, {
    key: 'getInteractiveState',
    value: function getInteractiveState() {
      return this._interactiveState;
    }

    /**
     * Start panning
     * @param {[Number, Number]} pos - position on screen where the pointer grabs
     */

  }, {
    key: 'panStart',
    value: function panStart(_ref2) {
      var pos = _ref2.pos;
      var _viewportProps = this._viewportProps,
          translationX = _viewportProps.translationX,
          translationY = _viewportProps.translationY;


      return this._getUpdatedOrbitState({
        startPanTranslation: [translationX, translationY],
        startPanPos: pos
      });
    }

    /**
     * Pan
     * @param {[Number, Number]} pos - position on screen where the pointer is
     */

  }, {
    key: 'pan',
    value: function pan(_ref3) {
      var pos = _ref3.pos,
          startPos = _ref3.startPos;

      var startPanPos = this._interactiveState.startPanPos || startPos;
      (0, _assert2.default)(startPanPos, '`startPanPos` props is required');

      var _ref4 = this._interactiveState.startPanTranslation || [],
          _ref5 = _slicedToArray(_ref4, 2),
          translationX = _ref5[0],
          translationY = _ref5[1];

      translationX = ensureFinite(translationX, this._viewportProps.translationX);
      translationY = ensureFinite(translationY, this._viewportProps.translationY);

      var deltaX = pos[0] - startPanPos[0];
      var deltaY = pos[1] - startPanPos[1];

      return this._getUpdatedOrbitState({
        translationX: translationX + deltaX,
        translationY: translationY - deltaY
      });
    }

    /**
     * End panning
     * Must call if `panStart()` was called
     */

  }, {
    key: 'panEnd',
    value: function panEnd() {
      return this._getUpdatedOrbitState({
        startPanTranslation: null,
        startPanPos: null
      });
    }

    /**
     * Start rotating
     * @param {[Number, Number]} pos - position on screen where the pointer grabs
     */

  }, {
    key: 'rotateStart',
    value: function rotateStart(_ref6) {
      var pos = _ref6.pos;

      // Rotation center should be the worldspace position at the center of the
      // the screen. If not found, use the last one.
      var startRotateCenter = this._getLocationAtCenter() || this._interactiveState.startRotateCenter;

      return this._getUpdatedOrbitState({
        startRotateCenter: startRotateCenter,
        startRotateViewport: this._viewportProps
      });
    }

    /**
     * Rotate
     * @param {[Number, Number]} pos - position on screen where the pointer is
     */

  }, {
    key: 'rotate',
    value: function rotate(_ref7) {
      var deltaScaleX = _ref7.deltaScaleX,
          deltaScaleY = _ref7.deltaScaleY;
      var _interactiveState = this._interactiveState,
          startRotateCenter = _interactiveState.startRotateCenter,
          startRotateViewport = _interactiveState.startRotateViewport;

      var _ref8 = startRotateViewport || {},
          rotationX = _ref8.rotationX,
          rotationY = _ref8.rotationY,
          translationX = _ref8.translationX,
          translationY = _ref8.translationY;

      rotationX = ensureFinite(rotationX, this._viewportProps.rotationX);
      rotationY = ensureFinite(rotationY, this._viewportProps.rotationY);
      translationX = ensureFinite(translationX, this._viewportProps.translationX);
      translationY = ensureFinite(translationY, this._viewportProps.translationY);

      var newRotationX = clamp(rotationX - deltaScaleY * 180, -89.999, 89.999);
      var newRotationY = (rotationY - deltaScaleX * 180) % 360;

      var newTranslationX = translationX;
      var newTranslationY = translationY;

      if (startRotateCenter) {
        // Keep rotation center at the center of the screen
        var oldViewport = new _orbitViewport2.default(startRotateViewport);
        var oldCenterPos = oldViewport.project(startRotateCenter);

        var newViewport = new _orbitViewport2.default(Object.assign({}, startRotateViewport, {
          rotationX: newRotationX,
          rotationY: newRotationY
        }));
        var newCenterPos = newViewport.project(startRotateCenter);

        newTranslationX += oldCenterPos[0] - newCenterPos[0];
        newTranslationY -= oldCenterPos[1] - newCenterPos[1];
      }

      return this._getUpdatedOrbitState({
        rotationX: newRotationX,
        rotationY: newRotationY,
        translationX: newTranslationX,
        translationY: newTranslationY
      });
    }

    /**
     * End rotating
     * Must call if `rotateStart()` was called
     */

  }, {
    key: 'rotateEnd',
    value: function rotateEnd() {
      return this._getUpdatedOrbitState({
        startRotateCenter: null,
        startRotateViewport: null
      });
    }

    /**
     * Start zooming
     * @param {[Number, Number]} pos - position on screen where the pointer grabs
     */

  }, {
    key: 'zoomStart',
    value: function zoomStart(_ref9) {
      var pos = _ref9.pos;

      return this._getUpdatedOrbitState({
        startZoomPos: pos,
        startZoom: this._viewportProps.zoom
      });
    }

    /**
     * Zoom
     * @param {[Number, Number]} pos - position on screen where the current center is
     * @param {[Number, Number]} startPos - the center position at
     *   the start of the operation. Must be supplied of `zoomStart()` was not called
     * @param {Number} scale - a number between [0, 1] specifying the accumulated
     *   relative scale.
     */

  }, {
    key: 'zoom',
    value: function zoom(_ref10) {
      var pos = _ref10.pos,
          startPos = _ref10.startPos,
          scale = _ref10.scale;
      var _viewportProps2 = this._viewportProps,
          zoom = _viewportProps2.zoom,
          minZoom = _viewportProps2.minZoom,
          maxZoom = _viewportProps2.maxZoom,
          width = _viewportProps2.width,
          height = _viewportProps2.height,
          translationX = _viewportProps2.translationX,
          translationY = _viewportProps2.translationY;


      var startZoomPos = this._interactiveState.startZoomPos || startPos || pos;

      var newZoom = clamp(zoom * scale, minZoom, maxZoom);
      var deltaX = pos[0] - startZoomPos[0];
      var deltaY = pos[1] - startZoomPos[1];

      // Zoom around the center position
      var cx = startZoomPos[0] - width / 2;
      var cy = height / 2 - startZoomPos[1];
      var newTranslationX = cx - (cx - translationX) * newZoom / zoom + deltaX;
      var newTranslationY = cy - (cy - translationY) * newZoom / zoom - deltaY;

      return this._getUpdatedOrbitState({
        zoom: newZoom,
        translationX: newTranslationX,
        translationY: newTranslationY
      });
    }

    /**
     * End zooming
     * Must call if `zoomStart()` was called
     */

  }, {
    key: 'zoomEnd',
    value: function zoomEnd() {
      return this._getUpdatedOrbitState({
        startZoomPos: null,
        startZoom: null
      });
    }

    /* Private methods */

  }, {
    key: '_getUpdatedOrbitState',
    value: function _getUpdatedOrbitState(newProps) {
      // Update _viewportProps
      return new OrbitState(Object.assign({}, this._viewportProps, this._interactiveState, newProps));
    }

    // Apply any constraints (mathematical or defined by _viewportProps) to map state

  }, {
    key: '_applyConstraints',
    value: function _applyConstraints(props) {
      // Ensure zoom is within specified range
      var maxZoom = props.maxZoom,
          minZoom = props.minZoom,
          zoom = props.zoom;

      props.zoom = zoom > maxZoom ? maxZoom : zoom;
      props.zoom = zoom < minZoom ? minZoom : zoom;

      return props;
    }

    /* Cast a ray into the screen center and take the average of all
     * intersections with the bounding box:
     *
     *                         (x=w/2)
     *                          .
     *                          .
     *   (bounding box)         .
     *           _-------------_.
     *          | "-_           :-_
     *         |     "-_        .  "-_
     *        |         "-------+-----:
     *       |.........|........C....|............. (y=h/2)
     *      |         |         .   |
     *     |         |          .  |
     *    |         |           . |
     *   |         |            .|
     *  |         |             |                      Y
     *   "-_     |             |.             Z       |
     *      "-_ |             | .              "-_   |
     *         "-------------"                    "-|_____ X
     */

  }, {
    key: '_getLocationAtCenter',
    value: function _getLocationAtCenter() {
      var _viewportProps3 = this._viewportProps,
          width = _viewportProps3.width,
          height = _viewportProps3.height,
          bounds = _viewportProps3.bounds;


      if (!bounds) {
        return null;
      }

      var viewport = new _orbitViewport2.default(this._viewportProps);

      var C0 = viewport.unproject([width / 2, height / 2, 0]);
      var C1 = viewport.unproject([width / 2, height / 2, 1]);
      var sum = [0, 0, 0];
      var count = 0;

      [
      // depth at intersection with X = minX
      interpolate(bounds.minX, C0[0], C1[0]),
      // depth at intersection with X = maxX
      interpolate(bounds.maxX, C0[0], C1[0]),
      // depth at intersection with Y = minY
      interpolate(bounds.minY, C0[1], C1[1]),
      // depth at intersection with Y = maxY
      interpolate(bounds.maxY, C0[1], C1[1]),
      // depth at intersection with Z = minZ
      interpolate(bounds.minZ, C0[2], C1[2]),
      // depth at intersection with Z = maxZ
      interpolate(bounds.maxZ, C0[2], C1[2])].forEach(function (d) {
        // worldspace position of the intersection
        var C = (0, _lerp2.default)([], C0, C1, d);
        // check if position is on the bounding box
        if (inRange(C[0], bounds.minX, bounds.maxX) && inRange(C[1], bounds.minY, bounds.maxY) && inRange(C[2], bounds.minZ, bounds.maxZ)) {
          count++;
          (0, _add2.default)(sum, sum, C);
        }
      });

      return count > 0 ? (0, _scale2.default)([], sum, 1 / count) : null;
    }
  }]);

  return OrbitState;
}();

exports.default = OrbitState;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb250cm9sbGVycy9vcmJpdC1jb250cm9sbGVyL29yYml0LXN0YXRlLmpzIl0sIm5hbWVzIjpbImRlZmF1bHRTdGF0ZSIsImxvb2tBdCIsInJvdGF0aW9uWCIsInJvdGF0aW9uWSIsImZvdiIsIm5lYXIiLCJmYXIiLCJ0cmFuc2xhdGlvblgiLCJ0cmFuc2xhdGlvblkiLCJ6b29tIiwiZGVmYXVsdENvbnN0cmFpbnRzIiwibWluWm9vbSIsIm1heFpvb20iLCJJbmZpbml0eSIsImluUmFuZ2UiLCJ4IiwibWluIiwibWF4IiwiY2xhbXAiLCJpbnRlcnBvbGF0ZSIsImRvbWFpbjAiLCJkb21haW4xIiwiZW5zdXJlRmluaXRlIiwidmFsdWUiLCJmYWxsYmFja1ZhbHVlIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJPcmJpdFN0YXRlIiwid2lkdGgiLCJoZWlnaHQiLCJkaXN0YW5jZSIsImJvdW5kcyIsInN0YXJ0UGFuUG9zIiwic3RhcnRQYW5UcmFuc2xhdGlvbiIsInN0YXJ0Um90YXRlQ2VudGVyIiwic3RhcnRSb3RhdGVWaWV3cG9ydCIsInN0YXJ0Wm9vbVBvcyIsInN0YXJ0Wm9vbSIsIl92aWV3cG9ydFByb3BzIiwiX2FwcGx5Q29uc3RyYWludHMiLCJfaW50ZXJhY3RpdmVTdGF0ZSIsInBvcyIsIl9nZXRVcGRhdGVkT3JiaXRTdGF0ZSIsInN0YXJ0UG9zIiwiZGVsdGFYIiwiZGVsdGFZIiwiX2dldExvY2F0aW9uQXRDZW50ZXIiLCJkZWx0YVNjYWxlWCIsImRlbHRhU2NhbGVZIiwibmV3Um90YXRpb25YIiwibmV3Um90YXRpb25ZIiwibmV3VHJhbnNsYXRpb25YIiwibmV3VHJhbnNsYXRpb25ZIiwib2xkVmlld3BvcnQiLCJvbGRDZW50ZXJQb3MiLCJwcm9qZWN0IiwibmV3Vmlld3BvcnQiLCJPYmplY3QiLCJhc3NpZ24iLCJuZXdDZW50ZXJQb3MiLCJzY2FsZSIsIm5ld1pvb20iLCJjeCIsImN5IiwibmV3UHJvcHMiLCJwcm9wcyIsInZpZXdwb3J0IiwiQzAiLCJ1bnByb2plY3QiLCJDMSIsInN1bSIsImNvdW50IiwibWluWCIsIm1heFgiLCJtaW5ZIiwibWF4WSIsIm1pbloiLCJtYXhaIiwiZm9yRWFjaCIsIkMiLCJkIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7QUFFQSxJQUFNQSxlQUFlO0FBQ25CQyxVQUFRLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLENBRFc7QUFFbkJDLGFBQVcsQ0FGUTtBQUduQkMsYUFBVyxDQUhRO0FBSW5CQyxPQUFLLEVBSmM7QUFLbkJDLFFBQU0sQ0FMYTtBQU1uQkMsT0FBSyxHQU5jO0FBT25CQyxnQkFBYyxDQVBLO0FBUW5CQyxnQkFBYyxDQVJLO0FBU25CQyxRQUFNO0FBVGEsQ0FBckI7O0FBWUEsSUFBTUMscUJBQXFCO0FBQ3pCQyxXQUFTLENBRGdCO0FBRXpCQyxXQUFTQztBQUZnQixDQUEzQjs7QUFLQTs7QUFFQTtBQUNBLFNBQVNDLE9BQVQsQ0FBaUJDLENBQWpCLEVBQW9CQyxHQUFwQixFQUF5QkMsR0FBekIsRUFBOEI7QUFDNUIsU0FBT0YsS0FBS0MsR0FBTCxJQUFZRCxLQUFLRSxHQUF4QjtBQUNEO0FBQ0Q7QUFDQSxTQUFTQyxLQUFULENBQWVILENBQWYsRUFBa0JDLEdBQWxCLEVBQXVCQyxHQUF2QixFQUE0QjtBQUMxQixTQUFPRixJQUFJQyxHQUFKLEdBQVVBLEdBQVYsR0FBaUJELElBQUlFLEdBQUosR0FBVUEsR0FBVixHQUFnQkYsQ0FBeEM7QUFDRDtBQUNEO0FBQ0EsU0FBU0ksV0FBVCxDQUFxQkosQ0FBckIsRUFBd0JLLE9BQXhCLEVBQWlDQyxPQUFqQyxFQUEwQztBQUN4QyxNQUFJRCxZQUFZQyxPQUFoQixFQUF5QjtBQUN2QixXQUFPTixNQUFNSyxPQUFOLEdBQWdCLENBQWhCLEdBQW9CUCxRQUEzQjtBQUNEO0FBQ0QsU0FBTyxDQUFDRSxJQUFJSyxPQUFMLEtBQWlCQyxVQUFVRCxPQUEzQixD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QUEyQjNDLE9BQU80QyxJQUFsQyxDQURBLElBRUE3RCxRQUFRaUUsRUFBRSxDQUFGLENBQVIsRUFBY2hELE9BQU82QyxJQUFyQixFQUEyQjdDLE9BQU84QyxJQUFsQyxDQUZKLEVBRTZDO0FBQzNDTjtBQUNBLDZCQUFTRCxHQUFULEVBQWNBLEdBQWQsRUFBbUJTLENBQW5CO0FBQ0Q7QUFDRixPQXZCRDs7QUF5QkEsYUFBT1IsUUFBUSxDQUFSLEdBQVkscUJBQVcsRUFBWCxFQUFlRCxHQUFmLEVBQW9CLElBQUlDLEtBQXhCLENBQVosR0FBNkMsSUFBcEQ7QUFDRDs7Ozs7O2tCQTFVa0I1QyxVIiwiZmlsZSI6Im9yYml0LXN0YXRlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IE9yYml0Vmlld3BvcnQgZnJvbSAnLi9vcmJpdC12aWV3cG9ydCc7XG5pbXBvcnQgdmVjM19hZGQgZnJvbSAnZ2wtdmVjMy9hZGQnO1xuaW1wb3J0IHZlYzNfc2NhbGUgZnJvbSAnZ2wtdmVjMy9zY2FsZSc7XG5pbXBvcnQgdmVjM19sZXJwIGZyb20gJ2dsLXZlYzMvbGVycCc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5cbmNvbnN0IGRlZmF1bHRTdGF0ZSA9IHtcbiAgbG9va0F0OiBbMCwgMCwgMF0sXG4gIHJvdGF0aW9uWDogMCxcbiAgcm90YXRpb25ZOiAwLFxuICBmb3Y6IDUwLFxuICBuZWFyOiAxLFxuICBmYXI6IDEwMCxcbiAgdHJhbnNsYXRpb25YOiAwLFxuICB0cmFuc2xhdGlvblk6IDAsXG4gIHpvb206IDFcbn07XG5cbmNvbnN0IGRlZmF1bHRDb25zdHJhaW50cyA9IHtcbiAgbWluWm9vbTogMCxcbiAgbWF4Wm9vbTogSW5maW5pdHlcbn07XG5cbi8qIEhlbHBlcnMgKi9cblxuLy8gV2hldGhlciBudW1iZXIgaXMgYmV0d2VlbiBib3VuZHNcbmZ1bmN0aW9uIGluUmFuZ2UoeCwgbWluLCBtYXgpIHtcbiAgcmV0dXJuIHggPj0gbWluICYmIHggPD0gbWF4O1xufVxuLy8gQ29uc3RyYWluIG51bWJlciBiZXR3ZWVuIGJvdW5kc1xuZnVuY3Rpb24gY2xhbXAoeCwgbWluLCBtYXgpIHtcbiAgcmV0dXJuIHggPCBtaW4gPyBtaW4gOiAoeCA+IG1heCA/IG1heCA6IHgpO1xufVxuLy8gR2V0IHJhdGlvIG9mIHggb24gZG9tYWluXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZSh4LCBkb21haW4wLCBkb21haW4xKSB7XG4gIGlmIChkb21haW4wID09PSBkb21haW4xKSB7XG4gICAgcmV0dXJuIHggPT09IGRvbWFpbjAgPyAwIDogSW5maW5pdHk7XG4gIH1cbiAgcmV0dXJuICh4IC0gZG9tYWluMCkgLyAoZG9tYWluMSAtIGRvbWFpbjApO1xufVxuXG5mdW5jdGlvbiBlbnN1cmVGaW5pdGUodmFsdWUsIGZhbGxiYWNrVmFsdWUpIHtcbiAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZSh2YWx1ZSkgPyB2YWx1ZSA6IGZhbGxiYWNrVmFsdWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE9yYml0U3RhdGUge1xuXG4gIGNvbnN0cnVjdG9yKHtcbiAgICAvKiBWaWV3cG9ydCBhcmd1bWVudHMgKi9cbiAgICB3aWR0aCwgLy8gV2lkdGggb2Ygdmlld3BvcnRcbiAgICBoZWlnaHQsIC8vIEhlaWdodCBvZiB2aWV3cG9ydFxuICAgIGRpc3RhbmNlLCAvLyBGcm9tIGV5ZSB0byB0YXJnZXRcbiAgICByb3RhdGlvblgsIC8vIFJvdGF0aW9uIGFyb3VuZCB4IGF4aXNcbiAgICByb3RhdGlvblksIC8vIFJvdGF0aW9uIGFyb3VuZCB5IGF4aXNcblxuICAgIC8vIEJvdW5kaW5nIGJveCBvZiB0aGUgbW9kZWwsIGluIHRoZSBzaGFwZSBvZiB7bWluWCwgbWF4WCwgbWluWSwgbWF4WSwgbWluWiwgbWF4Wn1cbiAgICBib3VuZHMsXG5cbiAgICAvKiBWaWV3IG1hdHJpeCBhcmd1bWVudHMgKi9cbiAgICBsb29rQXQsIC8vIFdoaWNoIHBvaW50IGlzIGNhbWVyYSBsb29raW5nIGF0LCBkZWZhdWx0IG9yaWdpblxuXG4gICAgLyogUHJvamVjdGlvbiBtYXRyaXggYXJndW1lbnRzICovXG4gICAgZm92LCAvLyBGaWVsZCBvZiB2aWV3IGNvdmVyZWQgYnkgY2FtZXJhXG4gICAgbmVhciwgLy8gRGlzdGFuY2Ugb2YgbmVhciBjbGlwcGluZyBwbGFuZVxuICAgIGZhciwgLy8gRGlzdGFuY2Ugb2YgZmFyIGNsaXBwaW5nIHBsYW5lXG5cbiAgICAvKiBBZnRlciBwcm9qZWN0aW9uICovXG4gICAgdHJhbnNsYXRpb25YLCAvLyBpbiBwaXhlbHNcbiAgICB0cmFuc2xhdGlvblksIC8vIGluIHBpeGVsc1xuICAgIHpvb20sXG5cbiAgICAvKiBWaWV3cG9ydCBjb25zdHJhaW50cyAqL1xuICAgIG1pblpvb20sXG4gICAgbWF4Wm9vbSxcblxuICAgIC8qKiBJbnRlcmFjdGlvbiBzdGF0ZXMsIHJlcXVpcmVkIHRvIGNhbGN1bGF0ZSBjaGFuZ2UgZHVyaW5nIHRyYW5zZm9ybSAqL1xuICAgIC8vIE1vZGVsIHN0YXRlIHdoZW4gdGhlIHBhbiBvcGVyYXRpb24gZmlyc3Qgc3RhcnRlZFxuICAgIHN0YXJ0UGFuUG9zLFxuICAgIHN0YXJ0UGFuVHJhbnNsYXRpb24sXG4gICAgLy8gTW9kZWwgc3RhdGUgd2hlbiB0aGUgcm90YXRlIG9wZXJhdGlvbiBmaXJzdCBzdGFydGVkXG4gICAgc3RhcnRSb3RhdGVDZW50ZXIsXG4gICAgc3RhcnRSb3RhdGVWaWV3cG9ydCxcbiAgICAvLyBNb2RlbCBzdGF0ZSB3aGVuIHRoZSB6b29tIG9wZXJhdGlvbiBmaXJzdCBzdGFydGVkXG4gICAgc3RhcnRab29tUG9zLFxuICAgIHN0YXJ0Wm9vbVxuICB9KSB7XG4gICAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZSh3aWR0aCksICdgd2lkdGhgIG11c3QgYmUgc3VwcGxpZWQnKTtcbiAgICBhc3NlcnQoTnVtYmVyLmlzRmluaXRlKGhlaWdodCksICdgaGVpZ2h0YCBtdXN0IGJlIHN1cHBsaWVkJyk7XG4gICAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZShkaXN0YW5jZSksICdgZGlzdGFuY2VgIG11c3QgYmUgc3VwcGxpZWQnKTtcblxuICAgIHRoaXMuX3ZpZXdwb3J0UHJvcHMgPSB0aGlzLl9hcHBseUNvbnN0cmFpbnRzKHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgZGlzdGFuY2UsXG4gICAgICByb3RhdGlvblg6IGVuc3VyZUZpbml0ZShyb3RhdGlvblgsIGRlZmF1bHRTdGF0ZS5yb3RhdGlvblgpLFxuICAgICAgcm90YXRpb25ZOiBlbnN1cmVGaW5pdGUocm90YXRpb25ZLCBkZWZhdWx0U3RhdGUucm90YXRpb25ZKSxcblxuICAgICAgYm91bmRzLFxuICAgICAgbG9va0F0OiBsb29rQXQgfHwgZGVmYXVsdFN0YXRlLmxvb2tBdCxcblxuICAgICAgZm92OiBlbnN1cmVGaW5pdGUoZm92LCBkZWZhdWx0U3RhdGUuZm92KSxcbiAgICAgIG5lYXI6IGVuc3VyZUZpbml0ZShuZWFyLCBkZWZhdWx0U3RhdGUubmVhciksXG4gICAgICBmYXI6IGVuc3VyZUZpbml0ZShmYXIsIGRlZmF1bHRTdGF0ZS5mYXIpLFxuICAgICAgdHJhbnNsYXRpb25YOiBlbnN1cmVGaW5pdGUodHJhbnNsYXRpb25YLCBkZWZhdWx0U3RhdGUudHJhbnNsYXRpb25YKSxcbiAgICAgIHRyYW5zbGF0aW9uWTogZW5zdXJlRmluaXRlKHRyYW5zbGF0aW9uWSwgZGVmYXVsdFN0YXRlLnRyYW5zbGF0aW9uWSksXG4gICAgICB6b29tOiBlbnN1cmVGaW5pdGUoem9vbSwgZGVmYXVsdFN0YXRlLnpvb20pLFxuXG4gICAgICBtaW5ab29tOiBlbnN1cmVGaW5pdGUobWluWm9vbSwgZGVmYXVsdENvbnN0cmFpbnRzLm1pblpvb20pLFxuICAgICAgbWF4Wm9vbTogZW5zdXJlRmluaXRlKG1heFpvb20sIGRlZmF1bHRDb25zdHJhaW50cy5tYXhab29tKVxuICAgIH0pO1xuXG4gICAgdGhpcy5faW50ZXJhY3RpdmVTdGF0ZSA9IHtcbiAgICAgIHN0YXJ0UGFuUG9zLFxuICAgICAgc3RhcnRQYW5UcmFuc2xhdGlvbixcbiAgICAgIHN0YXJ0Um90YXRlQ2VudGVyLFxuICAgICAgc3RhcnRSb3RhdGVWaWV3cG9ydCxcbiAgICAgIHN0YXJ0Wm9vbVBvcyxcbiAgICAgIHN0YXJ0Wm9vbVxuICAgIH07XG4gIH1cblxuICAvKiBQdWJsaWMgQVBJICovXG5cbiAgZ2V0Vmlld3BvcnRQcm9wcygpIHtcbiAgICByZXR1cm4gdGhpcy5fdmlld3BvcnRQcm9wcztcbiAgfVxuXG4gIGdldEludGVyYWN0aXZlU3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ludGVyYWN0aXZlU3RhdGU7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgcGFubmluZ1xuICAgKiBAcGFyYW0ge1tOdW1iZXIsIE51bWJlcl19IHBvcyAtIHBvc2l0aW9uIG9uIHNjcmVlbiB3aGVyZSB0aGUgcG9pbnRlciBncmFic1xuICAgKi9cbiAgcGFuU3RhcnQoe3Bvc30pIHtcbiAgICBjb25zdCB7dHJhbnNsYXRpb25YLCB0cmFuc2xhdGlvbll9ID0gdGhpcy5fdmlld3BvcnRQcm9wcztcblxuICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkT3JiaXRTdGF0ZSh7XG4gICAgICBzdGFydFBhblRyYW5zbGF0aW9uOiBbdHJhbnNsYXRpb25YLCB0cmFuc2xhdGlvblldLFxuICAgICAgc3RhcnRQYW5Qb3M6IHBvc1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhblxuICAgKiBAcGFyYW0ge1tOdW1iZXIsIE51bWJlcl19IHBvcyAtIHBvc2l0aW9uIG9uIHNjcmVlbiB3aGVyZSB0aGUgcG9pbnRlciBpc1xuICAgKi9cbiAgcGFuKHtwb3MsIHN0YXJ0UG9zfSkge1xuICAgIGNvbnN0IHN0YXJ0UGFuUG9zID0gdGhpcy5faW50ZXJhY3RpdmVTdGF0ZS5zdGFydFBhblBvcyB8fCBzdGFydFBvcztcbiAgICBhc3NlcnQoc3RhcnRQYW5Qb3MsICdgc3RhcnRQYW5Qb3NgIHByb3BzIGlzIHJlcXVpcmVkJyk7XG5cbiAgICBsZXQgW3RyYW5zbGF0aW9uWCwgdHJhbnNsYXRpb25ZXSA9IHRoaXMuX2ludGVyYWN0aXZlU3RhdGUuc3RhcnRQYW5UcmFuc2xhdGlvbiB8fCBbXTtcbiAgICB0cmFuc2xhdGlvblggPSBlbnN1cmVGaW5pdGUodHJhbnNsYXRpb25YLCB0aGlzLl92aWV3cG9ydFByb3BzLnRyYW5zbGF0aW9uWCk7XG4gICAgdHJhbnNsYXRpb25ZID0gZW5zdXJlRmluaXRlKHRyYW5zbGF0aW9uWSwgdGhpcy5fdmlld3BvcnRQcm9wcy50cmFuc2xhdGlvblkpO1xuXG4gICAgY29uc3QgZGVsdGFYID0gcG9zWzBdIC0gc3RhcnRQYW5Qb3NbMF07XG4gICAgY29uc3QgZGVsdGFZID0gcG9zWzFdIC0gc3RhcnRQYW5Qb3NbMV07XG5cbiAgICByZXR1cm4gdGhpcy5fZ2V0VXBkYXRlZE9yYml0U3RhdGUoe1xuICAgICAgdHJhbnNsYXRpb25YOiB0cmFuc2xhdGlvblggKyBkZWx0YVgsXG4gICAgICB0cmFuc2xhdGlvblk6IHRyYW5zbGF0aW9uWSAtIGRlbHRhWVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuZCBwYW5uaW5nXG4gICAqIE11c3QgY2FsbCBpZiBgcGFuU3RhcnQoKWAgd2FzIGNhbGxlZFxuICAgKi9cbiAgcGFuRW5kKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkT3JiaXRTdGF0ZSh7XG4gICAgICBzdGFydFBhblRyYW5zbGF0aW9uOiBudWxsLFxuICAgICAgc3RhcnRQYW5Qb3M6IG51bGxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCByb3RhdGluZ1xuICAgKiBAcGFyYW0ge1tOdW1iZXIsIE51bWJlcl19IHBvcyAtIHBvc2l0aW9uIG9uIHNjcmVlbiB3aGVyZSB0aGUgcG9pbnRlciBncmFic1xuICAgKi9cbiAgcm90YXRlU3RhcnQoe3Bvc30pIHtcbiAgICAvLyBSb3RhdGlvbiBjZW50ZXIgc2hvdWxkIGJlIHRoZSB3b3JsZHNwYWNlIHBvc2l0aW9uIGF0IHRoZSBjZW50ZXIgb2YgdGhlXG4gICAgLy8gdGhlIHNjcmVlbi4gSWYgbm90IGZvdW5kLCB1c2UgdGhlIGxhc3Qgb25lLlxuICAgIGNvbnN0IHN0YXJ0Um90YXRlQ2VudGVyID0gdGhpcy5fZ2V0TG9jYXRpb25BdENlbnRlcigpIHx8XG4gICAgICB0aGlzLl9pbnRlcmFjdGl2ZVN0YXRlLnN0YXJ0Um90YXRlQ2VudGVyO1xuXG4gICAgcmV0dXJuIHRoaXMuX2dldFVwZGF0ZWRPcmJpdFN0YXRlKHtcbiAgICAgIHN0YXJ0Um90YXRlQ2VudGVyLFxuICAgICAgc3RhcnRSb3RhdGVWaWV3cG9ydDogdGhpcy5fdmlld3BvcnRQcm9wc1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJvdGF0ZVxuICAgKiBAcGFyYW0ge1tOdW1iZXIsIE51bWJlcl19IHBvcyAtIHBvc2l0aW9uIG9uIHNjcmVlbiB3aGVyZSB0aGUgcG9pbnRlciBpc1xuICAgKi9cbiAgcm90YXRlKHtkZWx0YVNjYWxlWCwgZGVsdGFTY2FsZVl9KSB7XG4gICAgY29uc3Qge3N0YXJ0Um90YXRlQ2VudGVyLCBzdGFydFJvdGF0ZVZpZXdwb3J0fSA9IHRoaXMuX2ludGVyYWN0aXZlU3RhdGU7XG5cbiAgICBsZXQge3JvdGF0aW9uWCwgcm90YXRpb25ZLCB0cmFuc2xhdGlvblgsIHRyYW5zbGF0aW9uWX0gPSBzdGFydFJvdGF0ZVZpZXdwb3J0IHx8IHt9O1xuICAgIHJvdGF0aW9uWCA9IGVuc3VyZUZpbml0ZShyb3RhdGlvblgsIHRoaXMuX3ZpZXdwb3J0UHJvcHMucm90YXRpb25YKTtcbiAgICByb3RhdGlvblkgPSBlbnN1cmVGaW5pdGUocm90YXRpb25ZLCB0aGlzLl92aWV3cG9ydFByb3BzLnJvdGF0aW9uWSk7XG4gICAgdHJhbnNsYXRpb25YID0gZW5zdXJlRmluaXRlKHRyYW5zbGF0aW9uWCwgdGhpcy5fdmlld3BvcnRQcm9wcy50cmFuc2xhdGlvblgpO1xuICAgIHRyYW5zbGF0aW9uWSA9IGVuc3VyZUZpbml0ZSh0cmFuc2xhdGlvblksIHRoaXMuX3ZpZXdwb3J0UHJvcHMudHJhbnNsYXRpb25ZKTtcblxuICAgIGNvbnN0IG5ld1JvdGF0aW9uWCA9IGNsYW1wKHJvdGF0aW9uWCAtIGRlbHRhU2NhbGVZICogMTgwLCAtODkuOTk5LCA4OS45OTkpO1xuICAgIGNvbnN0IG5ld1JvdGF0aW9uWSA9IChyb3RhdGlvblkgLSBkZWx0YVNjYWxlWCAqIDE4MCkgJSAzNjA7XG5cbiAgICBsZXQgbmV3VHJhbnNsYXRpb25YID0gdHJhbnNsYXRpb25YO1xuICAgIGxldCBuZXdUcmFuc2xhdGlvblkgPSB0cmFuc2xhdGlvblk7XG5cbiAgICBpZiAoc3RhcnRSb3RhdGVDZW50ZXIpIHtcbiAgICAgIC8vIEtlZXAgcm90YXRpb24gY2VudGVyIGF0IHRoZSBjZW50ZXIgb2YgdGhlIHNjcmVlblxuICAgICAgY29uc3Qgb2xkVmlld3BvcnQgPSBuZXcgT3JiaXRWaWV3cG9ydChzdGFydFJvdGF0ZVZpZXdwb3J0KTtcbiAgICAgIGNvbnN0IG9sZENlbnRlclBvcyA9IG9sZFZpZXdwb3J0LnByb2plY3Qoc3RhcnRSb3RhdGVDZW50ZXIpO1xuXG4gICAgICBjb25zdCBuZXdWaWV3cG9ydCA9IG5ldyBPcmJpdFZpZXdwb3J0KE9iamVjdC5hc3NpZ24oe30sIHN0YXJ0Um90YXRlVmlld3BvcnQsIHtcbiAgICAgICAgcm90YXRpb25YOiBuZXdSb3RhdGlvblgsXG4gICAgICAgIHJvdGF0aW9uWTogbmV3Um90YXRpb25ZXG4gICAgICB9KSk7XG4gICAgICBjb25zdCBuZXdDZW50ZXJQb3MgPSBuZXdWaWV3cG9ydC5wcm9qZWN0KHN0YXJ0Um90YXRlQ2VudGVyKTtcblxuICAgICAgbmV3VHJhbnNsYXRpb25YICs9IG9sZENlbnRlclBvc1swXSAtIG5ld0NlbnRlclBvc1swXTtcbiAgICAgIG5ld1RyYW5zbGF0aW9uWSAtPSBvbGRDZW50ZXJQb3NbMV0gLSBuZXdDZW50ZXJQb3NbMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2dldFVwZGF0ZWRPcmJpdFN0YXRlKHtcbiAgICAgIHJvdGF0aW9uWDogbmV3Um90YXRpb25YLFxuICAgICAgcm90YXRpb25ZOiBuZXdSb3RhdGlvblksXG4gICAgICB0cmFuc2xhdGlvblg6IG5ld1RyYW5zbGF0aW9uWCxcbiAgICAgIHRyYW5zbGF0aW9uWTogbmV3VHJhbnNsYXRpb25ZXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRW5kIHJvdGF0aW5nXG4gICAqIE11c3QgY2FsbCBpZiBgcm90YXRlU3RhcnQoKWAgd2FzIGNhbGxlZFxuICAgKi9cbiAgcm90YXRlRW5kKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkT3JiaXRTdGF0ZSh7XG4gICAgICBzdGFydFJvdGF0ZUNlbnRlcjogbnVsbCxcbiAgICAgIHN0YXJ0Um90YXRlVmlld3BvcnQ6IG51bGxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCB6b29taW5nXG4gICAqIEBwYXJhbSB7W051bWJlciwgTnVtYmVyXX0gcG9zIC0gcG9zaXRpb24gb24gc2NyZWVuIHdoZXJlIHRoZSBwb2ludGVyIGdyYWJzXG4gICAqL1xuICB6b29tU3RhcnQoe3Bvc30pIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0VXBkYXRlZE9yYml0U3RhdGUoe1xuICAgICAgc3RhcnRab29tUG9zOiBwb3MsXG4gICAgICBzdGFydFpvb206IHRoaXMuX3ZpZXdwb3J0UHJvcHMuem9vbVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFpvb21cbiAgICogQHBhcmFtIHtbTnVtYmVyLCBOdW1iZXJdfSBwb3MgLSBwb3NpdGlvbiBvbiBzY3JlZW4gd2hlcmUgdGhlIGN1cnJlbnQgY2VudGVyIGlzXG4gICAqIEBwYXJhbSB7W051bWJlciwgTnVtYmVyXX0gc3RhcnRQb3MgLSB0aGUgY2VudGVyIHBvc2l0aW9uIGF0XG4gICAqICAgdGhlIHN0YXJ0IG9mIHRoZSBvcGVyYXRpb24uIE11c3QgYmUgc3VwcGxpZWQgb2YgYHpvb21TdGFydCgpYCB3YXMgbm90IGNhbGxlZFxuICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgLSBhIG51bWJlciBiZXR3ZWVuIFswLCAxXSBzcGVjaWZ5aW5nIHRoZSBhY2N1bXVsYXRlZFxuICAgKiAgIHJlbGF0aXZlIHNjYWxlLlxuICAgKi9cbiAgem9vbSh7cG9zLCBzdGFydFBvcywgc2NhbGV9KSB7XG4gICAgY29uc3Qge3pvb20sIG1pblpvb20sIG1heFpvb20sIHdpZHRoLCBoZWlnaHQsIHRyYW5zbGF0aW9uWCwgdHJhbnNsYXRpb25ZfSA9IHRoaXMuX3ZpZXdwb3J0UHJvcHM7XG5cbiAgICBjb25zdCBzdGFydFpvb21Qb3MgPSB0aGlzLl9pbnRlcmFjdGl2ZVN0YXRlLnN0YXJ0Wm9vbVBvcyB8fCBzdGFydFBvcyB8fCBwb3M7XG5cbiAgICBjb25zdCBuZXdab29tID0gY2xhbXAoem9vbSAqIHNjYWxlLCBtaW5ab29tLCBtYXhab29tKTtcbiAgICBjb25zdCBkZWx0YVggPSBwb3NbMF0gLSBzdGFydFpvb21Qb3NbMF07XG4gICAgY29uc3QgZGVsdGFZID0gcG9zWzFdIC0gc3RhcnRab29tUG9zWzFdO1xuXG4gICAgLy8gWm9vbSBhcm91bmQgdGhlIGNlbnRlciBwb3NpdGlvblxuICAgIGNvbnN0IGN4ID0gc3RhcnRab29tUG9zWzBdIC0gd2lkdGggLyAyO1xuICAgIGNvbnN0IGN5ID0gaGVpZ2h0IC8gMiAtIHN0YXJ0Wm9vbVBvc1sxXTtcbiAgICBjb25zdCBuZXdUcmFuc2xhdGlvblggPSBjeCAtIChjeCAtIHRyYW5zbGF0aW9uWCkgKiBuZXdab29tIC8gem9vbSArIGRlbHRhWDtcbiAgICBjb25zdCBuZXdUcmFuc2xhdGlvblkgPSBjeSAtIChjeSAtIHRyYW5zbGF0aW9uWSkgKiBuZXdab29tIC8gem9vbSAtIGRlbHRhWTtcblxuICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkT3JiaXRTdGF0ZSh7XG4gICAgICB6b29tOiBuZXdab29tLFxuICAgICAgdHJhbnNsYXRpb25YOiBuZXdUcmFuc2xhdGlvblgsXG4gICAgICB0cmFuc2xhdGlvblk6IG5ld1RyYW5zbGF0aW9uWVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuZCB6b29taW5nXG4gICAqIE11c3QgY2FsbCBpZiBgem9vbVN0YXJ0KClgIHdhcyBjYWxsZWRcbiAgICovXG4gIHpvb21FbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFVwZGF0ZWRPcmJpdFN0YXRlKHtcbiAgICAgIHN0YXJ0Wm9vbVBvczogbnVsbCxcbiAgICAgIHN0YXJ0Wm9vbTogbnVsbFxuICAgIH0pO1xuICB9XG5cbiAgLyogUHJpdmF0ZSBtZXRob2RzICovXG5cbiAgX2dldFVwZGF0ZWRPcmJpdFN0YXRlKG5ld1Byb3BzKSB7XG4gICAgLy8gVXBkYXRlIF92aWV3cG9ydFByb3BzXG4gICAgcmV0dXJuIG5ldyBPcmJpdFN0YXRlKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX3ZpZXdwb3J0UHJvcHMsIHRoaXMuX2ludGVyYWN0aXZlU3RhdGUsIG5ld1Byb3BzKSk7XG4gIH1cblxuICAvLyBBcHBseSBhbnkgY29uc3RyYWludHMgKG1hdGhlbWF0aWNhbCBvciBkZWZpbmVkIGJ5IF92aWV3cG9ydFByb3BzKSB0byBtYXAgc3RhdGVcbiAgX2FwcGx5Q29uc3RyYWludHMocHJvcHMpIHtcbiAgICAvLyBFbnN1cmUgem9vbSBpcyB3aXRoaW4gc3BlY2lmaWVkIHJhbmdlXG4gICAgY29uc3Qge21heFpvb20sIG1pblpvb20sIHpvb219ID0gcHJvcHM7XG4gICAgcHJvcHMuem9vbSA9IHpvb20gPiBtYXhab29tID8gbWF4Wm9vbSA6IHpvb207XG4gICAgcHJvcHMuem9vbSA9IHpvb20gPCBtaW5ab29tID8gbWluWm9vbSA6IHpvb207XG5cbiAgICByZXR1cm4gcHJvcHM7XG4gIH1cblxuICAvKiBDYXN0IGEgcmF5IGludG8gdGhlIHNjcmVlbiBjZW50ZXIgYW5kIHRha2UgdGhlIGF2ZXJhZ2Ugb2YgYWxsXG4gICAqIGludGVyc2VjdGlvbnMgd2l0aCB0aGUgYm91bmRpbmcgYm94OlxuICAgKlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAoeD13LzIpXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAuXG4gICAqICAgKGJvdW5kaW5nIGJveCkgICAgICAgICAuXG4gICAqICAgICAgICAgICBfLS0tLS0tLS0tLS0tLV8uXG4gICAqICAgICAgICAgIHwgXCItXyAgICAgICAgICAgOi1fXG4gICAqICAgICAgICAgfCAgICAgXCItXyAgICAgICAgLiAgXCItX1xuICAgKiAgICAgICAgfCAgICAgICAgIFwiLS0tLS0tLSstLS0tLTpcbiAgICogICAgICAgfC4uLi4uLi4uLnwuLi4uLi4uLkMuLi4ufC4uLi4uLi4uLi4uLi4gKHk9aC8yKVxuICAgKiAgICAgIHwgICAgICAgICB8ICAgICAgICAgLiAgIHxcbiAgICogICAgIHwgICAgICAgICB8ICAgICAgICAgIC4gIHxcbiAgICogICAgfCAgICAgICAgIHwgICAgICAgICAgIC4gfFxuICAgKiAgIHwgICAgICAgICB8ICAgICAgICAgICAgLnxcbiAgICogIHwgICAgICAgICB8ICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgWVxuICAgKiAgIFwiLV8gICAgIHwgICAgICAgICAgICAgfC4gICAgICAgICAgICAgWiAgICAgICB8XG4gICAqICAgICAgXCItXyB8ICAgICAgICAgICAgIHwgLiAgICAgICAgICAgICAgXCItXyAgIHxcbiAgICogICAgICAgICBcIi0tLS0tLS0tLS0tLS1cIiAgICAgICAgICAgICAgICAgICAgXCItfF9fX19fIFhcbiAgICovXG4gIF9nZXRMb2NhdGlvbkF0Q2VudGVyKCkge1xuICAgIGNvbnN0IHt3aWR0aCwgaGVpZ2h0LCBib3VuZHN9ID0gdGhpcy5fdmlld3BvcnRQcm9wcztcblxuICAgIGlmICghYm91bmRzKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCB2aWV3cG9ydCA9IG5ldyBPcmJpdFZpZXdwb3J0KHRoaXMuX3ZpZXdwb3J0UHJvcHMpO1xuXG4gICAgY29uc3QgQzAgPSB2aWV3cG9ydC51bnByb2plY3QoW3dpZHRoIC8gMiwgaGVpZ2h0IC8gMiwgMF0pO1xuICAgIGNvbnN0IEMxID0gdmlld3BvcnQudW5wcm9qZWN0KFt3aWR0aCAvIDIsIGhlaWdodCAvIDIsIDFdKTtcbiAgICBjb25zdCBzdW0gPSBbMCwgMCwgMF07XG4gICAgbGV0IGNvdW50ID0gMDtcblxuICAgIFtcbiAgICAgIC8vIGRlcHRoIGF0IGludGVyc2VjdGlvbiB3aXRoIFggPSBtaW5YXG4gICAgICBpbnRlcnBvbGF0ZShib3VuZHMubWluWCwgQzBbMF0sIEMxWzBdKSxcbiAgICAgIC8vIGRlcHRoIGF0IGludGVyc2VjdGlvbiB3aXRoIFggPSBtYXhYXG4gICAgICBpbnRlcnBvbGF0ZShib3VuZHMubWF4WCwgQzBbMF0sIEMxWzBdKSxcbiAgICAgIC8vIGRlcHRoIGF0IGludGVyc2VjdGlvbiB3aXRoIFkgPSBtaW5ZXG4gICAgICBpbnRlcnBvbGF0ZShib3VuZHMubWluWSwgQzBbMV0sIEMxWzFdKSxcbiAgICAgIC8vIGRlcHRoIGF0IGludGVyc2VjdGlvbiB3aXRoIFkgPSBtYXhZXG4gICAgICBpbnRlcnBvbGF0ZShib3VuZHMubWF4WSwgQzBbMV0sIEMxWzFdKSxcbiAgICAgIC8vIGRlcHRoIGF0IGludGVyc2VjdGlvbiB3aXRoIFogPSBtaW5aXG4gICAgICBpbnRlcnBvbGF0ZShib3VuZHMubWluWiwgQzBbMl0sIEMxWzJdKSxcbiAgICAgIC8vIGRlcHRoIGF0IGludGVyc2VjdGlvbiB3aXRoIFogPSBtYXhaXG4gICAgICBpbnRlcnBvbGF0ZShib3VuZHMubWF4WiwgQzBbMl0sIEMxWzJdKVxuICAgIF0uZm9yRWFjaChkID0+IHtcbiAgICAgIC8vIHdvcmxkc3BhY2UgcG9zaXRpb24gb2YgdGhlIGludGVyc2VjdGlvblxuICAgICAgY29uc3QgQyA9IHZlYzNfbGVycChbXSwgQzAsIEMxLCBkKTtcbiAgICAgIC8vIGNoZWNrIGlmIHBvc2l0aW9uIGlzIG9uIHRoZSBib3VuZGluZyBib3hcbiAgICAgIGlmIChpblJhbmdlKENbMF0sIGJvdW5kcy5taW5YLCBib3VuZHMubWF4WCkgJiZcbiAgICAgICAgICBpblJhbmdlKENbMV0sIGJvdW5kcy5taW5ZLCBib3VuZHMubWF4WSkgJiZcbiAgICAgICAgICBpblJhbmdlKENbMl0sIGJvdW5kcy5taW5aLCBib3VuZHMubWF4WikpIHtcbiAgICAgICAgY291bnQrKztcbiAgICAgICAgdmVjM19hZGQoc3VtLCBzdW0sIEMpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNvdW50ID4gMCA/IHZlYzNfc2NhbGUoW10sIHN1bSwgMSAvIGNvdW50KSA6IG51bGw7XG4gIH1cbn1cbiJdfQ==