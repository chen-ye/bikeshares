'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fitBounds = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _deck = require('deck.gl');

var _add = require('gl-vec2/add');

var _add2 = _interopRequireDefault(_add);

var _negate = require('gl-vec2/negate');

var _negate2 = _interopRequireDefault(_negate);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // View and Projection Matrix calculations for mapbox-js style map view properties


/* eslint-disable camelcase */


var PerspectiveMercatorViewport = function (_WebMercatorViewport) {
  _inherits(PerspectiveMercatorViewport, _WebMercatorViewport);

  function PerspectiveMercatorViewport() {
    _classCallCheck(this, PerspectiveMercatorViewport);

    return _possibleConstructorReturn(this, (PerspectiveMercatorViewport.__proto__ || Object.getPrototypeOf(PerspectiveMercatorViewport)).apply(this, arguments));
  }

  _createClass(PerspectiveMercatorViewport, [{
    key: 'getLocationAtPoint',

    /**
     * Get the map center that place a given [lng, lat] coordinate at screen
     * point [x, y]
     *
     * @param {Array} lngLat - [lng,lat] coordinates
     *   Specifies a point on the sphere.
     * @param {Array} pos - [x,y] coordinates
     *   Specifies a point on the screen.
     * @return {Array} [lng,lat] new map center.
     */
    value: function getLocationAtPoint(_ref) {
      var lngLat = _ref.lngLat,
          pos = _ref.pos;

      var fromLocation = this.projectFlat(this.unproject(pos));
      var toLocation = this.projectFlat(lngLat);

      var center = this.projectFlat([this.longitude, this.latitude]);

      var translate = (0, _add2.default)([], toLocation, (0, _negate2.default)([], fromLocation));
      var newCenter = (0, _add2.default)([], center, translate);
      return this.unprojectFlat(newCenter);
    }

    /**
     * Returns a new viewport that fit around the given rectangle.
     * Only supports non-perspective mode.
     * @param {Array} bounds - [[lon, lat], [lon, lat]]
     * @param {Number} [options.padding] - The amount of padding in pixels to add to the given bounds.
     * @param {Array} [options.offset] - The center of the given bounds relative to the map's center,
     *    [x, y] measured in pixels.
     * @returns {WebMercatorViewport}
     */

  }, {
    key: 'fitBounds',
    value: function fitBounds(bounds) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var width = this.width,
          height = this.height;

      var _fitBounds2 = _fitBounds(Object.assign({ width: width, height: height, bounds: bounds }, options)),
          longitude = _fitBounds2.longitude,
          latitude = _fitBounds2.latitude,
          zoom = _fitBounds2.zoom;

      return new PerspectiveMercatorViewport({ width: width, height: height, longitude: longitude, latitude: latitude, zoom: zoom });
    }
  }]);

  return PerspectiveMercatorViewport;
}(_deck.WebMercatorViewport);

/**
 * Returns map settings {latitude, longitude, zoom}
 * that will contain the provided corners within the provided width.
 * Only supports non-perspective mode.
 * @param {Number} width - viewport width
 * @param {Number} height - viewport height
 * @param {Array} bounds - [[lon, lat], [lon, lat]]
 * @param {Number} [padding] - The amount of padding in pixels to add to the given bounds.
 * @param {Array} [offset] - The center of the given bounds relative to the map's center,
 *    [x, y] measured in pixels.
 * @returns {Object} - latitude, longitude and zoom
 */


exports.default = PerspectiveMercatorViewport;
function _fitBounds(_ref2) {
  var width = _ref2.width,
      height = _ref2.height,
      bounds = _ref2.bounds,
      _ref2$padding = _ref2.padding,
      padding = _ref2$padding === undefined ? 0 : _ref2$padding,
      _ref2$offset = _ref2.offset,
      offset = _ref2$offset === undefined ? [0, 0] : _ref2$offset;

  var _bounds = _slicedToArray(bounds, 2),
      _bounds$ = _slicedToArray(_bounds[0], 2),
      west = _bounds$[0],
      south = _bounds$[1],
      _bounds$2 = _slicedToArray(_bounds[1], 2),
      east = _bounds$2[0],
      north = _bounds$2[1];

  var viewport = new _deck.WebMercatorViewport({
    width: width,
    height: height,
    longitude: 0,
    latitude: 0,
    zoom: 0
  });

  var nw = viewport.project([west, north]);
  var se = viewport.project([east, south]);
  var size = [Math.abs(se[0] - nw[0]), Math.abs(se[1] - nw[1])];
  var center = [(se[0] + nw[0]) / 2, (se[1] + nw[1]) / 2];

  var scaleX = (width - padding * 2 - Math.abs(offset[0]) * 2) / size[0];
  var scaleY = (height - padding * 2 - Math.abs(offset[1]) * 2) / size[1];

  var centerLngLat = viewport.unproject(center);
  var zoom = viewport.zoom + Math.log2(Math.abs(Math.min(scaleX, scaleY)));

  return {
    longitude: centerLngLat[0],
    latitude: centerLngLat[1],
    zoom: zoom
  };
}
exports.fitBounds = _fitBounds;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb250cm9sbGVycy9tYXAtY29udHJvbGxlci9wZXJzcGVjdGl2ZS1tZXJjYXRvci12aWV3cG9ydC5qcyJdLCJuYW1lcyI6WyJQZXJzcGVjdGl2ZU1lcmNhdG9yVmlld3BvcnQiLCJsbmdMYXQiLCJwb3MiLCJmcm9tTG9jYXRpb24iLCJwcm9qZWN0RmxhdCIsInVucHJvamVjdCIsInRvTG9jYXRpb24iLCJjZW50ZXIiLCJsb25naXR1ZGUiLCJsYXRpdHVkZSIsInRyYW5zbGF0ZSIsIm5ld0NlbnRlciIsInVucHJvamVjdEZsYXQiLCJib3VuZHMiLCJvcHRpb25zIiwid2lkdGgiLCJoZWlnaHQiLCJmaXRCb3VuZHMiLCJPYmplY3QiLCJhc3NpZ24iLCJ6b29tIiwicGFkZGluZyIsIm9mZnNldCIsIndlc3QiLCJzb3V0aCIsImVhc3QiLCJub3J0aCIsInZpZXdwb3J0IiwibnciLCJwcm9qZWN0Iiwic2UiLCJzaXplIiwiTWF0aCIsImFicyIsInNjYWxlWCIsInNjYWxlWSIsImNlbnRlckxuZ0xhdCIsImxvZzIiLCJtaW4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQ0E7O0FBR0E7Ozs7QUFDQTs7Ozs7Ozs7OzsrZUFMQTs7O0FBR0E7OztJQUlxQkEsMkI7Ozs7Ozs7Ozs7OztBQUNuQjs7Ozs7Ozs7Ozs2Q0FVa0M7QUFBQSxVQUFkQyxNQUFjLFFBQWRBLE1BQWM7QUFBQSxVQUFOQyxHQUFNLFFBQU5BLEdBQU07O0FBQ2hDLFVBQU1DLGVBQWUsS0FBS0MsV0FBTCxDQUFpQixLQUFLQyxTQUFMLENBQWVILEdBQWYsQ0FBakIsQ0FBckI7QUFDQSxVQUFNSSxhQUFhLEtBQUtGLFdBQUwsQ0FBaUJILE1BQWpCLENBQW5COztBQUVBLFVBQU1NLFNBQVMsS0FBS0gsV0FBTCxDQUFpQixDQUFDLEtBQUtJLFNBQU4sRUFBaUIsS0FBS0MsUUFBdEIsQ0FBakIsQ0FBZjs7QUFFQSxVQUFNQyxZQUFZLG1CQUFTLEVBQVQsRUFBYUosVUFBYixFQUF5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Q0FBU0osTUFBVCxFQUFpQkMsTUFBakIsQ0FBVCxDQUFWLENBQTdCOztBQUVBLFNBQU87QUFDTDNCLGVBQVc0QixhQUFhLENBQWIsQ0FETjtBQUVMM0IsY0FBVTJCLGFBQWEsQ0FBYixDQUZMO0FBR0xoQjtBQUhLLEdBQVA7QUFLRCIsImZpbGUiOiJwZXJzcGVjdGl2ZS1tZXJjYXRvci12aWV3cG9ydC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIFZpZXcgYW5kIFByb2plY3Rpb24gTWF0cml4IGNhbGN1bGF0aW9ucyBmb3IgbWFwYm94LWpzIHN0eWxlIG1hcCB2aWV3IHByb3BlcnRpZXNcbmltcG9ydCB7V2ViTWVyY2F0b3JWaWV3cG9ydH0gZnJvbSAnZGVjay5nbCc7XG5cbi8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqL1xuaW1wb3J0IHZlYzJfYWRkIGZyb20gJ2dsLXZlYzIvYWRkJztcbmltcG9ydCB2ZWMyX25lZ2F0ZSBmcm9tICdnbC12ZWMyL25lZ2F0ZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBlcnNwZWN0aXZlTWVyY2F0b3JWaWV3cG9ydCBleHRlbmRzIFdlYk1lcmNhdG9yVmlld3BvcnQge1xuICAvKipcbiAgICogR2V0IHRoZSBtYXAgY2VudGVyIHRoYXQgcGxhY2UgYSBnaXZlbiBbbG5nLCBsYXRdIGNvb3JkaW5hdGUgYXQgc2NyZWVuXG4gICAqIHBvaW50IFt4LCB5XVxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBsbmdMYXQgLSBbbG5nLGxhdF0gY29vcmRpbmF0ZXNcbiAgICogICBTcGVjaWZpZXMgYSBwb2ludCBvbiB0aGUgc3BoZXJlLlxuICAgKiBAcGFyYW0ge0FycmF5fSBwb3MgLSBbeCx5XSBjb29yZGluYXRlc1xuICAgKiAgIFNwZWNpZmllcyBhIHBvaW50IG9uIHRoZSBzY3JlZW4uXG4gICAqIEByZXR1cm4ge0FycmF5fSBbbG5nLGxhdF0gbmV3IG1hcCBjZW50ZXIuXG4gICAqL1xuICBnZXRMb2NhdGlvbkF0UG9pbnQoe2xuZ0xhdCwgcG9zfSkge1xuICAgIGNvbnN0IGZyb21Mb2NhdGlvbiA9IHRoaXMucHJvamVjdEZsYXQodGhpcy51bnByb2plY3QocG9zKSk7XG4gICAgY29uc3QgdG9Mb2NhdGlvbiA9IHRoaXMucHJvamVjdEZsYXQobG5nTGF0KTtcblxuICAgIGNvbnN0IGNlbnRlciA9IHRoaXMucHJvamVjdEZsYXQoW3RoaXMubG9uZ2l0dWRlLCB0aGlzLmxhdGl0dWRlXSk7XG5cbiAgICBjb25zdCB0cmFuc2xhdGUgPSB2ZWMyX2FkZChbXSwgdG9Mb2NhdGlvbiwgdmVjMl9uZWdhdGUoW10sIGZyb21Mb2NhdGlvbikpO1xuICAgIGNvbnN0IG5ld0NlbnRlciA9IHZlYzJfYWRkKFtdLCBjZW50ZXIsIHRyYW5zbGF0ZSk7XG4gICAgcmV0dXJuIHRoaXMudW5wcm9qZWN0RmxhdChuZXdDZW50ZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgdmlld3BvcnQgdGhhdCBmaXQgYXJvdW5kIHRoZSBnaXZlbiByZWN0YW5nbGUuXG4gICAqIE9ubHkgc3VwcG9ydHMgbm9uLXBlcnNwZWN0aXZlIG1vZGUuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGJvdW5kcyAtIFtbbG9uLCBsYXRdLCBbbG9uLCBsYXRdXVxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucGFkZGluZ10gLSBUaGUgYW1vdW50IG9mIHBhZGRpbmcgaW4gcGl4ZWxzIHRvIGFkZCB0byB0aGUgZ2l2ZW4gYm91bmRzLlxuICAgKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5vZmZzZXRdIC0gVGhlIGNlbnRlciBvZiB0aGUgZ2l2ZW4gYm91bmRzIHJlbGF0aXZlIHRvIHRoZSBtYXAncyBjZW50ZXIsXG4gICAqICAgIFt4LCB5XSBtZWFzdXJlZCBpbiBwaXhlbHMuXG4gICAqIEByZXR1cm5zIHtXZWJNZXJjYXRvclZpZXdwb3J0fVxuICAgKi9cbiAgZml0Qm91bmRzKGJvdW5kcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gdGhpcztcbiAgICBjb25zdCB7bG9uZ2l0dWRlLCBsYXRpdHVkZSwgem9vbX0gPSBmaXRCb3VuZHMoT2JqZWN0LmFzc2lnbih7d2lkdGgsIGhlaWdodCwgYm91bmRzfSwgb3B0aW9ucykpO1xuICAgIHJldHVybiBuZXcgUGVyc3BlY3RpdmVNZXJjYXRvclZpZXdwb3J0KHt3aWR0aCwgaGVpZ2h0LCBsb25naXR1ZGUsIGxhdGl0dWRlLCB6b29tfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIG1hcCBzZXR0aW5ncyB7bGF0aXR1ZGUsIGxvbmdpdHVkZSwgem9vbX1cbiAqIHRoYXQgd2lsbCBjb250YWluIHRoZSBwcm92aWRlZCBjb3JuZXJzIHdpdGhpbiB0aGUgcHJvdmlkZWQgd2lkdGguXG4gKiBPbmx5IHN1cHBvcnRzIG5vbi1wZXJzcGVjdGl2ZSBtb2RlLlxuICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gdmlld3BvcnQgd2lkdGhcbiAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSB2aWV3cG9ydCBoZWlnaHRcbiAqIEBwYXJhbSB7QXJyYXl9IGJvdW5kcyAtIFtbbG9uLCBsYXRdLCBbbG9uLCBsYXRdXVxuICogQHBhcmFtIHtOdW1iZXJ9IFtwYWRkaW5nXSAtIFRoZSBhbW91bnQgb2YgcGFkZGluZyBpbiBwaXhlbHMgdG8gYWRkIHRvIHRoZSBnaXZlbiBib3VuZHMuXG4gKiBAcGFyYW0ge0FycmF5fSBbb2Zmc2V0XSAtIFRoZSBjZW50ZXIgb2YgdGhlIGdpdmVuIGJvdW5kcyByZWxhdGl2ZSB0byB0aGUgbWFwJ3MgY2VudGVyLFxuICogICAgW3gsIHldIG1lYXN1cmVkIGluIHBpeGVscy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IC0gbGF0aXR1ZGUsIGxvbmdpdHVkZSBhbmQgem9vbVxuICovXG5leHBvcnQgZnVuY3Rpb24gZml0Qm91bmRzKHtcbiAgd2lkdGgsXG4gIGhlaWdodCxcbiAgYm91bmRzLFxuICAvLyBvcHRpb25zXG4gIHBhZGRpbmcgPSAwLFxuICBvZmZzZXQgPSBbMCwgMF1cbn0pIHtcbiAgY29uc3QgW1t3ZXN0LCBzb3V0aF0sIFtlYXN0LCBub3J0aF1dID0gYm91bmRzO1xuXG4gIGNvbnN0IHZpZXdwb3J0ID0gbmV3IFdlYk1lcmNhdG9yVmlld3BvcnQoe1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBsb25naXR1ZGU6IDAsXG4gICAgbGF0aXR1ZGU6IDAsXG4gICAgem9vbTogMFxuICB9KTtcblxuICBjb25zdCBudyA9IHZpZXdwb3J0LnByb2plY3QoW3dlc3QsIG5vcnRoXSk7XG4gIGNvbnN0IHNlID0gdmlld3BvcnQucHJvamVjdChbZWFzdCwgc291dGhdKTtcbiAgY29uc3Qgc2l6ZSA9IFtcbiAgICBNYXRoLmFicyhzZVswXSAtIG53WzBdKSxcbiAgICBNYXRoLmFicyhzZVsxXSAtIG53WzFdKVxuICBdO1xuICBjb25zdCBjZW50ZXIgPSBbXG4gICAgKHNlWzBdICsgbndbMF0pIC8gMixcbiAgICAoc2VbMV0gKyBud1sxXSkgLyAyXG4gIF07XG5cbiAgY29uc3Qgc2NhbGVYID0gKHdpZHRoIC0gcGFkZGluZyAqIDIgLSBNYXRoLmFicyhvZmZzZXRbMF0pICogMikgLyBzaXplWzBdO1xuICBjb25zdCBzY2FsZVkgPSAoaGVpZ2h0IC0gcGFkZGluZyAqIDIgLSBNYXRoLmFicyhvZmZzZXRbMV0pICogMikgLyBzaXplWzFdO1xuXG4gIGNvbnN0IGNlbnRlckxuZ0xhdCA9IHZpZXdwb3J0LnVucHJvamVjdChjZW50ZXIpO1xuICBjb25zdCB6b29tID0gdmlld3BvcnQuem9vbSArIE1hdGgubG9nMihNYXRoLmFicyhNYXRoLm1pbihzY2FsZVgsIHNjYWxlWSkpKTtcblxuICByZXR1cm4ge1xuICAgIGxvbmdpdHVkZTogY2VudGVyTG5nTGF0WzBdLFxuICAgIGxhdGl0dWRlOiBjZW50ZXJMbmdMYXRbMV0sXG4gICAgem9vbVxuICB9O1xufVxuIl19