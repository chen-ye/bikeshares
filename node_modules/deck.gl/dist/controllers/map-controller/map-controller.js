'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _mapState = require('./map-state');

var _eventManager = require('../../utils/events/event-manager');

var _eventManager2 = _interopRequireDefault(_eventManager);

var _mapControls = require('./map-controls');

var _mapControls2 = _interopRequireDefault(_mapControls);

var _config = require('../config');

var _config2 = _interopRequireDefault(_config);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var propTypes = {
  /** The width of the map. */
  width: _propTypes2.default.number.isRequired,
  /** The height of the map. */
  height: _propTypes2.default.number.isRequired,
  /** The longitude of the center of the map. */
  longitude: _propTypes2.default.number.isRequired,
  /** The latitude of the center of the map. */
  latitude: _propTypes2.default.number.isRequired,
  /** The tile zoom level of the map. */
  zoom: _propTypes2.default.number.isRequired,
  /** Specify the bearing of the viewport */
  bearing: _propTypes2.default.number,
  /** Specify the pitch of the viewport */
  pitch: _propTypes2.default.number,
  /** Altitude of the viewport camera. Default 1.5 "screen heights" */
  // Note: Non-public API, see https://github.com/mapbox/mapbox-gl-js/issues/1137
  altitude: _propTypes2.default.number,

  /** Viewport constraints */
  // Max zoom level
  maxZoom: _propTypes2.default.number,
  // Min zoom level
  minZoom: _propTypes2.default.number,
  // Max pitch in degrees
  maxPitch: _propTypes2.default.number,
  // Min pitch in degrees
  minPitch: _propTypes2.default.number,

  /**
   * `onViewportChange` callback is fired when the user interacted with the
   * map. The object passed to the callback contains viewport properties
   * such as `longitude`, `latitude`, `zoom` etc.
   */
  onViewportChange: _propTypes2.default.func,

  /** Enables control event handling */
  // Scroll to zoom
  scrollZoom: _propTypes2.default.bool,
  // Drag to pan
  dragPan: _propTypes2.default.bool,
  // Drag to rotate
  dragRotate: _propTypes2.default.bool,
  // Double click to zoom
  doubleClickZoom: _propTypes2.default.bool,
  // Pinch to zoom / rotate
  touchZoomRotate: _propTypes2.default.bool,

  /** Accessor that returns a cursor style to show interactive state */
  getCursor: _propTypes2.default.func,

  // A map control instance to replace the default map controls
  // The object must expose one property: `events` as an array of subscribed
  // event names; and two methods: `setState(state)` and `handle(event)`
  mapControls: _propTypes2.default.shape({
    events: _propTypes2.default.arrayOf(_propTypes2.default.string),
    handleEvent: _propTypes2.default.func
  })
};

var getDefaultCursor = function getDefaultCursor(_ref) {
  var isDragging = _ref.isDragging;
  return isDragging ? _config2.default.CURSOR.GRABBING : _config2.default.CURSOR.GRAB;
};

var defaultProps = Object.assign({}, _mapState.MAPBOX_LIMITS, {
  onViewportChange: null,

  scrollZoom: true,
  dragPan: true,
  dragRotate: true,
  doubleClickZoom: true,
  touchZoomRotate: true,

  getCursor: getDefaultCursor
});

var MapController = function (_PureComponent) {
  _inherits(MapController, _PureComponent);

  function MapController(props) {
    _classCallCheck(this, MapController);

    var _this = _possibleConstructorReturn(this, (MapController.__proto__ || Object.getPrototypeOf(MapController)).call(this, props));

    _this.state = {
      // Whether the cursor is down
      isDragging: false
    };

    // If props.mapControls is not provided, fallback to default MapControls instance
    // Cannot use defaultProps here because it needs to be per map instance
    _this._mapControls = props.mapControls || new _mapControls2.default();
    return _this;
  }

  _createClass(MapController, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var eventCanvas = this.refs.eventCanvas;


      var eventManager = new _eventManager2.default(eventCanvas);

      this._eventManager = eventManager;

      this._mapControls.setOptions(Object.assign({}, this.props, {
        onStateChange: this._onInteractiveStateChange.bind(this),
        eventManager: eventManager
      }));
    }
  }, {
    key: 'componentWillUpdate',
    value: function componentWillUpdate(nextProps) {
      this._mapControls.setOptions(nextProps);
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      if (this._eventManager) {
        // Must destroy because hammer adds event listeners to window
        this._eventManager.destroy();
      }
    }
  }, {
    key: '_onInteractiveStateChange',
    value: function _onInteractiveStateChange(_ref2) {
      var _ref2$isDragging = _ref2.isDragging,
          isDragging = _ref2$isDragging === undefined ? false : _ref2$isDragging;

      if (isDragging !== this.state.isDragging) {
        this.setState({ isDragging: isDragging });
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _props = this.props,
          width = _props.width,
          height = _props.height,
          getCursor = _props.getCursor;


      var eventCanvasStyle = {
        width: width,
        height: height,
        position: 'relative',
        cursor: getCursor(this.state)
      };

      return (0, _react.createElement)('div', {
        key: 'map-controls',
        ref: 'eventCanvas',
        style: eventCanvasStyle
      }, this.props.children);
    }
  }]);

  return MapController;
}(_react.PureComponent);

exports.default = MapController;


MapController.displayName = 'MapController';
MapController.propTypes = propTypes;
MapController.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb250cm9sbGVycy9tYXAtY29udHJvbGxlci9tYXAtY29udHJvbGxlci5qcyJdLCJuYW1lcyI6WyJwcm9wVHlwZXMiLCJ3aWR0aCIsIm51bWJlciIsImlzUmVxdWlyZWQiLCJoZWlnaHQiLCJsb25naXR1ZGUiLCJsYXRpdHVkZSIsInpvb20iLCJiZWFyaW5nIiwicGl0Y2giLCJhbHRpdHVkZSIsIm1heFpvb20iLCJtaW5ab29tIiwibWF4UGl0Y2giLCJtaW5QaXRjaCIsIm9uVmlld3BvcnRDaGFuZ2UiLCJmdW5jIiwic2Nyb2xsWm9vbSIsImJvb2wiLCJkcmFnUGFuIiwiZHJhZ1JvdGF0ZSIsImRvdWJsZUNsaWNrWm9vbSIsInRvdWNoWm9vbVJvdGF0ZSIsImdldEN1cnNvciIsIm1hcENvbnRyb2xzIiwic2hhcGUiLCJldmVudHMiLCJhcnJheU9mIiwic3RyaW5nIiwiaGFuZGxlRXZlbnQiLCJnZXREZWZhdWx0Q3Vyc29yIiwiaXNEcmFnZ2luZyIsIkNVUlNPUiIsIkdSQUJCSU5HIiwiR1JBQiIsImRlZmF1bHRQcm9wcyIsIk9iamVjdCIsImFzc2lnbiIsIk1hcENvbnRyb2xsZXIiLCJwcm9wcyIsInN0YXRlIiwiX21hcENvbnRyb2xzIiwiZXZlbnRDYW52YXMiLCJyZWZzIiwiZXZlbnRNYW5hZ2VyIiwiX2V2ZW50TWFuYWdlciIsInNldE9wdGlvbnMiLCJvblN0YXRlQ2hhbmdlIiwiX29uSW50ZXJhY3RpdmVTdGF0ZUNoYW5nZSIsImJpbmQiLCJuZXh0UHJvcHMiLCJkZXN0cm95Iiwic2V0U3RhdGUiLCJldmVudENhbnZhc1N0eWxlIiwicG9zaXRpb24iLCJjdXJzb3IiLCJrZXkiLCJyZWYiLCJzdHlsZSIsImNoaWxkcmVuIiwiZGlzcGxheU5hbWUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7O0FBQ0E7Ozs7QUFFQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7OztBQUVBLElBQU1BLFlBQVk7QUFDaEI7QUFDQUMs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QVE7O0FBQzlDLFVBQUlBLGVBQWUsS0FBS1MsS0FBTCxDQUFXVCxVQUE5QixFQUEwQztBQUN4QyxhQUFLcUIsUUFBTCxDQUFjLEVBQUNyQixzQkFBRCxFQUFkO0FBQ0Q7QUFDRjs7OzZCQUVRO0FBQUEsbUJBQzRCLEtBQUtRLEtBRGpDO0FBQUEsVUFDQXRDLEtBREEsVUFDQUEsS0FEQTtBQUFBLFVBQ09HLE1BRFAsVUFDT0EsTUFEUDtBQUFBLFVBQ2VtQixTQURmLFVBQ2VBLFNBRGY7OztBQUdQLFVBQU04QixtQkFBbUI7QUFDdkJwRCxvQkFEdUI7QUFFdkJHLHNCQUZ1QjtBQUd2QmtELGtCQUFVLFVBSGE7QUFJdkJDLGdCQUFRaEMsVUFBVSxLQUFLaUIsS0FBZjtBQUplLE9BQXpCOztBQU9BLGFBQ0UsMEJBQWMsS0FBZCxFQUFxQjtBQUNuQmdCLGFBQUssY0FEYztBQUVuQkMsYUFBSyxhQUZjO0FBR25CQyxlQUFPTDtBQUhZLE9BQXJCLEVBS0UsS0FBS2QsS0FBTCxDQUFXb0IsUUFMYixDQURGO0FBU0Q7Ozs7OztrQkFoRWtCckIsYTs7O0FBbUVyQkEsY0FBY3NCLFdBQWQsR0FBNEIsZUFBNUI7QUFDQXRCLGNBQWN0QyxTQUFkLEdBQTBCQSxTQUExQjtBQUNBc0MsY0FBY0gsWUFBZCxHQUE2QkEsWUFBN0IiLCJmaWxlIjoibWFwLWNvbnRyb2xsZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1B1cmVDb21wb25lbnQsIGNyZWF0ZUVsZW1lbnR9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbmltcG9ydCB7TUFQQk9YX0xJTUlUU30gZnJvbSAnLi9tYXAtc3RhdGUnO1xuaW1wb3J0IEV2ZW50TWFuYWdlciBmcm9tICcuLi8uLi91dGlscy9ldmVudHMvZXZlbnQtbWFuYWdlcic7XG5pbXBvcnQgTWFwQ29udHJvbHMgZnJvbSAnLi9tYXAtY29udHJvbHMnO1xuaW1wb3J0IGNvbmZpZyBmcm9tICcuLi9jb25maWcnO1xuXG5jb25zdCBwcm9wVHlwZXMgPSB7XG4gIC8qKiBUaGUgd2lkdGggb2YgdGhlIG1hcC4gKi9cbiAgd2lkdGg6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgLyoqIFRoZSBoZWlnaHQgb2YgdGhlIG1hcC4gKi9cbiAgaGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIC8qKiBUaGUgbG9uZ2l0dWRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIG1hcC4gKi9cbiAgbG9uZ2l0dWRlOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIC8qKiBUaGUgbGF0aXR1ZGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgbWFwLiAqL1xuICBsYXRpdHVkZTogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICAvKiogVGhlIHRpbGUgem9vbSBsZXZlbCBvZiB0aGUgbWFwLiAqL1xuICB6b29tOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIC8qKiBTcGVjaWZ5IHRoZSBiZWFyaW5nIG9mIHRoZSB2aWV3cG9ydCAqL1xuICBiZWFyaW5nOiBQcm9wVHlwZXMubnVtYmVyLFxuICAvKiogU3BlY2lmeSB0aGUgcGl0Y2ggb2YgdGhlIHZpZXdwb3J0ICovXG4gIHBpdGNoOiBQcm9wVHlwZXMubnVtYmVyLFxuICAvKiogQWx0aXR1ZGUgb2YgdGhlIHZpZXdwb3J0IGNhbWVyYS4gRGVmYXVsdCAxLjUgXCJzY3JlZW4gaGVpZ2h0c1wiICovXG4gIC8vIE5vdGU6IE5vbi1wdWJsaWMgQVBJLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21hcGJveC9tYXBib3gtZ2wtanMvaXNzdWVzLzExMzdcbiAgYWx0aXR1ZGU6IFByb3BUeXBlcy5udW1iZXIsXG5cbiAgLyoqIFZpZXdwb3J0IGNvbnN0cmFpbnRzICovXG4gIC8vIE1heCB6b29tIGxldmVsXG4gIG1heFpvb206IFByb3BUeXBlcy5udW1iZXIsXG4gIC8vIE1pbiB6b29tIGxldmVsXG4gIG1pblpvb206IFByb3BUeXBlcy5udW1iZXIsXG4gIC8vIE1heCBwaXRjaCBpbiBkZWdyZWVzXG4gIG1heFBpdGNoOiBQcm9wVHlwZXMubnVtYmVyLFxuICAvLyBNaW4gcGl0Y2ggaW4gZGVncmVlc1xuICBtaW5QaXRjaDogUHJvcFR5cGVzLm51bWJlcixcblxuICAvKipcbiAgICogYG9uVmlld3BvcnRDaGFuZ2VgIGNhbGxiYWNrIGlzIGZpcmVkIHdoZW4gdGhlIHVzZXIgaW50ZXJhY3RlZCB3aXRoIHRoZVxuICAgKiBtYXAuIFRoZSBvYmplY3QgcGFzc2VkIHRvIHRoZSBjYWxsYmFjayBjb250YWlucyB2aWV3cG9ydCBwcm9wZXJ0aWVzXG4gICAqIHN1Y2ggYXMgYGxvbmdpdHVkZWAsIGBsYXRpdHVkZWAsIGB6b29tYCBldGMuXG4gICAqL1xuICBvblZpZXdwb3J0Q2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKiogRW5hYmxlcyBjb250cm9sIGV2ZW50IGhhbmRsaW5nICovXG4gIC8vIFNjcm9sbCB0byB6b29tXG4gIHNjcm9sbFpvb206IFByb3BUeXBlcy5ib29sLFxuICAvLyBEcmFnIHRvIHBhblxuICBkcmFnUGFuOiBQcm9wVHlwZXMuYm9vbCxcbiAgLy8gRHJhZyB0byByb3RhdGVcbiAgZHJhZ1JvdGF0ZTogUHJvcFR5cGVzLmJvb2wsXG4gIC8vIERvdWJsZSBjbGljayB0byB6b29tXG4gIGRvdWJsZUNsaWNrWm9vbTogUHJvcFR5cGVzLmJvb2wsXG4gIC8vIFBpbmNoIHRvIHpvb20gLyByb3RhdGVcbiAgdG91Y2hab29tUm90YXRlOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKiogQWNjZXNzb3IgdGhhdCByZXR1cm5zIGEgY3Vyc29yIHN0eWxlIHRvIHNob3cgaW50ZXJhY3RpdmUgc3RhdGUgKi9cbiAgZ2V0Q3Vyc29yOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvLyBBIG1hcCBjb250cm9sIGluc3RhbmNlIHRvIHJlcGxhY2UgdGhlIGRlZmF1bHQgbWFwIGNvbnRyb2xzXG4gIC8vIFRoZSBvYmplY3QgbXVzdCBleHBvc2Ugb25lIHByb3BlcnR5OiBgZXZlbnRzYCBhcyBhbiBhcnJheSBvZiBzdWJzY3JpYmVkXG4gIC8vIGV2ZW50IG5hbWVzOyBhbmQgdHdvIG1ldGhvZHM6IGBzZXRTdGF0ZShzdGF0ZSlgIGFuZCBgaGFuZGxlKGV2ZW50KWBcbiAgbWFwQ29udHJvbHM6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgZXZlbnRzOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuc3RyaW5nKSxcbiAgICBoYW5kbGVFdmVudDogUHJvcFR5cGVzLmZ1bmNcbiAgfSlcbn07XG5cbmNvbnN0IGdldERlZmF1bHRDdXJzb3IgPSAoe2lzRHJhZ2dpbmd9KSA9PiBpc0RyYWdnaW5nID9cbiAgY29uZmlnLkNVUlNPUi5HUkFCQklORyA6IGNvbmZpZy5DVVJTT1IuR1JBQjtcblxuY29uc3QgZGVmYXVsdFByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgTUFQQk9YX0xJTUlUUywge1xuICBvblZpZXdwb3J0Q2hhbmdlOiBudWxsLFxuXG4gIHNjcm9sbFpvb206IHRydWUsXG4gIGRyYWdQYW46IHRydWUsXG4gIGRyYWdSb3RhdGU6IHRydWUsXG4gIGRvdWJsZUNsaWNrWm9vbTogdHJ1ZSxcbiAgdG91Y2hab29tUm90YXRlOiB0cnVlLFxuXG4gIGdldEN1cnNvcjogZ2V0RGVmYXVsdEN1cnNvclxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1hcENvbnRyb2xsZXIgZXh0ZW5kcyBQdXJlQ29tcG9uZW50IHtcblxuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcblxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAvLyBXaGV0aGVyIHRoZSBjdXJzb3IgaXMgZG93blxuICAgICAgaXNEcmFnZ2luZzogZmFsc2VcbiAgICB9O1xuXG4gICAgLy8gSWYgcHJvcHMubWFwQ29udHJvbHMgaXMgbm90IHByb3ZpZGVkLCBmYWxsYmFjayB0byBkZWZhdWx0IE1hcENvbnRyb2xzIGluc3RhbmNlXG4gICAgLy8gQ2Fubm90IHVzZSBkZWZhdWx0UHJvcHMgaGVyZSBiZWNhdXNlIGl0IG5lZWRzIHRvIGJlIHBlciBtYXAgaW5zdGFuY2VcbiAgICB0aGlzLl9tYXBDb250cm9scyA9IHByb3BzLm1hcENvbnRyb2xzIHx8IG5ldyBNYXBDb250cm9scygpO1xuICB9XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgY29uc3Qge2V2ZW50Q2FudmFzfSA9IHRoaXMucmVmcztcblxuICAgIGNvbnN0IGV2ZW50TWFuYWdlciA9IG5ldyBFdmVudE1hbmFnZXIoZXZlbnRDYW52YXMpO1xuXG4gICAgdGhpcy5fZXZlbnRNYW5hZ2VyID0gZXZlbnRNYW5hZ2VyO1xuXG4gICAgdGhpcy5fbWFwQ29udHJvbHMuc2V0T3B0aW9ucyhPYmplY3QuYXNzaWduKHt9LCB0aGlzLnByb3BzLCB7XG4gICAgICBvblN0YXRlQ2hhbmdlOiB0aGlzLl9vbkludGVyYWN0aXZlU3RhdGVDaGFuZ2UuYmluZCh0aGlzKSxcbiAgICAgIGV2ZW50TWFuYWdlclxuICAgIH0pKTtcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVcGRhdGUobmV4dFByb3BzKSB7XG4gICAgdGhpcy5fbWFwQ29udHJvbHMuc2V0T3B0aW9ucyhuZXh0UHJvcHMpO1xuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgaWYgKHRoaXMuX2V2ZW50TWFuYWdlcikge1xuICAgICAgLy8gTXVzdCBkZXN0cm95IGJlY2F1c2UgaGFtbWVyIGFkZHMgZXZlbnQgbGlzdGVuZXJzIHRvIHdpbmRvd1xuICAgICAgdGhpcy5fZXZlbnRNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cblxuICBfb25JbnRlcmFjdGl2ZVN0YXRlQ2hhbmdlKHtpc0RyYWdnaW5nID0gZmFsc2V9KSB7XG4gICAgaWYgKGlzRHJhZ2dpbmcgIT09IHRoaXMuc3RhdGUuaXNEcmFnZ2luZykge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7aXNEcmFnZ2luZ30pO1xuICAgIH1cbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7d2lkdGgsIGhlaWdodCwgZ2V0Q3Vyc29yfSA9IHRoaXMucHJvcHM7XG5cbiAgICBjb25zdCBldmVudENhbnZhc1N0eWxlID0ge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgIGN1cnNvcjogZ2V0Q3Vyc29yKHRoaXMuc3RhdGUpXG4gICAgfTtcblxuICAgIHJldHVybiAoXG4gICAgICBjcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICAgIGtleTogJ21hcC1jb250cm9scycsXG4gICAgICAgIHJlZjogJ2V2ZW50Q2FudmFzJyxcbiAgICAgICAgc3R5bGU6IGV2ZW50Q2FudmFzU3R5bGVcbiAgICAgIH0sXG4gICAgICAgIHRoaXMucHJvcHMuY2hpbGRyZW5cbiAgICAgIClcbiAgICApO1xuICB9XG59XG5cbk1hcENvbnRyb2xsZXIuZGlzcGxheU5hbWUgPSAnTWFwQ29udHJvbGxlcic7XG5NYXBDb250cm9sbGVyLnByb3BUeXBlcyA9IHByb3BUeXBlcztcbk1hcENvbnRyb2xsZXIuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuIl19