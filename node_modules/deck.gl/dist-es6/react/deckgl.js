var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

import React, { createElement } from 'react';
import PropTypes from 'prop-types';
import autobind from './autobind';
import WebGLRenderer from './webgl-renderer';
import { LayerManager, Layer } from '../lib';
import { EffectManager, Effect } from '../experimental';
import { GL, setParameters } from 'luma.gl';
import { Viewport, WebMercatorViewport } from '../lib/viewports';
import EventManager from '../utils/events/event-manager';

function noop() {}

var propTypes = {
  id: PropTypes.string,
  width: PropTypes.number.isRequired,
  height: PropTypes.number.isRequired,
  layers: PropTypes.arrayOf(PropTypes.instanceOf(Layer)).isRequired,
  effects: PropTypes.arrayOf(PropTypes.instanceOf(Effect)),
  gl: PropTypes.object,
  debug: PropTypes.bool,
  pickingRadius: PropTypes.number,
  viewport: PropTypes.instanceOf(Viewport),
  onWebGLInitialized: PropTypes.func,
  initWebGLParameters: PropTypes.bool,
  onAfterRender: PropTypes.func,
  onLayerClick: PropTypes.func,
  onLayerHover: PropTypes.func
};

var defaultProps = {
  id: 'deckgl-overlay',
  debug: false,
  pickingRadius: 0,
  gl: null,
  effects: [],
  onWebGLInitialized: noop,
  initWebGLParameters: false,
  onAfterRender: noop,
  onLayerClick: null,
  onLayerHover: null
};

var DeckGL = function (_React$Component) {
  _inherits(DeckGL, _React$Component);

  function DeckGL(props) {
    _classCallCheck(this, DeckGL);

    var _this = _possibleConstructorReturn(this, (DeckGL.__proto__ || Object.getPrototypeOf(DeckGL)).call(this, props));

    _this.state = {};
    _this.needsRedraw = true;
    _this.layerManager = null;
    _this.effectManager = null;
    autobind(_this);
    return _this;
  }

  _createClass(DeckGL, [{
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      this._updateLayers(nextProps);
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      if (this.layerManager) {
        this.layerManager.finalize();
      }
    }

    /* Public API */

  }, {
    key: 'queryObject',
    value: function queryObject(_ref) {
      var x = _ref.x,
          y = _ref.y,
          _ref$radius = _ref.radius,
          radius = _ref$radius === undefined ? 0 : _ref$radius,
          _ref$layerIds = _ref.layerIds,
          layerIds = _ref$layerIds === undefined ? null : _ref$layerIds;

      var selectedInfos = this.layerManager.pickLayer({ x: x, y: y, radius: radius, layerIds: layerIds, mode: 'query' });
      return selectedInfos.length ? selectedInfos[0] : null;
    }
  }, {
    key: 'queryVisibleObjects',
    value: function queryVisibleObjects(_ref2) {
      var x = _ref2.x,
          y = _ref2.y,
          _ref2$width = _ref2.width,
          width = _ref2$width === undefined ? 1 : _ref2$width,
          _ref2$height = _ref2.height,
          height = _ref2$height === undefined ? 1 : _ref2$height,
          _ref2$layerIds = _ref2.layerIds,
          layerIds = _ref2$layerIds === undefined ? null : _ref2$layerIds;

      return this.layerManager.queryLayer({ x: x, y: y, width: width, height: height, layerIds: layerIds });
    }
  }, {
    key: '_updateLayers',
    value: function _updateLayers(nextProps) {
      var width = nextProps.width,
          height = nextProps.height,
          latitude = nextProps.latitude,
          longitude = nextProps.longitude,
          zoom = nextProps.zoom,
          pitch = nextProps.pitch,
          bearing = nextProps.bearing,
          altitude = nextProps.altitude,
          pickingRadius = nextProps.pickingRadius,
          onLayerClick = nextProps.onLayerClick,
          onLayerHover = nextProps.onLayerHover;


      this.layerManager.setEventHandlingParameters({
        pickingRadius: pickingRadius,
        onLayerClick: onLayerClick,
        onLayerHover: onLayerHover
      });

      // If Viewport is not supplied, create one from mercator props
      var viewport = nextProps.viewport;

      viewport = viewport || new WebMercatorViewport({
        width: width, height: height, latitude: latitude, longitude: longitude, zoom: zoom, pitch: pitch, bearing: bearing, altitude: altitude
      });

      if (this.layerManager) {
        this.layerManager.setViewport(viewport).updateLayers({ newLayers: nextProps.layers });
      }
    }
  }, {
    key: '_onRendererInitialized',
    value: function _onRendererInitialized(_ref3) {
      var gl = _ref3.gl,
          canvas = _ref3.canvas;

      setParameters(gl, {
        blend: true,
        blendFunc: [GL.SRC_ALPHA, GL.ONE_MINUS_SRC_ALPHA],
        polygonOffsetFill: true
      });

      // TODO - these will be set by default starting from next major release
      if (this.props.initWebGLParameters) {
        setParameters(gl, {
          depthTest: true,
          depthFunc: GL.LEQUAL
        });
      }

      var props = this.props;

      props.onWebGLInitialized(gl);

      // Note: avoid React setState due GL animation loop / setState timing issue
      this.layerManager = new LayerManager({ gl: gl });
      this.layerManager.initEventHandling(new EventManager(canvas));
      this.effectManager = new EffectManager({ gl: gl, layerManager: this.layerManager });

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = props.effects[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var effect = _step.value;

          this.effectManager.addEffect(effect);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this._updateLayers(props);
    }
  }, {
    key: '_onRenderFrame',
    value: function _onRenderFrame(_ref4) {
      var gl = _ref4.gl;

      var redraw = this.layerManager.needsRedraw({ clearRedrawFlags: true });
      if (!redraw) {
        return;
      }

      // clear depth and color buffers
      gl.clear(GL.COLOR_BUFFER_BIT | GL.DEPTH_BUFFER_BIT);

      this.effectManager.preDraw();
      this.layerManager.drawLayers({ pass: 'to screen' });
      this.effectManager.draw();
    }
  }, {
    key: 'render',
    value: function render() {
      var _props = this.props,
          width = _props.width,
          height = _props.height,
          gl = _props.gl,
          debug = _props.debug;


      return createElement(WebGLRenderer, Object.assign({}, this.props, {
        width: width,
        height: height,
        // NOTE: Add 'useDevicePixelRatio' to 'this.props' and also pass it down to
        // to modules where window.devicePixelRatio is used.
        useDevicePixelRatio: true,
        gl: gl,
        debug: debug,
        onRendererInitialized: this._onRendererInitialized,
        onNeedRedraw: this._onNeedRedraw,
        onRenderFrame: this._onRenderFrame
      }));
    }
  }]);

  return DeckGL;
}(React.Component);

export default DeckGL;


DeckGL.propTypes = propTypes;
DeckGL.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9yZWFjdC9kZWNrZ2wuanMiXSwibmFtZXMiOlsiUmVhY3QiLCJjcmVhdGVFbGVtZW50IiwiUHJvcFR5cGVzIiwiYXV0b2JpbmQiLCJXZWJHTFJlbmRlcmVyIiwiTGF5ZXJNYW5hZ2VyIiwiTGF5ZXIiLCJFZmZlY3RNYW5hZ2VyIiwiRWZmZWN0IiwiR0wiLCJzZXRQYXJhbWV0ZXJzIiwiVmlld3BvcnQiLCJXZWJNZXJjYXRvclZpZXdwb3J0IiwiRXZlbnRNYW5hZ2VyIiwibm9vcCIsInByb3BUeXBlcyIsImlkIiwic3RyaW5nIiwid2lkdGgiLCJudW1iZXIiLCJpc1JlcXVpcmVkIiwiaGVpZ2h0IiwibGF5ZXJzIiwiYXJyYXlPZiIsImluc3RhbmNlT2YiLCJlZmZlY3RzIiwiZ2wiLCJvYmplY3QiLCJkZWJ1ZyIsImJvb2wiLCJwaWNraW5nUmFkaXVzIiwidmlld3BvcnQiLCJvbldlYkdMSW5pdGlhbGl6ZWQiLCJmdW5jIiwiaW5pdFdlYkdMUGFyYW1ldGVycyIsIm9uQWZ0ZXJSZW5kZXIiLCJvbkxheWVyQ2xpY2siLCJvbkxheWVySG92ZXIiLCJkZWZhdWx0UHJvcHMiLCJEZWNrR0wiLCJwcm9wcyIsInN0YXRlIiwibmVlZHNSZWRyYXciLCJsYXllck1hbmFnZXIiLCJlZmZlY3RNYW5hZ2VyIiwibmV4dFByb3BzIiwiX3VwZGF0ZUxheWVycyIsImZpbmFsaXplIiwieCIsInkiLCJyYWRpdXMiLCJsYXllcklkcyIsInNlbGVjdGVkSW5mb3MiLCJwaWNrTGF5ZXIiLCJtb2RlIiwibGVuZ3RoIiwicXVlcnlMYXllciIsImxhdGl0dWRlIiwibG9uZ2l0dWRlIiwiem9vbSIsInBpdGNoIiwiYmVhcmluZyIsImFsdGl0dWRlIiwic2V0RXZlbnRIYW5kbGluZ1BhcmFtZXRlcnMiLCJzZXRWaWV3cG9ydCIsInVwZGF0ZUxheWVycyIsIm5ld0xheWVycyIsImNhbnZhcyIsImJsZW5kIiwiYmxlbmRGdW5jIiwiU1JDX0FMUEhBIiwiT05FX01JTlVTX1NSQ19BTFBIQSIsInBvbHlnb25PZmZzZXRGaWxsIiwiZGVwdGhUZXN0IiwiZGVwdGhGdW5jIiwiTEVRVUFMIiwiaW5pdEV2ZW50SGFuZGxpbmciLCJlZmZlY3QiLCJhZGRFZmZlY3QiLCJyZWRyYXciLCJjbGVhclJlZHJhd0ZsYWdzIiwiY2xlYXIiLCJDT0xPUl9CVUZGRVJfQklUIiwiREVQVEhfQlVGRkVSX0JJVCIsInByZURyYXciLCJkcmF3TGF5ZXJzIiwicGFzcyIsImRyYXciLCJPYmplY3QiLCJhc3NpZ24iLCJ1c2VEZXZpY2VQaXhlbFJhdGlvIiwib25SZW5kZXJlckluaXRpYWxpemVkIiwiX29uUmVuZGVyZXJJbml0aWFsaXplZCIsIm9uTmVlZFJlZHJhdyIsIl9vbk5lZWRSZWRyYXciLCJvblJlbmRlckZyYW1lIiwiX29uUmVuZGVyRnJhbWUiLCJDb21wb25lbnQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBT0EsS0FBUCxJQUFlQyxhQUFmLFFBQW1DLE9BQW5DO0FBQ0EsT0FBT0MsU0FBUCxNQUFzQixZQUF0QjtBQUNBLE9BQU9DLFFBQVAsTUFBcUIsWUFBckI7QUFDQSxPQUFPQyxhQUFQLE1BQTBCLGtCQUExQjtBQUNBLFNBQVFDLFlBQVIsRUFBc0JDLEtBQXRCLFFBQWtDLFFBQWxDO0FBQ0EsU0FBUUMsYUFBUixFQUF1QkMsTUFBdkIsUUFBb0MsaUJBQXBDO0FBQ0EsU0FBUUMsRUFBUixFQUFZQyxhQUFaLFFBQWdDLFNBQWhDO0FBQ0EsU0FBUUMsUUFBUixFQUFrQkMsbUJBQWxCLFFBQTRDLGtCQUE1QztBQUNBLE9BQU9DLFlBQVAsTUFBeUIsK0JBQXpCOztBQUVBLFNBQVNDLElBQVQsR0FBZ0IsQ0FBRTs7QUFFbEIsSUFBTUMsWUFBWTtBQUNoQkMsTUFBSWQsVUFBVWUsTUFERTtBQUVoQkMsU0FBT2hCLFVBQVVpQixNQUFWLENBQWlCQyxVQUZSO0FBR2hCQyxVQUFRbkIsVUFBVWlCLE1BQVYsQ0FBaUJDLFVBSFQ7QUFJaEJFLFVBQVFwQixVQUFVcUIsT0FBVixDQUFrQnJCLFVBQVVzQixVQUFWLENBQXFCbEIsS0FBckIsQ0FBbEIsRUFBK0NjLFVBSnZDO0FBS2hCSyxXQUFTdkIsVUFBVXFCLE9BQVYsQ0FBa0JyQixVQUFVc0IsVUFBVixDQUFxQmhCLE1BQXJCLENBQWxCLENBTE87QUFNaEJrQixNQUFJeEIsVUFBVXlCLE1BTkU7QUFPaEJDLFNBQU8xQixVQUFVMkIsSUFQRDtBQVFoQkMsaUJBQWU1QixVQUFVaUIsTUFSVDtBQVNoQlksWUFBVTdCLFVBQVVzQixVQUFWLENBQXFCYixRQUFyQixDQVRNO0FBVWhCcUIsc0JBQW9COUIsVUFBVStCLElBVmQ7QUFXaEJDLHVCQUFxQmhDLFVBQVUyQixJQVhmO0FBWWhCTSxpQkFBZWpDLFVBQVUrQixJQVpUO0FBYWhCRyxnQkFBY2xDLFVBQVUrQixJQWJSO0FBY2hCSSxnQkFBY25DLFVBQVUrQjtBQWRSLENBQWxCOztBQWlCQSxJQUFNSyxlQUFlO0FBQ25CdEIsTUFBSSxnQkFEZTtBQUVuQlksU0FBTyxLQUZZO0FBR25CRSxpQkFBZSxDQUhJO0FBSW5CSixNQUFJLElBSmU7QUFLbkJELFdBQVMsRUFMVTtBQU1uQk8sc0JBQW9CbEIsSUFORDtBQU9uQm9CLHVCQUFxQixLQVBGO0FBUW5CQyxpQkFBZXJCLElBUkk7QUFTbkJzQixnQkFBYyxJQVRLO0FBVW5CQyxnQkFBYztBQVZLLENBQXJCOztJQWFxQkUsTTs7O0FBQ25CLGtCQUFZQyxLQUFaLEVBQW1CO0FBQUE7O0FBQUEsZ0hBQ1hBLEtBRFc7O0FBRWpCLFVBQUtDLEtBQUwsR0FBYSxFQUFiO0FBQ0EsVUFBS0MsV0FBTCxHQUFtQixJQUFuQjtBQUNBLFVBQUtDLFlBQUwsR0FBb0IsSUFBcEI7QUFDQSxVQUFLQyxhQUFMLEdBQXFCLElBQXJCO0FBQ0F6QztBQU5pQjtBQU9sQjs7Ozs4Q0FFeUIwQyxTLEVBQVc7QUFDbkMsV0FBS0MsYUFBTCxDQUFtQkQsU0FBbkI7QUFDRDs7OzJDQUVzQjtBQUNyQixVQUFJLEtBQUtGLFlBQVQsRUFBdUI7QUFDckIsYUFBS0EsWUFBTCxDQUFrQkksUUFBbEI7QUFDRDtBQUNGOztBQUVEOzs7O3NDQUNpRDtBQUFBLFVBQXBDQyxDQUFvQyxRQUFwQ0EsQ0FBb0M7QUFBQSxVQUFqQ0MsQ0FBaUMsUUFBakNBLENBQWlDO0FBQUEsNkJBQTlCQyxNQUE4QjtBQUFBLFVBQTlCQSxNQUE4QiwrQkFBckIsQ0FBcUI7QUFBQSwrQkFBbEJDLFFBQWtCO0FBQUEsVUFBbEJBLFFBQWtCLGlDQUFQLElBQU87O0FBQy9DLFVBQU1DLGdCQUFnQixLQUFLVCxZQUFMLENBQWtCVSxTQUFsQixDQUE0QixFQUFDTCxJQUFELEVBQUlDLElBQUosRUFBT0MsY0FBUCxFQUFlQyxrQkFBZixFQUF5QkcsTUFBTSxPQUEvQixFQUE1QixDQUF0QjtBQUNBLGFBQU9GLGNBQWNHLE1BQWQsR0FBdUJILGNBQWMsQ0FBZCxDQUF2QixHQUEwQyxJQUFqRDtBQUNEOzs7K0NBRW1FO0FBQUEsVUFBL0NKLENBQStDLFNBQS9DQSxDQUErQztBQUFBLFVBQTVDQyxDQUE0QyxTQUE1Q0EsQ0FBNEM7QUFBQSw4QkFBekMvQixLQUF5QztBQUFBLFVBQXpDQSxLQUF5QywrQkFBakMsQ0FBaUM7QUFBQSwrQkFBOUJHLE1BQThCO0FBQUEsVUFBOUJBLE1BQThCLGdDQUFyQixDQUFxQjtBQUFBLGlDQUFsQjhCLFFBQWtCO0FBQUEsVUFBbEJBLFFBQWtCLGtDQUFQLElBQU87O0FBQ2xFLGFBQU8sS0FBS1IsWUFBTCxDQUFrQmEsVUFBbEIsQ0FBNkIsRUFBQ1IsSUFBRCxFQUFJQyxJQUFKLEVBQU8vQixZQUFQLEVBQWNHLGNBQWQsRUFBc0I4QixrQkFBdEIsRUFBN0IsQ0FBUDtBQUNEOzs7a0NBRWFOLFMsRUFBVztBQUFBLFVBRXJCM0IsS0FGcUIsR0FhbkIyQixTQWJtQixDQUVyQjNCLEtBRnFCO0FBQUEsVUFHckJHLE1BSHFCLEdBYW5Cd0IsU0FibUIsQ0FHckJ4QixNQUhxQjtBQUFBLFVBSXJCb0MsUUFKcUIsR0FhbkJaLFNBYm1CLENBSXJCWSxRQUpxQjtBQUFBLFVBS3JCQyxTQUxxQixHQWFuQmIsU0FibUIsQ0FLckJhLFNBTHFCO0FBQUEsVUFNckJDLElBTnFCLEdBYW5CZCxTQWJtQixDQU1yQmMsSUFOcUI7QUFBQSxVQU9yQkMsS0FQcUIsR0FhbkJmLFNBYm1CLENBT3JCZSxLQVBxQjtBQUFBLFVBUXJCQyxPQVJxQixHQWFuQmhCLFNBYm1CLENBUXJCZ0IsT0FScUI7QUFBQSxVQVNyQkMsUUFUcUIsR0FhbkJqQixTQWJtQixDQVNyQmlCLFFBVHFCO0FBQUEsVUFVckJoQyxhQVZxQixHQWFuQmUsU0FibUIsQ0FVckJmLGFBVnFCO0FBQUEsVUFXckJNLFlBWHFCLEdBYW5CUyxTQWJtQixDQVdyQlQsWUFYcUI7QUFBQSxVQVlyQkMsWUFacUIsR0FhbkJRLFNBYm1CLENBWXJCUixZQVpxQjs7O0FBZXZCLFdBQUtNLFlBQUwsQ0FBa0JvQiwwQkFBbEIsQ0FBNkM7QUFDM0NqQyxvQ0FEMkM7QUFFM0NNLGtDQUYyQztBQUczQ0M7QUFIMkMsT0FBN0M7O0FBTUE7QUFyQnVCLFVBc0JsQk4sUUF0QmtCLEdBc0JOYyxTQXRCTSxDQXNCbEJkLFFBdEJrQjs7QUF1QnZCQSxpQkFBV0EsWUFBWSxJQUFJbkIsbUJBQUosQ0FBd0I7QUFDN0NNLG9CQUQ2QyxFQUN0Q0csY0FEc0MsRUFDOUJvQyxrQkFEOEIsRUFDcEJDLG9CQURvQixFQUNUQyxVQURTLEVBQ0hDLFlBREcsRUFDSUMsZ0JBREosRUFDYUM7QUFEYixPQUF4QixDQUF2Qjs7QUFJQSxVQUFJLEtBQUtuQixZQUFULEVBQXVCO0FBQ3JCLGFBQUtBLFlBQUwsQ0FDR3FCLFdBREgsQ0FDZWpDLFFBRGYsRUFFR2tDLFlBRkgsQ0FFZ0IsRUFBQ0MsV0FBV3JCLFVBQVV2QixNQUF0QixFQUZoQjtBQUdEO0FBQ0Y7OztrREFFb0M7QUFBQSxVQUFiSSxFQUFhLFNBQWJBLEVBQWE7QUFBQSxVQUFUeUMsTUFBUyxTQUFUQSxNQUFTOztBQUNuQ3pELG9CQUFjZ0IsRUFBZCxFQUFrQjtBQUNoQjBDLGVBQU8sSUFEUztBQUVoQkMsbUJBQVcsQ0FBQzVELEdBQUc2RCxTQUFKLEVBQWU3RCxHQUFHOEQsbUJBQWxCLENBRks7QUFHaEJDLDJCQUFtQjtBQUhILE9BQWxCOztBQU1BO0FBQ0EsVUFBSSxLQUFLaEMsS0FBTCxDQUFXTixtQkFBZixFQUFvQztBQUNsQ3hCLHNCQUFjZ0IsRUFBZCxFQUFrQjtBQUNoQitDLHFCQUFXLElBREs7QUFFaEJDLHFCQUFXakUsR0FBR2tFO0FBRkUsU0FBbEI7QUFJRDs7QUFia0MsVUFlNUJuQyxLQWY0QixHQWVuQixJQWZtQixDQWU1QkEsS0FmNEI7O0FBZ0JuQ0EsWUFBTVIsa0JBQU4sQ0FBeUJOLEVBQXpCOztBQUVBO0FBQ0EsV0FBS2lCLFlBQUwsR0FBb0IsSUFBSXRDLFlBQUosQ0FBaUIsRUFBQ3FCLE1BQUQsRUFBakIsQ0FBcEI7QUFDQSxXQUFLaUIsWUFBTCxDQUFrQmlDLGlCQUFsQixDQUFvQyxJQUFJL0QsWUFBSixDQUFpQnNELE1BQWpCLENBQXBDO0FBQ0EsV0FBS3ZCLGFBQUwsR0FBcUIsSUFBSXJDLGFBQUosQ0FBa0IsRUFBQ21CLE1BQUQsRUFBS2lCLGNBQWMsS0FBS0EsWUFBeEIsRUFBbEIsQ0FBckI7O0FBckJtQztBQUFBO0FBQUE7O0FBQUE7QUF1Qm5DLDZCQUFxQkgsTUFBTWYsT0FBM0IsOEhBQW9DO0FBQUEsY0FBekJvRCxNQUF5Qjs7QUFDbEMsZUFBS2pDLGFBQUwsQ0FBbUJrQyxTQUFuQixDQUE2QkQsTUFBN0I7QUFDRDtBQXpCa0M7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUEyQm5DLFdBQUsvQixhQUFMLENBQW1CTixLQUFuQjtBQUNEOzs7MENBRW9CO0FBQUEsVUFBTGQsRUFBSyxTQUFMQSxFQUFLOztBQUNuQixVQUFNcUQsU0FBUyxLQUFLcEMsWUFBTCxDQUFrQkQsV0FBbEIsQ0FBOEIsRUFBQ3NDLGtCQUFrQixJQUFuQixFQUE5QixDQUFmO0FBQ0EsVUFBSSxDQUFDRCxNQUFMLEVBQWE7QUFDWDtBQUNEOztBQUVEO0FBQ0FyRCxTQUFHdUQsS0FBSCxDQUFTeEUsR0FBR3lFLGdCQUFILEdBQXNCekUsR0FBRzBFLGdCQUFsQzs7QUFFQSxXQUFLdkMsYUFBTCxDQUFtQndDLE9BQW5CO0FBQ0EsV0FBS3pDLFlBQUwsQ0FBa0IwQyxVQUFsQixDQUE2QixFQUFDQyxNQUFNLFdBQVAsRUFBN0I7QUFDQSxXQUFLMUMsYUFBTCxDQUFtQjJDLElBQW5CO0FBQ0Q7Ozs2QkFFUTtBQUFBLG1CQUM0QixLQUFLL0MsS0FEakM7QUFBQSxVQUNBdEIsS0FEQSxVQUNBQSxLQURBO0FBQUEsVUFDT0csTUFEUCxVQUNPQSxNQURQO0FBQUEsVUFDZUssRUFEZixVQUNlQSxFQURmO0FBQUEsVUFDbUJFLEtBRG5CLFVBQ21CQSxLQURuQjs7O0FBR1AsYUFBTzNCLGNBQWNHLGFBQWQsRUFBNkJvRixPQUFPQyxNQUFQLENBQWMsRUFBZCxFQUFrQixLQUFLakQsS0FBdkIsRUFBOEI7QUFDaEV0QixvQkFEZ0U7QUFFaEVHLHNCQUZnRTtBQUdoRTtBQUNBO0FBQ0FxRSw2QkFBcUIsSUFMMkM7QUFNaEVoRSxjQU5nRTtBQU9oRUUsb0JBUGdFO0FBUWhFK0QsK0JBQXVCLEtBQUtDLHNCQVJvQztBQVNoRUMsc0JBQWMsS0FBS0MsYUFUNkM7QUFVaEVDLHVCQUFlLEtBQUtDO0FBVjRDLE9BQTlCLENBQTdCLENBQVA7QUFZRDs7OztFQTNIaUNoRyxNQUFNaUcsUzs7ZUFBckIxRCxNOzs7QUE4SHJCQSxPQUFPeEIsU0FBUCxHQUFtQkEsU0FBbkI7QUFDQXdCLE9BQU9ELFlBQVAsR0FBc0JBLFlBQXRCIiwiZmlsZSI6ImRlY2tnbC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQgUmVhY3QsIHtjcmVhdGVFbGVtZW50fSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGF1dG9iaW5kIGZyb20gJy4vYXV0b2JpbmQnO1xuaW1wb3J0IFdlYkdMUmVuZGVyZXIgZnJvbSAnLi93ZWJnbC1yZW5kZXJlcic7XG5pbXBvcnQge0xheWVyTWFuYWdlciwgTGF5ZXJ9IGZyb20gJy4uL2xpYic7XG5pbXBvcnQge0VmZmVjdE1hbmFnZXIsIEVmZmVjdH0gZnJvbSAnLi4vZXhwZXJpbWVudGFsJztcbmltcG9ydCB7R0wsIHNldFBhcmFtZXRlcnN9IGZyb20gJ2x1bWEuZ2wnO1xuaW1wb3J0IHtWaWV3cG9ydCwgV2ViTWVyY2F0b3JWaWV3cG9ydH0gZnJvbSAnLi4vbGliL3ZpZXdwb3J0cyc7XG5pbXBvcnQgRXZlbnRNYW5hZ2VyIGZyb20gJy4uL3V0aWxzL2V2ZW50cy9ldmVudC1tYW5hZ2VyJztcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmNvbnN0IHByb3BUeXBlcyA9IHtcbiAgaWQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHdpZHRoOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIGhlaWdodDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICBsYXllcnM6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5pbnN0YW5jZU9mKExheWVyKSkuaXNSZXF1aXJlZCxcbiAgZWZmZWN0czogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLmluc3RhbmNlT2YoRWZmZWN0KSksXG4gIGdsOiBQcm9wVHlwZXMub2JqZWN0LFxuICBkZWJ1ZzogUHJvcFR5cGVzLmJvb2wsXG4gIHBpY2tpbmdSYWRpdXM6IFByb3BUeXBlcy5udW1iZXIsXG4gIHZpZXdwb3J0OiBQcm9wVHlwZXMuaW5zdGFuY2VPZihWaWV3cG9ydCksXG4gIG9uV2ViR0xJbml0aWFsaXplZDogUHJvcFR5cGVzLmZ1bmMsXG4gIGluaXRXZWJHTFBhcmFtZXRlcnM6IFByb3BUeXBlcy5ib29sLFxuICBvbkFmdGVyUmVuZGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25MYXllckNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25MYXllckhvdmVyOiBQcm9wVHlwZXMuZnVuY1xufTtcblxuY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICBpZDogJ2RlY2tnbC1vdmVybGF5JyxcbiAgZGVidWc6IGZhbHNlLFxuICBwaWNraW5nUmFkaXVzOiAwLFxuICBnbDogbnVsbCxcbiAgZWZmZWN0czogW10sXG4gIG9uV2ViR0xJbml0aWFsaXplZDogbm9vcCxcbiAgaW5pdFdlYkdMUGFyYW1ldGVyczogZmFsc2UsXG4gIG9uQWZ0ZXJSZW5kZXI6IG5vb3AsXG4gIG9uTGF5ZXJDbGljazogbnVsbCxcbiAgb25MYXllckhvdmVyOiBudWxsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEZWNrR0wgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLnN0YXRlID0ge307XG4gICAgdGhpcy5uZWVkc1JlZHJhdyA9IHRydWU7XG4gICAgdGhpcy5sYXllck1hbmFnZXIgPSBudWxsO1xuICAgIHRoaXMuZWZmZWN0TWFuYWdlciA9IG51bGw7XG4gICAgYXV0b2JpbmQodGhpcyk7XG4gIH1cblxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgIHRoaXMuX3VwZGF0ZUxheWVycyhuZXh0UHJvcHMpO1xuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgaWYgKHRoaXMubGF5ZXJNYW5hZ2VyKSB7XG4gICAgICB0aGlzLmxheWVyTWFuYWdlci5maW5hbGl6ZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qIFB1YmxpYyBBUEkgKi9cbiAgcXVlcnlPYmplY3Qoe3gsIHksIHJhZGl1cyA9IDAsIGxheWVySWRzID0gbnVsbH0pIHtcbiAgICBjb25zdCBzZWxlY3RlZEluZm9zID0gdGhpcy5sYXllck1hbmFnZXIucGlja0xheWVyKHt4LCB5LCByYWRpdXMsIGxheWVySWRzLCBtb2RlOiAncXVlcnknfSk7XG4gICAgcmV0dXJuIHNlbGVjdGVkSW5mb3MubGVuZ3RoID8gc2VsZWN0ZWRJbmZvc1swXSA6IG51bGw7XG4gIH1cblxuICBxdWVyeVZpc2libGVPYmplY3RzKHt4LCB5LCB3aWR0aCA9IDEsIGhlaWdodCA9IDEsIGxheWVySWRzID0gbnVsbH0pIHtcbiAgICByZXR1cm4gdGhpcy5sYXllck1hbmFnZXIucXVlcnlMYXllcih7eCwgeSwgd2lkdGgsIGhlaWdodCwgbGF5ZXJJZHN9KTtcbiAgfVxuXG4gIF91cGRhdGVMYXllcnMobmV4dFByb3BzKSB7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBsYXRpdHVkZSxcbiAgICAgIGxvbmdpdHVkZSxcbiAgICAgIHpvb20sXG4gICAgICBwaXRjaCxcbiAgICAgIGJlYXJpbmcsXG4gICAgICBhbHRpdHVkZSxcbiAgICAgIHBpY2tpbmdSYWRpdXMsXG4gICAgICBvbkxheWVyQ2xpY2ssXG4gICAgICBvbkxheWVySG92ZXJcbiAgICB9ID0gbmV4dFByb3BzO1xuXG4gICAgdGhpcy5sYXllck1hbmFnZXIuc2V0RXZlbnRIYW5kbGluZ1BhcmFtZXRlcnMoe1xuICAgICAgcGlja2luZ1JhZGl1cyxcbiAgICAgIG9uTGF5ZXJDbGljayxcbiAgICAgIG9uTGF5ZXJIb3ZlclxuICAgIH0pO1xuXG4gICAgLy8gSWYgVmlld3BvcnQgaXMgbm90IHN1cHBsaWVkLCBjcmVhdGUgb25lIGZyb20gbWVyY2F0b3IgcHJvcHNcbiAgICBsZXQge3ZpZXdwb3J0fSA9IG5leHRQcm9wcztcbiAgICB2aWV3cG9ydCA9IHZpZXdwb3J0IHx8IG5ldyBXZWJNZXJjYXRvclZpZXdwb3J0KHtcbiAgICAgIHdpZHRoLCBoZWlnaHQsIGxhdGl0dWRlLCBsb25naXR1ZGUsIHpvb20sIHBpdGNoLCBiZWFyaW5nLCBhbHRpdHVkZVxuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMubGF5ZXJNYW5hZ2VyKSB7XG4gICAgICB0aGlzLmxheWVyTWFuYWdlclxuICAgICAgICAuc2V0Vmlld3BvcnQodmlld3BvcnQpXG4gICAgICAgIC51cGRhdGVMYXllcnMoe25ld0xheWVyczogbmV4dFByb3BzLmxheWVyc30pO1xuICAgIH1cbiAgfVxuXG4gIF9vblJlbmRlcmVySW5pdGlhbGl6ZWQoe2dsLCBjYW52YXN9KSB7XG4gICAgc2V0UGFyYW1ldGVycyhnbCwge1xuICAgICAgYmxlbmQ6IHRydWUsXG4gICAgICBibGVuZEZ1bmM6IFtHTC5TUkNfQUxQSEEsIEdMLk9ORV9NSU5VU19TUkNfQUxQSEFdLFxuICAgICAgcG9seWdvbk9mZnNldEZpbGw6IHRydWVcbiAgICB9KTtcblxuICAgIC8vIFRPRE8gLSB0aGVzZSB3aWxsIGJlIHNldCBieSBkZWZhdWx0IHN0YXJ0aW5nIGZyb20gbmV4dCBtYWpvciByZWxlYXNlXG4gICAgaWYgKHRoaXMucHJvcHMuaW5pdFdlYkdMUGFyYW1ldGVycykge1xuICAgICAgc2V0UGFyYW1ldGVycyhnbCwge1xuICAgICAgICBkZXB0aFRlc3Q6IHRydWUsXG4gICAgICAgIGRlcHRoRnVuYzogR0wuTEVRVUFMXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCB7cHJvcHN9ID0gdGhpcztcbiAgICBwcm9wcy5vbldlYkdMSW5pdGlhbGl6ZWQoZ2wpO1xuXG4gICAgLy8gTm90ZTogYXZvaWQgUmVhY3Qgc2V0U3RhdGUgZHVlIEdMIGFuaW1hdGlvbiBsb29wIC8gc2V0U3RhdGUgdGltaW5nIGlzc3VlXG4gICAgdGhpcy5sYXllck1hbmFnZXIgPSBuZXcgTGF5ZXJNYW5hZ2VyKHtnbH0pO1xuICAgIHRoaXMubGF5ZXJNYW5hZ2VyLmluaXRFdmVudEhhbmRsaW5nKG5ldyBFdmVudE1hbmFnZXIoY2FudmFzKSk7XG4gICAgdGhpcy5lZmZlY3RNYW5hZ2VyID0gbmV3IEVmZmVjdE1hbmFnZXIoe2dsLCBsYXllck1hbmFnZXI6IHRoaXMubGF5ZXJNYW5hZ2VyfSk7XG5cbiAgICBmb3IgKGNvbnN0IGVmZmVjdCBvZiBwcm9wcy5lZmZlY3RzKSB7XG4gICAgICB0aGlzLmVmZmVjdE1hbmFnZXIuYWRkRWZmZWN0KGVmZmVjdCk7XG4gICAgfVxuXG4gICAgdGhpcy5fdXBkYXRlTGF5ZXJzKHByb3BzKTtcbiAgfVxuXG4gIF9vblJlbmRlckZyYW1lKHtnbH0pIHtcbiAgICBjb25zdCByZWRyYXcgPSB0aGlzLmxheWVyTWFuYWdlci5uZWVkc1JlZHJhdyh7Y2xlYXJSZWRyYXdGbGFnczogdHJ1ZX0pO1xuICAgIGlmICghcmVkcmF3KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gY2xlYXIgZGVwdGggYW5kIGNvbG9yIGJ1ZmZlcnNcbiAgICBnbC5jbGVhcihHTC5DT0xPUl9CVUZGRVJfQklUIHwgR0wuREVQVEhfQlVGRkVSX0JJVCk7XG5cbiAgICB0aGlzLmVmZmVjdE1hbmFnZXIucHJlRHJhdygpO1xuICAgIHRoaXMubGF5ZXJNYW5hZ2VyLmRyYXdMYXllcnMoe3Bhc3M6ICd0byBzY3JlZW4nfSk7XG4gICAgdGhpcy5lZmZlY3RNYW5hZ2VyLmRyYXcoKTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7d2lkdGgsIGhlaWdodCwgZ2wsIGRlYnVnfSA9IHRoaXMucHJvcHM7XG5cbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudChXZWJHTFJlbmRlcmVyLCBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnByb3BzLCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIC8vIE5PVEU6IEFkZCAndXNlRGV2aWNlUGl4ZWxSYXRpbycgdG8gJ3RoaXMucHJvcHMnIGFuZCBhbHNvIHBhc3MgaXQgZG93biB0b1xuICAgICAgLy8gdG8gbW9kdWxlcyB3aGVyZSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyBpcyB1c2VkLlxuICAgICAgdXNlRGV2aWNlUGl4ZWxSYXRpbzogdHJ1ZSxcbiAgICAgIGdsLFxuICAgICAgZGVidWcsXG4gICAgICBvblJlbmRlcmVySW5pdGlhbGl6ZWQ6IHRoaXMuX29uUmVuZGVyZXJJbml0aWFsaXplZCxcbiAgICAgIG9uTmVlZFJlZHJhdzogdGhpcy5fb25OZWVkUmVkcmF3LFxuICAgICAgb25SZW5kZXJGcmFtZTogdGhpcy5fb25SZW5kZXJGcmFtZVxuICAgIH0pKTtcbiAgfVxufVxuXG5EZWNrR0wucHJvcFR5cGVzID0gcHJvcFR5cGVzO1xuRGVja0dMLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcbiJdfQ==