var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

import { CompositeLayer } from '../../../lib';
import GridCellLayer from '../grid-cell-layer/grid-cell-layer';

import { pointToDensityGridData } from './grid-aggregator';
import { defaultColorRange } from '../../../utils/color-utils';
import { getQuantizeScale, getLinearScale } from '../../../utils/scale-utils';

import BinSorter from '../../../utils/bin-sorter';

function nop() {}

var defaultProps = {

  // color
  colorDomain: null,
  colorRange: defaultColorRange,
  getColorValue: function getColorValue(points) {
    return points.length;
  },
  lowerPercentile: 0,
  upperPercentile: 100,
  onSetColorDomain: nop,

  // elevation
  elevationDomain: null,
  elevationRange: [0, 1000],
  getElevationValue: function getElevationValue(points) {
    return points.length;
  },
  elevationLowerPercentile: 0,
  elevationUpperPercentile: 100,
  elevationScale: 1,
  onSetElevationDomain: nop,

  // grid
  cellSize: 1000,
  coverage: 1,
  getPosition: function getPosition(x) {
    return x.position;
  },
  extruded: false,
  fp64: false,
  // Optional settings for 'lighting' shader module
  lightSettings: {
    lightsPosition: [-122.45, 37.75, 8000, -122.0, 38.00, 5000],
    ambientRatio: 0.05,
    diffuseRatio: 0.6,
    specularRatio: 0.8,
    lightsStrength: [2.0, 0.0, 0.0, 0.0],
    numberOfLights: 2
  }
};

var GridLayer = function (_CompositeLayer) {
  _inherits(GridLayer, _CompositeLayer);

  function GridLayer() {
    _classCallCheck(this, GridLayer);

    return _possibleConstructorReturn(this, (GridLayer.__proto__ || Object.getPrototypeOf(GridLayer)).apply(this, arguments));
  }

  _createClass(GridLayer, [{
    key: 'initializeState',
    value: function initializeState() {
      this.state = {
        layerData: [],
        sortedColorBins: null,
        sortedElevationBins: null,
        colorValueDomain: null,
        elevationValueDomain: null,
        colorScaleFunc: nop,
        elevationScaleFunc: nop,
        dimensionUpdaters: this.getDimensionUpdaters()
      };
    }
  }, {
    key: 'updateState',
    value: function updateState(_ref) {
      var _this2 = this;

      var oldProps = _ref.oldProps,
          props = _ref.props,
          changeFlags = _ref.changeFlags;

      var dimensionChanges = this.getDimensionChanges(oldProps, props);

      if (changeFlags.dataChanged || this.needsReProjectPoints(oldProps, props)) {
        // project data into hexagons, and get sortedBins
        this.getLayerData();
      } else if (dimensionChanges) {
        dimensionChanges.forEach(function (f) {
          return typeof f === 'function' && f.apply(_this2);
        });
      }
    }
  }, {
    key: 'needsReProjectPoints',
    value: function needsReProjectPoints(oldProps, props) {
      return oldProps.cellSize !== props.cellSize;
    }
  }, {
    key: 'getDimensionUpdaters',
    value: function getDimensionUpdaters() {
      // dimension updaters are sequential,
      // if the first one needs to be called, the 2nd and 3rd one will automatically
      // be called. e.g. if ColorValue needs to be updated, getColorValueDomain and getColorScale
      // will automatically be called
      return {
        getColor: [{
          id: 'value',
          triggers: ['getColorValue'],
          updater: this.getSortedColorBins
        }, {
          id: 'domain',
          triggers: ['lowerPercentile', 'upperPercentile'],
          updater: this.getColorValueDomain
        }, {
          id: 'scaleFunc',
          triggers: ['colorDomain', 'colorRange'],
          updater: this.getColorScale
        }],
        getElevation: [{
          id: 'value',
          triggers: ['getElevationValue'],
          updater: this.getSortedElevationBins
        }, {
          id: 'domain',
          triggers: ['elevationLowerPercentile', 'elevationUpperPercentile'],
          updater: this.getElevationValueDomain
        }, {
          id: 'scaleFunc',
          triggers: ['elevationDomain', 'elevationRange'],
          updater: this.getElevationScale
        }]
      };
    }
  }, {
    key: 'getDimensionChanges',
    value: function getDimensionChanges(oldProps, props) {
      var dimensionUpdaters = this.state.dimensionUpdaters;

      var updaters = [];

      // get dimension to be updated
      for (var dimensionKey in dimensionUpdaters) {

        // return the first triggered updater for each dimension
        var needUpdate = dimensionUpdaters[dimensionKey].find(function (item) {
          return item.triggers.some(function (t) {
            return oldProps[t] !== props[t];
          });
        });

        if (needUpdate) {
          updaters.push(needUpdate.updater);
        }
      }

      return updaters.length ? updaters : null;
    }
  }, {
    key: 'getPickingInfo',
    value: function getPickingInfo(_ref2) {
      var info = _ref2.info;
      var _state = this.state,
          sortedColorBins = _state.sortedColorBins,
          sortedElevationBins = _state.sortedElevationBins;


      var isPicked = info.picked && info.index > -1;
      var object = null;

      if (isPicked) {
        var cell = this.state.layerData[info.index];

        var colorValue = sortedColorBins.binMap[cell.index] && sortedColorBins.binMap[cell.index].value;
        var elevationValue = sortedElevationBins.binMap[cell.index] && sortedElevationBins.binMap[cell.index].value;

        object = Object.assign({
          colorValue: colorValue,
          elevationValue: elevationValue
        }, cell);
      }

      // add bin colorValue and elevationValue to info
      return Object.assign(info, {
        picked: Boolean(object),
        // override object with picked cell
        object: object
      });
    }
  }, {
    key: 'getUpdateTriggers',
    value: function getUpdateTriggers() {
      var _this3 = this;

      var dimensionUpdaters = this.state.dimensionUpdaters;

      // merge all dimension triggers

      var updateTriggers = {};

      var _loop = function _loop(dimensionKey) {

        updateTriggers[dimensionKey] = {};

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = dimensionUpdaters[dimensionKey][Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var step = _step.value;


            step.triggers.forEach(function (prop) {
              updateTriggers[dimensionKey][prop] = _this3.props[prop];
            });
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      };

      for (var dimensionKey in dimensionUpdaters) {
        _loop(dimensionKey);
      }

      return updateTriggers;
    }
  }, {
    key: 'getLayerData',
    value: function getLayerData() {
      var _props = this.props,
          data = _props.data,
          cellSize = _props.cellSize,
          getPosition = _props.getPosition;

      var _pointToDensityGridDa = pointToDensityGridData(data, cellSize, getPosition),
          layerData = _pointToDensityGridDa.layerData;

      this.setState({ layerData: layerData });
      this.getSortedBins();
    }
  }, {
    key: 'getValueDomain',
    value: function getValueDomain() {
      this.getColorValueDomain();
      this.getElevationValueDomain();
    }
  }, {
    key: 'getSortedBins',
    value: function getSortedBins() {
      this.getSortedColorBins();
      this.getSortedElevationBins();
    }
  }, {
    key: 'getSortedColorBins',
    value: function getSortedColorBins() {
      var getColorValue = this.props.getColorValue;

      var sortedColorBins = new BinSorter(this.state.layerData || [], getColorValue);

      this.setState({ sortedColorBins: sortedColorBins });
      this.getColorValueDomain();
    }
  }, {
    key: 'getSortedElevationBins',
    value: function getSortedElevationBins() {
      var getElevationValue = this.props.getElevationValue;

      var sortedElevationBins = new BinSorter(this.state.layerData || [], getElevationValue);
      this.setState({ sortedElevationBins: sortedElevationBins });
      this.getElevationValueDomain();
    }
  }, {
    key: 'getColorValueDomain',
    value: function getColorValueDomain() {
      var _props2 = this.props,
          lowerPercentile = _props2.lowerPercentile,
          upperPercentile = _props2.upperPercentile,
          onSetColorDomain = _props2.onSetColorDomain;


      this.state.colorValueDomain = this.state.sortedColorBins.getValueRange([lowerPercentile, upperPercentile]);

      if (typeof onSetColorDomain === 'function') {
        onSetColorDomain(this.state.colorValueDomain);
      }

      this.getColorScale();
    }
  }, {
    key: 'getElevationValueDomain',
    value: function getElevationValueDomain() {
      var _props3 = this.props,
          elevationLowerPercentile = _props3.elevationLowerPercentile,
          elevationUpperPercentile = _props3.elevationUpperPercentile,
          onSetElevationDomain = _props3.onSetElevationDomain;


      this.state.elevationValueDomain = this.state.sortedElevationBins.getValueRange([elevationLowerPercentile, elevationUpperPercentile]);

      if (typeof onSetElevationDomain === 'function') {
        onSetElevationDomain(this.state.elevationValueDomain);
      }

      this.getElevationScale();
    }
  }, {
    key: 'getColorScale',
    value: function getColorScale() {
      var colorRange = this.props.colorRange;

      var colorDomain = this.props.colorDomain || this.state.colorValueDomain;

      this.state.colorScaleFunc = getQuantizeScale(colorDomain, colorRange);
    }
  }, {
    key: 'getElevationScale',
    value: function getElevationScale() {
      var elevationRange = this.props.elevationRange;

      var elevationDomain = this.props.elevationDomain || this.state.elevationValueDomain;

      this.state.elevationScaleFunc = getLinearScale(elevationDomain, elevationRange);
    }
  }, {
    key: '_onGetSublayerColor',
    value: function _onGetSublayerColor(cell) {
      var _state2 = this.state,
          sortedColorBins = _state2.sortedColorBins,
          colorScaleFunc = _state2.colorScaleFunc,
          colorValueDomain = _state2.colorValueDomain;


      var cv = sortedColorBins.binMap[cell.index] && sortedColorBins.binMap[cell.index].value;
      var colorDomain = this.props.colorDomain || colorValueDomain;

      var isColorValueInDomain = cv >= colorDomain[0] && cv <= colorDomain[colorDomain.length - 1];

      // if cell value is outside domain, set alpha to 0
      var color = isColorValueInDomain ? colorScaleFunc(cv) : [0, 0, 0, 0];

      // add alpha to color if not defined in colorRange
      color[3] = Number.isFinite(color[3]) ? color[3] : 255;

      return color;
    }
  }, {
    key: '_onGetSublayerElevation',
    value: function _onGetSublayerElevation(cell) {
      var _state3 = this.state,
          sortedElevationBins = _state3.sortedElevationBins,
          elevationScaleFunc = _state3.elevationScaleFunc,
          elevationValueDomain = _state3.elevationValueDomain;

      var ev = sortedElevationBins.binMap[cell.index] && sortedElevationBins.binMap[cell.index].value;

      var elevationDomain = this.props.elevationDomain || elevationValueDomain;

      var isElevationValueInDomain = ev >= elevationDomain[0] && ev <= elevationDomain[elevationDomain.length - 1];

      // if cell value is outside domain, set elevation to -1
      return isElevationValueInDomain ? elevationScaleFunc(ev) : -1;
    }
  }, {
    key: 'getSubLayerProps',
    value: function getSubLayerProps() {
      // for subclassing, override this method to return
      // customized sub layer props
      var _props4 = this.props,
          id = _props4.id,
          elevationScale = _props4.elevationScale,
          fp64 = _props4.fp64,
          extruded = _props4.extruded,
          cellSize = _props4.cellSize,
          coverage = _props4.coverage,
          lightSettings = _props4.lightSettings;

      // base layer props

      var _props5 = this.props,
          opacity = _props5.opacity,
          pickable = _props5.pickable,
          visible = _props5.visible,
          getPolygonOffset = _props5.getPolygonOffset;

      // viewport props

      var _props6 = this.props,
          positionOrigin = _props6.positionOrigin,
          projectionMode = _props6.projectionMode,
          modelMatrix = _props6.modelMatrix;

      // return props to the sublayer constructor

      return {
        id: id + '-grid-cell',
        data: this.state.layerData,
        cellSize: cellSize,
        coverage: coverage,
        lightSettings: lightSettings,
        elevationScale: elevationScale,
        extruded: extruded,
        fp64: fp64,
        opacity: opacity,
        pickable: pickable,
        visible: visible,
        getPolygonOffset: getPolygonOffset,
        projectionMode: projectionMode,
        positionOrigin: positionOrigin,
        modelMatrix: modelMatrix,
        getColor: this._onGetSublayerColor.bind(this),
        getElevation: this._onGetSublayerElevation.bind(this),
        updateTriggers: this.getUpdateTriggers()
      };
    }
  }, {
    key: 'getSubLayerClass',
    value: function getSubLayerClass() {
      // for subclassing, override this method to return
      // customized sub layer class
      return GridCellLayer;
    }
  }, {
    key: 'renderLayers',
    value: function renderLayers() {
      var SubLayerClass = this.getSubLayerClass();

      return new SubLayerClass(this.getSubLayerProps());
    }
  }]);

  return GridLayer;
}(CompositeLayer);

export default GridLayer;


GridLayer.layerName = 'GridLayer';
GridLayer.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9ncmlkLWxheWVyL2dyaWQtbGF5ZXIuanMiXSwibmFtZXMiOlsiQ29tcG9zaXRlTGF5ZXIiLCJHcmlkQ2VsbExheWVyIiwicG9pbnRUb0RlbnNpdHlHcmlkRGF0YSIsImRlZmF1bHRDb2xvclJhbmdlIiwiZ2V0UXVhbnRpemVTY2FsZSIsImdldExpbmVhclNjYWxlIiwiQmluU29ydGVyIiwibm9wIiwiZGVmYXVsdFByb3BzIiwiY29sb3JEb21haW4iLCJjb2xvclJhbmdlIiwiZ2V0Q29sb3JWYWx1ZSIsInBvaW50cyIsImxlbmd0aCIsImxvd2VyUGVyY2VudGlsZSIsInVwcGVyUGVyY2VudGlsZSIsIm9uU2V0Q29sb3JEb21haW4iLCJlbGV2YXRpb25Eb21haW4iLCJlbGV2YXRpb25SYW5nZSIsImdldEVsZXZhdGlvblZhbHVlIiwiZWxldmF0aW9uTG93ZXJQZXJjZW50aWxlIiwiZWxldmF0aW9uVXBwZXJQZXJjZW50aWxlIiwiZWxldmF0aW9uU2NhbGUiLCJvblNldEVsZXZhdGlvbkRvbWFpbiIsImNlbGxTaXplIiwiY292ZXJhZ2UiLCJnZXRQb3NpdGlvbiIsIngiLCJwb3NpdGlvbiIsImV4dHJ1ZGVkIiwiZnA2NCIsImxpZ2h0U2V0dGluZ3MiLCJsaWdodHNQb3NpdGlvbiIsImFtYmllbnRSYXRpbyIsImRpZmZ1c2VSYXRpbyIsInNwZWN1bGFyUmF0aW8iLCJsaWdodHNTdHJlbmd0aCIsIm51bWJlck9mTGlnaHRzIiwiR3JpZExheWVyIiwic3RhdGUiLCJsYXllckRhdGEiLCJzb3J0ZWRDb2xvckJpbnMiLCJzb3J0ZWRFbGV2YXRpb25CaW5zIiwiY29sb3JWYWx1ZURvbWFpbiIsImVsZXZhdGlvblZhbHVlRG9tYWluIiwiY29sb3JTY2FsZUZ1bmMiLCJlbGV2YXRpb25TY2FsZUZ1bmMiLCJkaW1lbnNpb25VcGRhdGVycyIsImdldERpbWVuc2lvblVwZGF0ZXJzIiwib2xkUHJvcHMiLCJwcm9wcyIsImNoYW5nZUZsYWdzIiwiZGltZW5zaW9uQ2hhbmdlcyIsImdldERpbWVuc2lvbkNoYW5nZXMiLCJkYXRhQ2hhbmdlZCIsIm5lZWRzUmVQcm9qZWN0UG9pbnRzIiwiZ2V0TGF5ZXJEYXRhIiwiZm9yRWFjaCIsImYiLCJhcHBseSIsImdldENvbG9yIiwiaWQiLCJ0cmlnZ2VycyIsInVwZGF0ZXIiLCJnZXRTb3J0ZWRDb2xvckJpbnMiLCJnZXRDb2xvclZhbHVlRG9tYWluIiwiZ2V0Q29sb3JTY2FsZSIsImdldEVsZXZhdGlvbiIsImdldFNvcnRlZEVsZXZhdGlvbkJpbnMiLCJnZXRFbGV2YXRpb25WYWx1ZURvbWFpbiIsImdldEVsZXZhdGlvblNjYWxlIiwidXBkYXRlcnMiLCJkaW1lbnNpb25LZXkiLCJuZWVkVXBkYXRlIiwiZmluZCIsIml0ZW0iLCJzb21lIiwidCIsInB1c2giLCJpbmZvIiwiaXNQaWNrZWQiLCJwaWNrZWQiLCJpbmRleCIsIm9iamVjdCIsImNlbGwiLCJjb2xvclZhbHVlIiwiYmluTWFwIiwidmFsdWUiLCJlbGV2YXRpb25WYWx1ZSIsIk9iamVjdCIsImFzc2lnbiIsIkJvb2xlYW4iLCJ1cGRhdGVUcmlnZ2VycyIsInN0ZXAiLCJwcm9wIiwiZGF0YSIsInNldFN0YXRlIiwiZ2V0U29ydGVkQmlucyIsImdldFZhbHVlUmFuZ2UiLCJjdiIsImlzQ29sb3JWYWx1ZUluRG9tYWluIiwiY29sb3IiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsImV2IiwiaXNFbGV2YXRpb25WYWx1ZUluRG9tYWluIiwib3BhY2l0eSIsInBpY2thYmxlIiwidmlzaWJsZSIsImdldFBvbHlnb25PZmZzZXQiLCJwb3NpdGlvbk9yaWdpbiIsInByb2plY3Rpb25Nb2RlIiwibW9kZWxNYXRyaXgiLCJfb25HZXRTdWJsYXllckNvbG9yIiwiYmluZCIsIl9vbkdldFN1YmxheWVyRWxldmF0aW9uIiwiZ2V0VXBkYXRlVHJpZ2dlcnMiLCJTdWJMYXllckNsYXNzIiwiZ2V0U3ViTGF5ZXJDbGFzcyIsImdldFN1YkxheWVyUHJvcHMiLCJsYXllck5hbWUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUUEsY0FBUixRQUE2QixjQUE3QjtBQUNBLE9BQU9DLGFBQVAsTUFBMEIsb0NBQTFCOztBQUVBLFNBQVFDLHNCQUFSLFFBQXFDLG1CQUFyQztBQUNBLFNBQVFDLGlCQUFSLFFBQWdDLDRCQUFoQztBQUNBLFNBQVFDLGdCQUFSLEVBQTBCQyxjQUExQixRQUErQyw0QkFBL0M7O0FBRUEsT0FBT0MsU0FBUCxNQUFzQiwyQkFBdEI7O0FBRUEsU0FBU0MsR0FBVCxHQUFlLENBQUU7O0FBRWpCLElBQU1DLGVBQWU7O0FBRW5CO0FBQ0FDLGVBQWEsSUFITTtBQUluQkMsY0FBWVAsaUJBSk87QUFLbkJRLGlCQUFlO0FBQUEsV0FBVUMsT0FBT0MsTUFBakI7QUFBQSxHQUxJO0FBTW5CQyxtQkFBaUIsQ0FORTtBQU9uQkMsbUJBQWlCLEdBUEU7QUFRbkJDLG9CQUFrQlQsR0FSQzs7QUFVbkI7QUFDQVUsbUJBQWlCLElBWEU7QUFZbkJDLGtCQUFnQixDQUFDLENBQUQsRUFBSSxJQUFKLENBWkc7QUFhbkJDLHFCQUFtQjtBQUFBLFdBQVVQLE9BQU9DLE1BQWpCO0FBQUEsR0FiQTtBQWNuQk8sNEJBQTBCLENBZFA7QUFlbkJDLDRCQUEwQixHQWZQO0FBZ0JuQkMsa0JBQWdCLENBaEJHO0FBaUJuQkMsd0JBQXNCaEIsR0FqQkg7O0FBbUJuQjtBQUNBaUIsWUFBVSxJQXBCUztBQXFCbkJDLFlBQVUsQ0FyQlM7QUFzQm5CQyxlQUFhO0FBQUEsV0FBS0MsRUFBRUMsUUFBUDtBQUFBLEdBdEJNO0FBdUJuQkMsWUFBVSxLQXZCUztBQXdCbkJDLFFBQU0sS0F4QmE7QUF5Qm5CO0FBQ0FDLGlCQUFlO0FBQ2JDLG9CQUFnQixDQUFDLENBQUMsTUFBRixFQUFVLEtBQVYsRUFBaUIsSUFBakIsRUFBdUIsQ0FBQyxLQUF4QixFQUErQixLQUEvQixFQUFzQyxJQUF0QyxDQURIO0FBRWJDLGtCQUFjLElBRkQ7QUFHYkMsa0JBQWMsR0FIRDtBQUliQyxtQkFBZSxHQUpGO0FBS2JDLG9CQUFnQixDQUFDLEdBQUQsRUFBTSxHQUFOLEVBQVcsR0FBWCxFQUFnQixHQUFoQixDQUxIO0FBTWJDLG9CQUFnQjtBQU5IO0FBMUJJLENBQXJCOztJQW9DcUJDLFM7Ozs7Ozs7Ozs7O3NDQUNEO0FBQ2hCLFdBQUtDLEtBQUwsR0FBYTtBQUNYQyxtQkFBVyxFQURBO0FBRVhDLHlCQUFpQixJQUZOO0FBR1hDLDZCQUFxQixJQUhWO0FBSVhDLDBCQUFrQixJQUpQO0FBS1hDLDhCQUFzQixJQUxYO0FBTVhDLHdCQUFnQnRDLEdBTkw7QUFPWHVDLDRCQUFvQnZDLEdBUFQ7QUFRWHdDLDJCQUFtQixLQUFLQyxvQkFBTDtBQVJSLE9BQWI7QUFVRDs7O3NDQUUyQztBQUFBOztBQUFBLFVBQS9CQyxRQUErQixRQUEvQkEsUUFBK0I7QUFBQSxVQUFyQkMsS0FBcUIsUUFBckJBLEtBQXFCO0FBQUEsVUFBZEMsV0FBYyxRQUFkQSxXQUFjOztBQUMxQyxVQUFNQyxtQkFBbUIsS0FBS0MsbUJBQUwsQ0FBeUJKLFFBQXpCLEVBQW1DQyxLQUFuQyxDQUF6Qjs7QUFFQSxVQUFJQyxZQUFZRyxXQUFaLElBQTJCLEtBQUtDLG9CQUFMLENBQTBCTixRQUExQixFQUFvQ0MsS0FBcEMsQ0FBL0IsRUFBMkU7QUFDekU7QUFDQSxhQUFLTSxZQUFMO0FBQ0QsT0FIRCxNQUdPLElBQUlKLGdCQUFKLEVBQXNCO0FBQzNCQSx5QkFBaUJLLE9BQWpCLENBQXlCO0FBQUEsaUJBQUssT0FBT0MsQ0FBUCxLQUFhLFVBQWIsSUFBMkJBLEVBQUVDLEtBQUYsUUFBaEM7QUFBQSxTQUF6QjtBQUNEO0FBQ0Y7Ozt5Q0FFb0JWLFEsRUFBVUMsSyxFQUFPO0FBQ3BDLGFBQU9ELFNBQVN6QixRQUFULEtBQXNCMEIsTUFBTTFCLFFBQW5DO0FBQ0Q7OzsyQ0FFc0I7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFPO0FBQ0xvQyxrQkFBVSxDQUNSO0FBQ0VDLGNBQUksT0FETjtBQUVFQyxvQkFBVSxDQUFDLGVBQUQsQ0FGWjtBQUdFQyxtQkFBUyxLQUFLQztBQUhoQixTQURRLEVBS0w7QUFDREgsY0FBSSxRQURIO0FBRURDLG9CQUFVLENBQUMsaUJBQUQsRUFBb0IsaUJBQXBCLENBRlQ7QUFHREMsbUJBQVMsS0FBS0U7QUFIYixTQUxLLEVBU0w7QUFDREosY0FBSSxXQURIO0FBRURDLG9CQUFVLENBQUMsYUFBRCxFQUFnQixZQUFoQixDQUZUO0FBR0RDLG1CQUFTLEtBQUtHO0FBSGIsU0FUSyxDQURMO0FBZ0JMQyxzQkFBYyxDQUNaO0FBQ0VOLGNBQUksT0FETjtBQUVFQyxvQkFBVSxDQUFDLG1CQUFELENBRlo7QUFHRUMsbUJBQVMsS0FBS0s7QUFIaEIsU0FEWSxFQUtUO0FBQ0RQLGNBQUksUUFESDtBQUVEQyxvQkFBVSxDQUFDLDBCQUFELEVBQTZCLDBCQUE3QixDQUZUO0FBR0RDLG1CQUFTLEtBQUtNO0FBSGIsU0FMUyxFQVNUO0FBQ0RSLGNBQUksV0FESDtBQUVEQyxvQkFBVSxDQUFDLGlCQUFELEVBQW9CLGdCQUFwQixDQUZUO0FBR0RDLG1CQUFTLEtBQUtPO0FBSGIsU0FUUztBQWhCVCxPQUFQO0FBZ0NEOzs7d0NBRW1CckIsUSxFQUFVQyxLLEVBQU87QUFBQSxVQUM1QkgsaUJBRDRCLEdBQ1AsS0FBS1IsS0FERSxDQUM1QlEsaUJBRDRCOztBQUVuQyxVQUFNd0IsV0FBVyxFQUFqQjs7QUFFQTtBQUNBLFdBQUssSUFBTUMsWUFBWCxJQUEyQnpCLGlCQUEzQixFQUE4Qzs7QUFFNUM7QUFDQSxZQUFNMEIsYUFBYTFCLGtCQUFrQnlCLFlBQWxCLEVBQ2hCRSxJQURnQixDQUNYO0FBQUEsaUJBQVFDLEtBQUtiLFFBQUwsQ0FBY2MsSUFBZCxDQUFtQjtBQUFBLG1CQUFLM0IsU0FBUzRCLENBQVQsTUFBZ0IzQixNQUFNMkIsQ0FBTixDQUFyQjtBQUFBLFdBQW5CLENBQVI7QUFBQSxTQURXLENBQW5COztBQUdBLFlBQUlKLFVBQUosRUFBZ0I7QUFDZEYsbUJBQVNPLElBQVQsQ0FBY0wsV0FBV1YsT0FBekI7QUFDRDtBQUNGOztBQUVELGFBQU9RLFNBQVMxRCxNQUFULEdBQWtCMEQsUUFBbEIsR0FBNkIsSUFBcEM7QUFDRDs7OzBDQUVzQjtBQUFBLFVBQVBRLElBQU8sU0FBUEEsSUFBTztBQUFBLG1CQUMwQixLQUFLeEMsS0FEL0I7QUFBQSxVQUNkRSxlQURjLFVBQ2RBLGVBRGM7QUFBQSxVQUNHQyxtQkFESCxVQUNHQSxtQkFESDs7O0FBR3JCLFVBQU1zQyxXQUFXRCxLQUFLRSxNQUFMLElBQWVGLEtBQUtHLEtBQUwsR0FBYSxDQUFDLENBQTlDO0FBQ0EsVUFBSUMsU0FBUyxJQUFiOztBQUVBLFVBQUlILFFBQUosRUFBYztBQUNaLFlBQU1JLE9BQU8sS0FBSzdDLEtBQUwsQ0FBV0MsU0FBWCxDQUFxQnVDLEtBQUtHLEtBQTFCLENBQWI7O0FBRUEsWUFBTUcsYUFBYTVDLGdCQUFnQjZDLE1BQWhCLENBQXVCRixLQUFLRixLQUE1QixLQUNqQnpDLGdCQUFnQjZDLE1BQWhCLENBQXVCRixLQUFLRixLQUE1QixFQUFtQ0ssS0FEckM7QUFFQSxZQUFNQyxpQkFBaUI5QyxvQkFBb0I0QyxNQUFwQixDQUEyQkYsS0FBS0YsS0FBaEMsS0FDckJ4QyxvQkFBb0I0QyxNQUFwQixDQUEyQkYsS0FBS0YsS0FBaEMsRUFBdUNLLEtBRHpDOztBQUdBSixpQkFBU00sT0FBT0MsTUFBUCxDQUFjO0FBQ3JCTCxnQ0FEcUI7QUFFckJHO0FBRnFCLFNBQWQsRUFHTkosSUFITSxDQUFUO0FBSUQ7O0FBRUQ7QUFDQSxhQUFPSyxPQUFPQyxNQUFQLENBQWNYLElBQWQsRUFBb0I7QUFDekJFLGdCQUFRVSxRQUFRUixNQUFSLENBRGlCO0FBRXpCO0FBQ0FBO0FBSHlCLE9BQXBCLENBQVA7QUFLRDs7O3dDQUVtQjtBQUFBOztBQUFBLFVBQ1hwQyxpQkFEVyxHQUNVLEtBQUtSLEtBRGYsQ0FDWFEsaUJBRFc7O0FBR2xCOztBQUNBLFVBQU02QyxpQkFBaUIsRUFBdkI7O0FBSmtCLGlDQU1QcEIsWUFOTzs7QUFRaEJvQix1QkFBZXBCLFlBQWYsSUFBK0IsRUFBL0I7O0FBUmdCO0FBQUE7QUFBQTs7QUFBQTtBQVVoQiwrQkFBbUJ6QixrQkFBa0J5QixZQUFsQixDQUFuQiw4SEFBb0Q7QUFBQSxnQkFBekNxQixJQUF5Qzs7O0FBRWxEQSxpQkFBSy9CLFFBQUwsQ0FBY0wsT0FBZCxDQUFzQixnQkFBUTtBQUM1Qm1DLDZCQUFlcEIsWUFBZixFQUE2QnNCLElBQTdCLElBQXFDLE9BQUs1QyxLQUFMLENBQVc0QyxJQUFYLENBQXJDO0FBQ0QsYUFGRDtBQUlEO0FBaEJlO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFNbEIsV0FBSyxJQUFNdEIsWUFBWCxJQUEyQnpCLGlCQUEzQixFQUE4QztBQUFBLGNBQW5DeUIsWUFBbUM7QUFXN0M7O0FBRUQsYUFBT29CLGNBQVA7QUFDRDs7O21DQUVjO0FBQUEsbUJBQ3lCLEtBQUsxQyxLQUQ5QjtBQUFBLFVBQ042QyxJQURNLFVBQ05BLElBRE07QUFBQSxVQUNBdkUsUUFEQSxVQUNBQSxRQURBO0FBQUEsVUFDVUUsV0FEVixVQUNVQSxXQURWOztBQUFBLGtDQUVPeEIsdUJBQXVCNkYsSUFBdkIsRUFBNkJ2RSxRQUE3QixFQUF1Q0UsV0FBdkMsQ0FGUDtBQUFBLFVBRU5jLFNBRk0seUJBRU5BLFNBRk07O0FBSWIsV0FBS3dELFFBQUwsQ0FBYyxFQUFDeEQsb0JBQUQsRUFBZDtBQUNBLFdBQUt5RCxhQUFMO0FBQ0Q7OztxQ0FFZ0I7QUFDZixXQUFLaEMsbUJBQUw7QUFDQSxXQUFLSSx1QkFBTDtBQUNEOzs7b0NBRWU7QUFDZCxXQUFLTCxrQkFBTDtBQUNBLFdBQUtJLHNCQUFMO0FBQ0Q7Ozt5Q0FFb0I7QUFBQSxVQUNaekQsYUFEWSxHQUNLLEtBQUt1QyxLQURWLENBQ1p2QyxhQURZOztBQUVuQixVQUFNOEIsa0JBQWtCLElBQUluQyxTQUFKLENBQWMsS0FBS2lDLEtBQUwsQ0FBV0MsU0FBWCxJQUF3QixFQUF0QyxFQUEwQzdCLGFBQTFDLENBQXhCOztBQUVBLFdBQUtxRixRQUFMLENBQWMsRUFBQ3ZELGdDQUFELEVBQWQ7QUFDQSxXQUFLd0IsbUJBQUw7QUFDRDs7OzZDQUV3QjtBQUFBLFVBQ2hCOUMsaUJBRGdCLEdBQ0ssS0FBSytCLEtBRFYsQ0FDaEIvQixpQkFEZ0I7O0FBRXZCLFVBQU11QixzQkFBc0IsSUFBSXBDLFNBQUosQ0FBYyxLQUFLaUMsS0FBTCxDQUFXQyxTQUFYLElBQXdCLEVBQXRDLEVBQTBDckIsaUJBQTFDLENBQTVCO0FBQ0EsV0FBSzZFLFFBQUwsQ0FBYyxFQUFDdEQsd0NBQUQsRUFBZDtBQUNBLFdBQUsyQix1QkFBTDtBQUNEOzs7MENBRXFCO0FBQUEsb0JBQ3lDLEtBQUtuQixLQUQ5QztBQUFBLFVBQ2JwQyxlQURhLFdBQ2JBLGVBRGE7QUFBQSxVQUNJQyxlQURKLFdBQ0lBLGVBREo7QUFBQSxVQUNxQkMsZ0JBRHJCLFdBQ3FCQSxnQkFEckI7OztBQUdwQixXQUFLdUIsS0FBTCxDQUFXSSxnQkFBWCxHQUE4QixLQUFLSixLQUFMLENBQVdFLGVBQVgsQ0FDM0J5RCxhQUQyQixDQUNiLENBQUNwRixlQUFELEVBQWtCQyxlQUFsQixDQURhLENBQTlCOztBQUdBLFVBQUksT0FBT0MsZ0JBQVAsS0FBNEIsVUFBaEMsRUFBNEM7QUFDMUNBLHlCQUFpQixLQUFLdUIsS0FBTCxDQUFXSSxnQkFBNUI7QUFDRDs7QUFFRCxXQUFLdUIsYUFBTDtBQUNEOzs7OENBRXlCO0FBQUEsb0JBQzJELEtBQUtoQixLQURoRTtBQUFBLFVBQ2pCOUIsd0JBRGlCLFdBQ2pCQSx3QkFEaUI7QUFBQSxVQUNTQyx3QkFEVCxXQUNTQSx3QkFEVDtBQUFBLFVBQ21DRSxvQkFEbkMsV0FDbUNBLG9CQURuQzs7O0FBR3hCLFdBQUtnQixLQUFMLENBQVdLLG9CQUFYLEdBQWtDLEtBQUtMLEtBQUwsQ0FBV0csbUJBQVgsQ0FDL0J3RCxhQUQrQixDQUNqQixDQUFDOUUsd0JBQUQsRUFBMkJDLHdCQUEzQixDQURpQixDQUFsQzs7QUFHQSxVQUFJLE9BQU9FLG9CQUFQLEtBQWdDLFVBQXBDLEVBQWdEO0FBQzlDQSw2QkFBcUIsS0FBS2dCLEtBQUwsQ0FBV0ssb0JBQWhDO0FBQ0Q7O0FBRUQsV0FBSzBCLGlCQUFMO0FBQ0Q7OztvQ0FFZTtBQUFBLFVBQ1A1RCxVQURPLEdBQ08sS0FBS3dDLEtBRFosQ0FDUHhDLFVBRE87O0FBRWQsVUFBTUQsY0FBYyxLQUFLeUMsS0FBTCxDQUFXekMsV0FBWCxJQUEwQixLQUFLOEIsS0FBTCxDQUFXSSxnQkFBekQ7O0FBRUEsV0FBS0osS0FBTCxDQUFXTSxjQUFYLEdBQTRCekMsaUJBQWlCSyxXQUFqQixFQUE4QkMsVUFBOUIsQ0FBNUI7QUFDRDs7O3dDQUVtQjtBQUFBLFVBQ1hRLGNBRFcsR0FDTyxLQUFLZ0MsS0FEWixDQUNYaEMsY0FEVzs7QUFFbEIsVUFBTUQsa0JBQWtCLEtBQUtpQyxLQUFMLENBQVdqQyxlQUFYLElBQThCLEtBQUtzQixLQUFMLENBQVdLLG9CQUFqRTs7QUFFQSxXQUFLTCxLQUFMLENBQVdPLGtCQUFYLEdBQWdDekMsZUFBZVksZUFBZixFQUFnQ0MsY0FBaEMsQ0FBaEM7QUFDRDs7O3dDQUVtQmtFLEksRUFBTTtBQUFBLG9CQUNvQyxLQUFLN0MsS0FEekM7QUFBQSxVQUNqQkUsZUFEaUIsV0FDakJBLGVBRGlCO0FBQUEsVUFDQUksY0FEQSxXQUNBQSxjQURBO0FBQUEsVUFDZ0JGLGdCQURoQixXQUNnQkEsZ0JBRGhCOzs7QUFHeEIsVUFBTXdELEtBQUsxRCxnQkFBZ0I2QyxNQUFoQixDQUF1QkYsS0FBS0YsS0FBNUIsS0FBc0N6QyxnQkFBZ0I2QyxNQUFoQixDQUF1QkYsS0FBS0YsS0FBNUIsRUFBbUNLLEtBQXBGO0FBQ0EsVUFBTTlFLGNBQWMsS0FBS3lDLEtBQUwsQ0FBV3pDLFdBQVgsSUFBMEJrQyxnQkFBOUM7O0FBRUEsVUFBTXlELHVCQUF1QkQsTUFBTTFGLFlBQVksQ0FBWixDQUFOLElBQXdCMEYsTUFBTTFGLFlBQVlBLFlBQVlJLE1BQVosR0FBcUIsQ0FBakMsQ0FBM0Q7O0FBRUE7QUFDQSxVQUFNd0YsUUFBUUQsdUJBQXVCdkQsZUFBZXNELEVBQWYsQ0FBdkIsR0FBNEMsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLENBQTFEOztBQUVBO0FBQ0FFLFlBQU0sQ0FBTixJQUFXQyxPQUFPQyxRQUFQLENBQWdCRixNQUFNLENBQU4sQ0FBaEIsSUFBNEJBLE1BQU0sQ0FBTixDQUE1QixHQUF1QyxHQUFsRDs7QUFFQSxhQUFPQSxLQUFQO0FBQ0Q7Ozs0Q0FFdUJqQixJLEVBQU07QUFBQSxvQkFDNEMsS0FBSzdDLEtBRGpEO0FBQUEsVUFDckJHLG1CQURxQixXQUNyQkEsbUJBRHFCO0FBQUEsVUFDQUksa0JBREEsV0FDQUEsa0JBREE7QUFBQSxVQUNvQkYsb0JBRHBCLFdBQ29CQSxvQkFEcEI7O0FBRTVCLFVBQU00RCxLQUFLOUQsb0JBQW9CNEMsTUFBcEIsQ0FBMkJGLEtBQUtGLEtBQWhDLEtBQ1R4QyxvQkFBb0I0QyxNQUFwQixDQUEyQkYsS0FBS0YsS0FBaEMsRUFBdUNLLEtBRHpDOztBQUdBLFVBQU10RSxrQkFBa0IsS0FBS2lDLEtBQUwsQ0FBV2pDLGVBQVgsSUFBOEIyQixvQkFBdEQ7O0FBRUEsVUFBTTZELDJCQUEyQkQsTUFBTXZGLGdCQUFnQixDQUFoQixDQUFOLElBQy9CdUYsTUFBTXZGLGdCQUFnQkEsZ0JBQWdCSixNQUFoQixHQUF5QixDQUF6QyxDQURSOztBQUdBO0FBQ0EsYUFBTzRGLDJCQUEyQjNELG1CQUFtQjBELEVBQW5CLENBQTNCLEdBQW9ELENBQUMsQ0FBNUQ7QUFDRDs7O3VDQUVrQjtBQUNqQjtBQUNBO0FBRmlCLG9CQUcrRCxLQUFLdEQsS0FIcEU7QUFBQSxVQUdWVyxFQUhVLFdBR1ZBLEVBSFU7QUFBQSxVQUdOdkMsY0FITSxXQUdOQSxjQUhNO0FBQUEsVUFHVVEsSUFIVixXQUdVQSxJQUhWO0FBQUEsVUFHZ0JELFFBSGhCLFdBR2dCQSxRQUhoQjtBQUFBLFVBRzBCTCxRQUgxQixXQUcwQkEsUUFIMUI7QUFBQSxVQUdvQ0MsUUFIcEMsV0FHb0NBLFFBSHBDO0FBQUEsVUFHOENNLGFBSDlDLFdBRzhDQSxhQUg5Qzs7QUFLakI7O0FBTGlCLG9CQU1zQyxLQUFLbUIsS0FOM0M7QUFBQSxVQU1Wd0QsT0FOVSxXQU1WQSxPQU5VO0FBQUEsVUFNREMsUUFOQyxXQU1EQSxRQU5DO0FBQUEsVUFNU0MsT0FOVCxXQU1TQSxPQU5UO0FBQUEsVUFNa0JDLGdCQU5sQixXQU1rQkEsZ0JBTmxCOztBQVFqQjs7QUFSaUIsb0JBU3FDLEtBQUszRCxLQVQxQztBQUFBLFVBU1Y0RCxjQVRVLFdBU1ZBLGNBVFU7QUFBQSxVQVNNQyxjQVROLFdBU01BLGNBVE47QUFBQSxVQVNzQkMsV0FUdEIsV0FTc0JBLFdBVHRCOztBQVdqQjs7QUFDQSxhQUFPO0FBQ0xuRCxZQUFPQSxFQUFQLGVBREs7QUFFTGtDLGNBQU0sS0FBS3hELEtBQUwsQ0FBV0MsU0FGWjtBQUdMaEIsMEJBSEs7QUFJTEMsMEJBSks7QUFLTE0sb0NBTEs7QUFNTFQsc0NBTks7QUFPTE8sMEJBUEs7QUFRTEMsa0JBUks7QUFTTDRFLHdCQVRLO0FBVUxDLDBCQVZLO0FBV0xDLHdCQVhLO0FBWUxDLDBDQVpLO0FBYUxFLHNDQWJLO0FBY0xELHNDQWRLO0FBZUxFLGdDQWZLO0FBZ0JMcEQsa0JBQVUsS0FBS3FELG1CQUFMLENBQXlCQyxJQUF6QixDQUE4QixJQUE5QixDQWhCTDtBQWlCTC9DLHNCQUFjLEtBQUtnRCx1QkFBTCxDQUE2QkQsSUFBN0IsQ0FBa0MsSUFBbEMsQ0FqQlQ7QUFrQkx0Qix3QkFBZ0IsS0FBS3dCLGlCQUFMO0FBbEJYLE9BQVA7QUFvQkQ7Ozt1Q0FFa0I7QUFDakI7QUFDQTtBQUNBLGFBQU9uSCxhQUFQO0FBQ0Q7OzttQ0FFYztBQUNiLFVBQU1vSCxnQkFBZ0IsS0FBS0MsZ0JBQUwsRUFBdEI7O0FBRUEsYUFBTyxJQUFJRCxhQUFKLENBQ0wsS0FBS0UsZ0JBQUwsRUFESyxDQUFQO0FBR0Q7Ozs7RUEvUm9DdkgsYzs7ZUFBbEJzQyxTOzs7QUFrU3JCQSxVQUFVa0YsU0FBVixHQUFzQixXQUF0QjtBQUNBbEYsVUFBVTlCLFlBQVYsR0FBeUJBLFlBQXpCIiwiZmlsZSI6ImdyaWQtbGF5ZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHtDb21wb3NpdGVMYXllcn0gZnJvbSAnLi4vLi4vLi4vbGliJztcbmltcG9ydCBHcmlkQ2VsbExheWVyIGZyb20gJy4uL2dyaWQtY2VsbC1sYXllci9ncmlkLWNlbGwtbGF5ZXInO1xuXG5pbXBvcnQge3BvaW50VG9EZW5zaXR5R3JpZERhdGF9IGZyb20gJy4vZ3JpZC1hZ2dyZWdhdG9yJztcbmltcG9ydCB7ZGVmYXVsdENvbG9yUmFuZ2V9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2NvbG9yLXV0aWxzJztcbmltcG9ydCB7Z2V0UXVhbnRpemVTY2FsZSwgZ2V0TGluZWFyU2NhbGV9IGZyb20gJy4uLy4uLy4uL3V0aWxzL3NjYWxlLXV0aWxzJztcblxuaW1wb3J0IEJpblNvcnRlciBmcm9tICcuLi8uLi8uLi91dGlscy9iaW4tc29ydGVyJztcblxuZnVuY3Rpb24gbm9wKCkge31cblxuY29uc3QgZGVmYXVsdFByb3BzID0ge1xuXG4gIC8vIGNvbG9yXG4gIGNvbG9yRG9tYWluOiBudWxsLFxuICBjb2xvclJhbmdlOiBkZWZhdWx0Q29sb3JSYW5nZSxcbiAgZ2V0Q29sb3JWYWx1ZTogcG9pbnRzID0+IHBvaW50cy5sZW5ndGgsXG4gIGxvd2VyUGVyY2VudGlsZTogMCxcbiAgdXBwZXJQZXJjZW50aWxlOiAxMDAsXG4gIG9uU2V0Q29sb3JEb21haW46IG5vcCxcblxuICAvLyBlbGV2YXRpb25cbiAgZWxldmF0aW9uRG9tYWluOiBudWxsLFxuICBlbGV2YXRpb25SYW5nZTogWzAsIDEwMDBdLFxuICBnZXRFbGV2YXRpb25WYWx1ZTogcG9pbnRzID0+IHBvaW50cy5sZW5ndGgsXG4gIGVsZXZhdGlvbkxvd2VyUGVyY2VudGlsZTogMCxcbiAgZWxldmF0aW9uVXBwZXJQZXJjZW50aWxlOiAxMDAsXG4gIGVsZXZhdGlvblNjYWxlOiAxLFxuICBvblNldEVsZXZhdGlvbkRvbWFpbjogbm9wLFxuXG4gIC8vIGdyaWRcbiAgY2VsbFNpemU6IDEwMDAsXG4gIGNvdmVyYWdlOiAxLFxuICBnZXRQb3NpdGlvbjogeCA9PiB4LnBvc2l0aW9uLFxuICBleHRydWRlZDogZmFsc2UsXG4gIGZwNjQ6IGZhbHNlLFxuICAvLyBPcHRpb25hbCBzZXR0aW5ncyBmb3IgJ2xpZ2h0aW5nJyBzaGFkZXIgbW9kdWxlXG4gIGxpZ2h0U2V0dGluZ3M6IHtcbiAgICBsaWdodHNQb3NpdGlvbjogWy0xMjIuNDUsIDM3Ljc1LCA4MDAwLCAtMTIyLjAsIDM4LjAwLCA1MDAwXSxcbiAgICBhbWJpZW50UmF0aW86IDAuMDUsXG4gICAgZGlmZnVzZVJhdGlvOiAwLjYsXG4gICAgc3BlY3VsYXJSYXRpbzogMC44LFxuICAgIGxpZ2h0c1N0cmVuZ3RoOiBbMi4wLCAwLjAsIDAuMCwgMC4wXSxcbiAgICBudW1iZXJPZkxpZ2h0czogMlxuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHcmlkTGF5ZXIgZXh0ZW5kcyBDb21wb3NpdGVMYXllciB7XG4gIGluaXRpYWxpemVTdGF0ZSgpIHtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgbGF5ZXJEYXRhOiBbXSxcbiAgICAgIHNvcnRlZENvbG9yQmluczogbnVsbCxcbiAgICAgIHNvcnRlZEVsZXZhdGlvbkJpbnM6IG51bGwsXG4gICAgICBjb2xvclZhbHVlRG9tYWluOiBudWxsLFxuICAgICAgZWxldmF0aW9uVmFsdWVEb21haW46IG51bGwsXG4gICAgICBjb2xvclNjYWxlRnVuYzogbm9wLFxuICAgICAgZWxldmF0aW9uU2NhbGVGdW5jOiBub3AsXG4gICAgICBkaW1lbnNpb25VcGRhdGVyczogdGhpcy5nZXREaW1lbnNpb25VcGRhdGVycygpXG4gICAgfTtcbiAgfVxuXG4gIHVwZGF0ZVN0YXRlKHtvbGRQcm9wcywgcHJvcHMsIGNoYW5nZUZsYWdzfSkge1xuICAgIGNvbnN0IGRpbWVuc2lvbkNoYW5nZXMgPSB0aGlzLmdldERpbWVuc2lvbkNoYW5nZXMob2xkUHJvcHMsIHByb3BzKTtcblxuICAgIGlmIChjaGFuZ2VGbGFncy5kYXRhQ2hhbmdlZCB8fCB0aGlzLm5lZWRzUmVQcm9qZWN0UG9pbnRzKG9sZFByb3BzLCBwcm9wcykpIHtcbiAgICAgIC8vIHByb2plY3QgZGF0YSBpbnRvIGhleGFnb25zLCBhbmQgZ2V0IHNvcnRlZEJpbnNcbiAgICAgIHRoaXMuZ2V0TGF5ZXJEYXRhKCk7XG4gICAgfSBlbHNlIGlmIChkaW1lbnNpb25DaGFuZ2VzKSB7XG4gICAgICBkaW1lbnNpb25DaGFuZ2VzLmZvckVhY2goZiA9PiB0eXBlb2YgZiA9PT0gJ2Z1bmN0aW9uJyAmJiBmLmFwcGx5KHRoaXMpKTtcbiAgICB9XG4gIH1cblxuICBuZWVkc1JlUHJvamVjdFBvaW50cyhvbGRQcm9wcywgcHJvcHMpIHtcbiAgICByZXR1cm4gb2xkUHJvcHMuY2VsbFNpemUgIT09IHByb3BzLmNlbGxTaXplO1xuICB9XG5cbiAgZ2V0RGltZW5zaW9uVXBkYXRlcnMoKSB7XG4gICAgLy8gZGltZW5zaW9uIHVwZGF0ZXJzIGFyZSBzZXF1ZW50aWFsLFxuICAgIC8vIGlmIHRoZSBmaXJzdCBvbmUgbmVlZHMgdG8gYmUgY2FsbGVkLCB0aGUgMm5kIGFuZCAzcmQgb25lIHdpbGwgYXV0b21hdGljYWxseVxuICAgIC8vIGJlIGNhbGxlZC4gZS5nLiBpZiBDb2xvclZhbHVlIG5lZWRzIHRvIGJlIHVwZGF0ZWQsIGdldENvbG9yVmFsdWVEb21haW4gYW5kIGdldENvbG9yU2NhbGVcbiAgICAvLyB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgY2FsbGVkXG4gICAgcmV0dXJuIHtcbiAgICAgIGdldENvbG9yOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogJ3ZhbHVlJyxcbiAgICAgICAgICB0cmlnZ2VyczogWydnZXRDb2xvclZhbHVlJ10sXG4gICAgICAgICAgdXBkYXRlcjogdGhpcy5nZXRTb3J0ZWRDb2xvckJpbnNcbiAgICAgICAgfSwge1xuICAgICAgICAgIGlkOiAnZG9tYWluJyxcbiAgICAgICAgICB0cmlnZ2VyczogWydsb3dlclBlcmNlbnRpbGUnLCAndXBwZXJQZXJjZW50aWxlJ10sXG4gICAgICAgICAgdXBkYXRlcjogdGhpcy5nZXRDb2xvclZhbHVlRG9tYWluXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBpZDogJ3NjYWxlRnVuYycsXG4gICAgICAgICAgdHJpZ2dlcnM6IFsnY29sb3JEb21haW4nLCAnY29sb3JSYW5nZSddLFxuICAgICAgICAgIHVwZGF0ZXI6IHRoaXMuZ2V0Q29sb3JTY2FsZVxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgZ2V0RWxldmF0aW9uOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogJ3ZhbHVlJyxcbiAgICAgICAgICB0cmlnZ2VyczogWydnZXRFbGV2YXRpb25WYWx1ZSddLFxuICAgICAgICAgIHVwZGF0ZXI6IHRoaXMuZ2V0U29ydGVkRWxldmF0aW9uQmluc1xuICAgICAgICB9LCB7XG4gICAgICAgICAgaWQ6ICdkb21haW4nLFxuICAgICAgICAgIHRyaWdnZXJzOiBbJ2VsZXZhdGlvbkxvd2VyUGVyY2VudGlsZScsICdlbGV2YXRpb25VcHBlclBlcmNlbnRpbGUnXSxcbiAgICAgICAgICB1cGRhdGVyOiB0aGlzLmdldEVsZXZhdGlvblZhbHVlRG9tYWluXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBpZDogJ3NjYWxlRnVuYycsXG4gICAgICAgICAgdHJpZ2dlcnM6IFsnZWxldmF0aW9uRG9tYWluJywgJ2VsZXZhdGlvblJhbmdlJ10sXG4gICAgICAgICAgdXBkYXRlcjogdGhpcy5nZXRFbGV2YXRpb25TY2FsZVxuICAgICAgICB9XG4gICAgICBdXG4gICAgfTtcbiAgfVxuXG4gIGdldERpbWVuc2lvbkNoYW5nZXMob2xkUHJvcHMsIHByb3BzKSB7XG4gICAgY29uc3Qge2RpbWVuc2lvblVwZGF0ZXJzfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgdXBkYXRlcnMgPSBbXTtcblxuICAgIC8vIGdldCBkaW1lbnNpb24gdG8gYmUgdXBkYXRlZFxuICAgIGZvciAoY29uc3QgZGltZW5zaW9uS2V5IGluIGRpbWVuc2lvblVwZGF0ZXJzKSB7XG5cbiAgICAgIC8vIHJldHVybiB0aGUgZmlyc3QgdHJpZ2dlcmVkIHVwZGF0ZXIgZm9yIGVhY2ggZGltZW5zaW9uXG4gICAgICBjb25zdCBuZWVkVXBkYXRlID0gZGltZW5zaW9uVXBkYXRlcnNbZGltZW5zaW9uS2V5XVxuICAgICAgICAuZmluZChpdGVtID0+IGl0ZW0udHJpZ2dlcnMuc29tZSh0ID0+IG9sZFByb3BzW3RdICE9PSBwcm9wc1t0XSkpO1xuXG4gICAgICBpZiAobmVlZFVwZGF0ZSkge1xuICAgICAgICB1cGRhdGVycy5wdXNoKG5lZWRVcGRhdGUudXBkYXRlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHVwZGF0ZXJzLmxlbmd0aCA/IHVwZGF0ZXJzIDogbnVsbDtcbiAgfVxuXG4gIGdldFBpY2tpbmdJbmZvKHtpbmZvfSkge1xuICAgIGNvbnN0IHtzb3J0ZWRDb2xvckJpbnMsIHNvcnRlZEVsZXZhdGlvbkJpbnN9ID0gdGhpcy5zdGF0ZTtcblxuICAgIGNvbnN0IGlzUGlja2VkID0gaW5mby5waWNrZWQgJiYgaW5mby5pbmRleCA+IC0xO1xuICAgIGxldCBvYmplY3QgPSBudWxsO1xuXG4gICAgaWYgKGlzUGlja2VkKSB7XG4gICAgICBjb25zdCBjZWxsID0gdGhpcy5zdGF0ZS5sYXllckRhdGFbaW5mby5pbmRleF07XG5cbiAgICAgIGNvbnN0IGNvbG9yVmFsdWUgPSBzb3J0ZWRDb2xvckJpbnMuYmluTWFwW2NlbGwuaW5kZXhdICYmXG4gICAgICAgIHNvcnRlZENvbG9yQmlucy5iaW5NYXBbY2VsbC5pbmRleF0udmFsdWU7XG4gICAgICBjb25zdCBlbGV2YXRpb25WYWx1ZSA9IHNvcnRlZEVsZXZhdGlvbkJpbnMuYmluTWFwW2NlbGwuaW5kZXhdICYmXG4gICAgICAgIHNvcnRlZEVsZXZhdGlvbkJpbnMuYmluTWFwW2NlbGwuaW5kZXhdLnZhbHVlO1xuXG4gICAgICBvYmplY3QgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgY29sb3JWYWx1ZSxcbiAgICAgICAgZWxldmF0aW9uVmFsdWVcbiAgICAgIH0sIGNlbGwpO1xuICAgIH1cblxuICAgIC8vIGFkZCBiaW4gY29sb3JWYWx1ZSBhbmQgZWxldmF0aW9uVmFsdWUgdG8gaW5mb1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGluZm8sIHtcbiAgICAgIHBpY2tlZDogQm9vbGVhbihvYmplY3QpLFxuICAgICAgLy8gb3ZlcnJpZGUgb2JqZWN0IHdpdGggcGlja2VkIGNlbGxcbiAgICAgIG9iamVjdFxuICAgIH0pO1xuICB9XG5cbiAgZ2V0VXBkYXRlVHJpZ2dlcnMoKSB7XG4gICAgY29uc3Qge2RpbWVuc2lvblVwZGF0ZXJzfSA9IHRoaXMuc3RhdGU7XG5cbiAgICAvLyBtZXJnZSBhbGwgZGltZW5zaW9uIHRyaWdnZXJzXG4gICAgY29uc3QgdXBkYXRlVHJpZ2dlcnMgPSB7fTtcblxuICAgIGZvciAoY29uc3QgZGltZW5zaW9uS2V5IGluIGRpbWVuc2lvblVwZGF0ZXJzKSB7XG5cbiAgICAgIHVwZGF0ZVRyaWdnZXJzW2RpbWVuc2lvbktleV0gPSB7fTtcblxuICAgICAgZm9yIChjb25zdCBzdGVwIG9mIGRpbWVuc2lvblVwZGF0ZXJzW2RpbWVuc2lvbktleV0pIHtcblxuICAgICAgICBzdGVwLnRyaWdnZXJzLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICAgICAgdXBkYXRlVHJpZ2dlcnNbZGltZW5zaW9uS2V5XVtwcm9wXSA9IHRoaXMucHJvcHNbcHJvcF07XG4gICAgICAgIH0pO1xuXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHVwZGF0ZVRyaWdnZXJzO1xuICB9XG5cbiAgZ2V0TGF5ZXJEYXRhKCkge1xuICAgIGNvbnN0IHtkYXRhLCBjZWxsU2l6ZSwgZ2V0UG9zaXRpb259ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7bGF5ZXJEYXRhfSA9IHBvaW50VG9EZW5zaXR5R3JpZERhdGEoZGF0YSwgY2VsbFNpemUsIGdldFBvc2l0aW9uKTtcblxuICAgIHRoaXMuc2V0U3RhdGUoe2xheWVyRGF0YX0pO1xuICAgIHRoaXMuZ2V0U29ydGVkQmlucygpO1xuICB9XG5cbiAgZ2V0VmFsdWVEb21haW4oKSB7XG4gICAgdGhpcy5nZXRDb2xvclZhbHVlRG9tYWluKCk7XG4gICAgdGhpcy5nZXRFbGV2YXRpb25WYWx1ZURvbWFpbigpO1xuICB9XG5cbiAgZ2V0U29ydGVkQmlucygpIHtcbiAgICB0aGlzLmdldFNvcnRlZENvbG9yQmlucygpO1xuICAgIHRoaXMuZ2V0U29ydGVkRWxldmF0aW9uQmlucygpO1xuICB9XG5cbiAgZ2V0U29ydGVkQ29sb3JCaW5zKCkge1xuICAgIGNvbnN0IHtnZXRDb2xvclZhbHVlfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qgc29ydGVkQ29sb3JCaW5zID0gbmV3IEJpblNvcnRlcih0aGlzLnN0YXRlLmxheWVyRGF0YSB8fCBbXSwgZ2V0Q29sb3JWYWx1ZSk7XG5cbiAgICB0aGlzLnNldFN0YXRlKHtzb3J0ZWRDb2xvckJpbnN9KTtcbiAgICB0aGlzLmdldENvbG9yVmFsdWVEb21haW4oKTtcbiAgfVxuXG4gIGdldFNvcnRlZEVsZXZhdGlvbkJpbnMoKSB7XG4gICAgY29uc3Qge2dldEVsZXZhdGlvblZhbHVlfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qgc29ydGVkRWxldmF0aW9uQmlucyA9IG5ldyBCaW5Tb3J0ZXIodGhpcy5zdGF0ZS5sYXllckRhdGEgfHwgW10sIGdldEVsZXZhdGlvblZhbHVlKTtcbiAgICB0aGlzLnNldFN0YXRlKHtzb3J0ZWRFbGV2YXRpb25CaW5zfSk7XG4gICAgdGhpcy5nZXRFbGV2YXRpb25WYWx1ZURvbWFpbigpO1xuICB9XG5cbiAgZ2V0Q29sb3JWYWx1ZURvbWFpbigpIHtcbiAgICBjb25zdCB7bG93ZXJQZXJjZW50aWxlLCB1cHBlclBlcmNlbnRpbGUsIG9uU2V0Q29sb3JEb21haW59ID0gdGhpcy5wcm9wcztcblxuICAgIHRoaXMuc3RhdGUuY29sb3JWYWx1ZURvbWFpbiA9IHRoaXMuc3RhdGUuc29ydGVkQ29sb3JCaW5zXG4gICAgICAuZ2V0VmFsdWVSYW5nZShbbG93ZXJQZXJjZW50aWxlLCB1cHBlclBlcmNlbnRpbGVdKTtcblxuICAgIGlmICh0eXBlb2Ygb25TZXRDb2xvckRvbWFpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb25TZXRDb2xvckRvbWFpbih0aGlzLnN0YXRlLmNvbG9yVmFsdWVEb21haW4pO1xuICAgIH1cblxuICAgIHRoaXMuZ2V0Q29sb3JTY2FsZSgpO1xuICB9XG5cbiAgZ2V0RWxldmF0aW9uVmFsdWVEb21haW4oKSB7XG4gICAgY29uc3Qge2VsZXZhdGlvbkxvd2VyUGVyY2VudGlsZSwgZWxldmF0aW9uVXBwZXJQZXJjZW50aWxlLCBvblNldEVsZXZhdGlvbkRvbWFpbn0gPSB0aGlzLnByb3BzO1xuXG4gICAgdGhpcy5zdGF0ZS5lbGV2YXRpb25WYWx1ZURvbWFpbiA9IHRoaXMuc3RhdGUuc29ydGVkRWxldmF0aW9uQmluc1xuICAgICAgLmdldFZhbHVlUmFuZ2UoW2VsZXZhdGlvbkxvd2VyUGVyY2VudGlsZSwgZWxldmF0aW9uVXBwZXJQZXJjZW50aWxlXSk7XG5cbiAgICBpZiAodHlwZW9mIG9uU2V0RWxldmF0aW9uRG9tYWluID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvblNldEVsZXZhdGlvbkRvbWFpbih0aGlzLnN0YXRlLmVsZXZhdGlvblZhbHVlRG9tYWluKTtcbiAgICB9XG5cbiAgICB0aGlzLmdldEVsZXZhdGlvblNjYWxlKCk7XG4gIH1cblxuICBnZXRDb2xvclNjYWxlKCkge1xuICAgIGNvbnN0IHtjb2xvclJhbmdlfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgY29sb3JEb21haW4gPSB0aGlzLnByb3BzLmNvbG9yRG9tYWluIHx8IHRoaXMuc3RhdGUuY29sb3JWYWx1ZURvbWFpbjtcblxuICAgIHRoaXMuc3RhdGUuY29sb3JTY2FsZUZ1bmMgPSBnZXRRdWFudGl6ZVNjYWxlKGNvbG9yRG9tYWluLCBjb2xvclJhbmdlKTtcbiAgfVxuXG4gIGdldEVsZXZhdGlvblNjYWxlKCkge1xuICAgIGNvbnN0IHtlbGV2YXRpb25SYW5nZX0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IGVsZXZhdGlvbkRvbWFpbiA9IHRoaXMucHJvcHMuZWxldmF0aW9uRG9tYWluIHx8IHRoaXMuc3RhdGUuZWxldmF0aW9uVmFsdWVEb21haW47XG5cbiAgICB0aGlzLnN0YXRlLmVsZXZhdGlvblNjYWxlRnVuYyA9IGdldExpbmVhclNjYWxlKGVsZXZhdGlvbkRvbWFpbiwgZWxldmF0aW9uUmFuZ2UpO1xuICB9XG5cbiAgX29uR2V0U3VibGF5ZXJDb2xvcihjZWxsKSB7XG4gICAgY29uc3Qge3NvcnRlZENvbG9yQmlucywgY29sb3JTY2FsZUZ1bmMsIGNvbG9yVmFsdWVEb21haW59ID0gdGhpcy5zdGF0ZTtcblxuICAgIGNvbnN0IGN2ID0gc29ydGVkQ29sb3JCaW5zLmJpbk1hcFtjZWxsLmluZGV4XSAmJiBzb3J0ZWRDb2xvckJpbnMuYmluTWFwW2NlbGwuaW5kZXhdLnZhbHVlO1xuICAgIGNvbnN0IGNvbG9yRG9tYWluID0gdGhpcy5wcm9wcy5jb2xvckRvbWFpbiB8fCBjb2xvclZhbHVlRG9tYWluO1xuXG4gICAgY29uc3QgaXNDb2xvclZhbHVlSW5Eb21haW4gPSBjdiA+PSBjb2xvckRvbWFpblswXSAmJiBjdiA8PSBjb2xvckRvbWFpbltjb2xvckRvbWFpbi5sZW5ndGggLSAxXTtcblxuICAgIC8vIGlmIGNlbGwgdmFsdWUgaXMgb3V0c2lkZSBkb21haW4sIHNldCBhbHBoYSB0byAwXG4gICAgY29uc3QgY29sb3IgPSBpc0NvbG9yVmFsdWVJbkRvbWFpbiA/IGNvbG9yU2NhbGVGdW5jKGN2KSA6IFswLCAwLCAwLCAwXTtcblxuICAgIC8vIGFkZCBhbHBoYSB0byBjb2xvciBpZiBub3QgZGVmaW5lZCBpbiBjb2xvclJhbmdlXG4gICAgY29sb3JbM10gPSBOdW1iZXIuaXNGaW5pdGUoY29sb3JbM10pID8gY29sb3JbM10gOiAyNTU7XG5cbiAgICByZXR1cm4gY29sb3I7XG4gIH1cblxuICBfb25HZXRTdWJsYXllckVsZXZhdGlvbihjZWxsKSB7XG4gICAgY29uc3Qge3NvcnRlZEVsZXZhdGlvbkJpbnMsIGVsZXZhdGlvblNjYWxlRnVuYywgZWxldmF0aW9uVmFsdWVEb21haW59ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBldiA9IHNvcnRlZEVsZXZhdGlvbkJpbnMuYmluTWFwW2NlbGwuaW5kZXhdICYmXG4gICAgICBzb3J0ZWRFbGV2YXRpb25CaW5zLmJpbk1hcFtjZWxsLmluZGV4XS52YWx1ZTtcblxuICAgIGNvbnN0IGVsZXZhdGlvbkRvbWFpbiA9IHRoaXMucHJvcHMuZWxldmF0aW9uRG9tYWluIHx8IGVsZXZhdGlvblZhbHVlRG9tYWluO1xuXG4gICAgY29uc3QgaXNFbGV2YXRpb25WYWx1ZUluRG9tYWluID0gZXYgPj0gZWxldmF0aW9uRG9tYWluWzBdICYmXG4gICAgICBldiA8PSBlbGV2YXRpb25Eb21haW5bZWxldmF0aW9uRG9tYWluLmxlbmd0aCAtIDFdO1xuXG4gICAgLy8gaWYgY2VsbCB2YWx1ZSBpcyBvdXRzaWRlIGRvbWFpbiwgc2V0IGVsZXZhdGlvbiB0byAtMVxuICAgIHJldHVybiBpc0VsZXZhdGlvblZhbHVlSW5Eb21haW4gPyBlbGV2YXRpb25TY2FsZUZ1bmMoZXYpIDogLTE7XG4gIH1cblxuICBnZXRTdWJMYXllclByb3BzKCkge1xuICAgIC8vIGZvciBzdWJjbGFzc2luZywgb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gcmV0dXJuXG4gICAgLy8gY3VzdG9taXplZCBzdWIgbGF5ZXIgcHJvcHNcbiAgICBjb25zdCB7aWQsIGVsZXZhdGlvblNjYWxlLCBmcDY0LCBleHRydWRlZCwgY2VsbFNpemUsIGNvdmVyYWdlLCBsaWdodFNldHRpbmdzfSA9IHRoaXMucHJvcHM7XG5cbiAgICAvLyBiYXNlIGxheWVyIHByb3BzXG4gICAgY29uc3Qge29wYWNpdHksIHBpY2thYmxlLCB2aXNpYmxlLCBnZXRQb2x5Z29uT2Zmc2V0fSA9IHRoaXMucHJvcHM7XG5cbiAgICAvLyB2aWV3cG9ydCBwcm9wc1xuICAgIGNvbnN0IHtwb3NpdGlvbk9yaWdpbiwgcHJvamVjdGlvbk1vZGUsIG1vZGVsTWF0cml4fSA9IHRoaXMucHJvcHM7XG5cbiAgICAvLyByZXR1cm4gcHJvcHMgdG8gdGhlIHN1YmxheWVyIGNvbnN0cnVjdG9yXG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiBgJHtpZH0tZ3JpZC1jZWxsYCxcbiAgICAgIGRhdGE6IHRoaXMuc3RhdGUubGF5ZXJEYXRhLFxuICAgICAgY2VsbFNpemUsXG4gICAgICBjb3ZlcmFnZSxcbiAgICAgIGxpZ2h0U2V0dGluZ3MsXG4gICAgICBlbGV2YXRpb25TY2FsZSxcbiAgICAgIGV4dHJ1ZGVkLFxuICAgICAgZnA2NCxcbiAgICAgIG9wYWNpdHksXG4gICAgICBwaWNrYWJsZSxcbiAgICAgIHZpc2libGUsXG4gICAgICBnZXRQb2x5Z29uT2Zmc2V0LFxuICAgICAgcHJvamVjdGlvbk1vZGUsXG4gICAgICBwb3NpdGlvbk9yaWdpbixcbiAgICAgIG1vZGVsTWF0cml4LFxuICAgICAgZ2V0Q29sb3I6IHRoaXMuX29uR2V0U3VibGF5ZXJDb2xvci5iaW5kKHRoaXMpLFxuICAgICAgZ2V0RWxldmF0aW9uOiB0aGlzLl9vbkdldFN1YmxheWVyRWxldmF0aW9uLmJpbmQodGhpcyksXG4gICAgICB1cGRhdGVUcmlnZ2VyczogdGhpcy5nZXRVcGRhdGVUcmlnZ2VycygpXG4gICAgfTtcbiAgfVxuXG4gIGdldFN1YkxheWVyQ2xhc3MoKSB7XG4gICAgLy8gZm9yIHN1YmNsYXNzaW5nLCBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byByZXR1cm5cbiAgICAvLyBjdXN0b21pemVkIHN1YiBsYXllciBjbGFzc1xuICAgIHJldHVybiBHcmlkQ2VsbExheWVyO1xuICB9XG5cbiAgcmVuZGVyTGF5ZXJzKCkge1xuICAgIGNvbnN0IFN1YkxheWVyQ2xhc3MgPSB0aGlzLmdldFN1YkxheWVyQ2xhc3MoKTtcblxuICAgIHJldHVybiBuZXcgU3ViTGF5ZXJDbGFzcyhcbiAgICAgIHRoaXMuZ2V0U3ViTGF5ZXJQcm9wcygpXG4gICAgKTtcbiAgfVxufVxuXG5HcmlkTGF5ZXIubGF5ZXJOYW1lID0gJ0dyaWRMYXllcic7XG5HcmlkTGF5ZXIuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuIl19