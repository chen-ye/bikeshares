var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

import assert from 'assert';
import { Framebuffer, ShaderCache } from 'luma.gl';
import seer from 'seer';
import Layer from './layer';
import { log } from './utils';
import { flatten } from './utils/flatten';
import { drawLayers as _drawLayers, pickLayers, queryLayers } from './draw-and-pick';
import { LIFECYCLE } from './constants';
import { Viewport } from './viewports';
import { setPropOverrides, layerEditListener, seerInitListener, initLayerInSeer, updateLayerInSeer } from '../debug/seer-integration';

var LOG_PRIORITY_LIFECYCLE = 2;
var LOG_PRIORITY_LIFECYCLE_MINOR = 4;

var layerName = function layerName(layer) {
  return layer instanceof Layer ? '' + layer : !layer ? 'null layer' : 'invalid layer';
};

var LayerManager = function () {
  function LayerManager(_ref) {
    var gl = _ref.gl;

    _classCallCheck(this, LayerManager);

    /* Currently deck.gl expects the DeckGL.layers to be different
     whenever React rerenders. If the same layers array is used, the
     LayerManager's diffing algorithm will generate a fatal error and
     break the rendering.
      `this.lastRenderedLayers` stores the UNFILTERED layers sent
     down to LayerManager, so that `layers` reference can be compared.
     If it's the same across two React render calls, the diffing logic
     will be skipped.
    */

    this.lastRenderedLayers = [];

    this.prevLayers = [];
    this.layers = [];
    this.oldContext = {};
    this.screenCleared = false;
    this._needsRedraw = true;

    this._eventManager = null;
    this._pickingRadius = 0;
    this._onLayerClick = null;
    this._onLayerHover = null;
    this._onClick = this._onClick.bind(this);
    this._onPointerMove = this._onPointerMove.bind(this);

    this._initSeer = this._initSeer.bind(this);
    this._editSeer = this._editSeer.bind(this);

    this.context = {
      gl: gl,
      uniforms: {},
      viewport: null,
      viewportChanged: true,
      pickingFBO: null,
      lastPickedInfo: {
        index: -1,
        layerId: null
      },
      shaderCache: new ShaderCache({ gl: gl })
    };

    seerInitListener(this._initSeer);
    layerEditListener(this._editSeer);

    Object.seal(this.context);
    Object.seal(this);
  }

  // Gets an (optionally) filtered list of layers


  _createClass(LayerManager, [{
    key: 'getLayers',
    value: function getLayers() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$layerIds = _ref2.layerIds,
          layerIds = _ref2$layerIds === undefined ? null : _ref2$layerIds;

      // Filtering by layerId compares beginning of strings, so that sublayers will be included
      // Dependes on the convention of adding suffixes to the parent's layer name
      return layerIds ? this.layers.filter(function (layer) {
        return layerIds.find(function (layerId) {
          return layer.id.indexOf(layerId) === 0;
        });
      }) : this.layers;
    }

    /**
     * Method to call when the layer manager is not needed anymore.
     *
     * Currently used in the <DeckGL> componentWillUnmount lifecycle to unbind Seer listeners.
     */

  }, {
    key: 'finalize',
    value: function finalize() {
      seer.removeListener(this._initSeer);
      seer.removeListener(this._editSeer);
    }
  }, {
    key: 'setViewport',
    value: function setViewport(viewport) {
      assert(viewport instanceof Viewport, 'Invalid viewport');

      // TODO - viewport change detection breaks METER_OFFSETS mode
      // const oldViewport = this.context.viewport;
      // const viewportChanged = !oldViewport || !viewport.equals(oldViewport);

      this._needsRedraw = true;

      var viewportChanged = true;

      if (viewportChanged) {
        Object.assign(this.oldContext, this.context);
        this.context.viewport = viewport;
        this.context.viewportChanged = true;
        this.context.uniforms = {};
        log(4, viewport);
      }

      return this;
    }

    /**
     * @param {Object} eventManager   A source of DOM input events
     */

  }, {
    key: 'initEventHandling',
    value: function initEventHandling(eventManager) {
      this._eventManager = eventManager;

      // TODO: add/remove handlers on demand at runtime, not all at once on init.
      // Consider both top-level handlers like onLayerClick/Hover
      // and per-layer handlers attached to individual layers.
      // https://github.com/uber/deck.gl/issues/634
      this._eventManager.on({
        click: this._onClick,
        pointermove: this._onPointerMove
      });
    }

    // Set parameters for input event handling.

  }, {
    key: 'setEventHandlingParameters',
    value: function setEventHandlingParameters(_ref3) {
      var pickingRadius = _ref3.pickingRadius,
          onLayerClick = _ref3.onLayerClick,
          onLayerHover = _ref3.onLayerHover;

      if (!isNaN(pickingRadius)) {
        this._pickingRadius = pickingRadius;
      }
      if (typeof onLayerClick !== 'undefined') {
        this._onLayerClick = onLayerClick;
      }
      if (typeof onLayerHover !== 'undefined') {
        this._onLayerHover = onLayerHover;
      }
      this._validateEventHandling();
    }
  }, {
    key: 'updateLayers',
    value: function updateLayers(_ref4) {
      var newLayers = _ref4.newLayers;

      // TODO - something is generating state updates that cause rerender of the same
      if (newLayers === this.lastRenderedLayers) {
        log.log(3, 'Ignoring layer update due to layer array not changed');
        return this;
      }
      this.lastRenderedLayers = newLayers;

      assert(this.context.viewport, 'LayerManager.updateLayers: viewport not set');

      // Filter out any null layers
      newLayers = newLayers.filter(function (newLayer) {
        return newLayer !== null;
      });

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = newLayers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var layer = _step.value;

          layer.context = this.context;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this.prevLayers = this.layers;

      var _updateLayers2 = this._updateLayers({
        oldLayers: this.prevLayers,
        newLayers: newLayers
      }),
          error = _updateLayers2.error,
          generatedLayers = _updateLayers2.generatedLayers;

      this.layers = generatedLayers;
      // Throw first error found, if any
      if (error) {
        throw error;
      }
      return this;
    }
  }, {
    key: 'drawLayers',
    value: function drawLayers(_ref5) {
      var pass = _ref5.pass;

      assert(this.context.viewport, 'LayerManager.drawLayers: viewport not set');

      _drawLayers({ layers: this.layers, pass: pass });

      return this;
    }

    // Pick the closest info at given coordinate

  }, {
    key: 'pickLayer',
    value: function pickLayer(_ref6) {
      var x = _ref6.x,
          y = _ref6.y,
          mode = _ref6.mode,
          _ref6$radius = _ref6.radius,
          radius = _ref6$radius === undefined ? 0 : _ref6$radius,
          layerIds = _ref6.layerIds;
      var gl = this.context.gl;


      var layers = this.getLayers({ layerIds: layerIds });

      return pickLayers(gl, {
        x: x,
        y: y,
        radius: radius,
        layers: layers,
        mode: mode,
        viewport: this.context.viewport,
        pickingFBO: this._getPickingBuffer(),
        lastPickedInfo: this.context.lastPickedInfo
      });
    }

    // Get all unique infos within a bounding box

  }, {
    key: 'queryLayer',
    value: function queryLayer(_ref7) {
      var x = _ref7.x,
          y = _ref7.y,
          width = _ref7.width,
          height = _ref7.height,
          layerIds = _ref7.layerIds;
      var gl = this.context.gl;

      var layers = layerIds ? this.layers.filter(function (layer) {
        return layerIds.indexOf(layer.id) >= 0;
      }) : this.layers;

      return queryLayers(gl, {
        x: x,
        y: y,
        width: width,
        height: height,
        layers: layers,
        mode: 'query',
        viewport: this.context.viewport,
        pickingFBO: this._getPickingBuffer()
      });
    }
  }, {
    key: 'needsRedraw',
    value: function needsRedraw() {
      var _ref8 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref8$clearRedrawFlag = _ref8.clearRedrawFlags,
          clearRedrawFlags = _ref8$clearRedrawFlag === undefined ? false : _ref8$clearRedrawFlag;

      if (!this.context.viewport) {
        return false;
      }

      var redraw = this._needsRedraw;
      if (clearRedrawFlags) {
        this._needsRedraw = false;
      }

      // Make sure that buffer is cleared once when layer list becomes empty
      if (this.layers.length === 0) {
        if (this.screenCleared === false) {
          redraw = true;
          this.screenCleared = true;
          return true;
        }
      } else if (this.screenCleared === true) {
        this.screenCleared = false;
      }

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this.layers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var layer = _step2.value;

          redraw = redraw || layer.getNeedsRedraw({ clearRedrawFlags: clearRedrawFlags });
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return redraw;
    }

    //
    // PRIVATE METHODS
    //

  }, {
    key: '_getPickingBuffer',
    value: function _getPickingBuffer() {
      var gl = this.context.gl;

      // Create a frame buffer if not already available

      this.context.pickingFBO = this.context.pickingFBO || new Framebuffer(gl, {
        width: gl.canvas.width,
        height: gl.canvas.height
      });

      // Resize it to current canvas size (this is a noop if size hasn't changed)
      this.context.pickingFBO.resize({
        width: gl.canvas.width,
        height: gl.canvas.height
      });

      return this.context.pickingFBO;
    }

    // Match all layers, checking for caught errors
    // To avoid having an exception in one layer disrupt other layers

  }, {
    key: '_updateLayers',
    value: function _updateLayers(_ref9) {
      var oldLayers = _ref9.oldLayers,
          newLayers = _ref9.newLayers;

      // Create old layer map
      var oldLayerMap = {};
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = oldLayers[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var oldLayer = _step3.value;

          if (oldLayerMap[oldLayer.id]) {
            log.once(0, 'Multiple old layers with same id ' + layerName(oldLayer));
          } else {
            oldLayerMap[oldLayer.id] = oldLayer;
            oldLayer.lifecycle = LIFECYCLE.AWAITING_FINALIZATION;
          }
        }

        // Allocate array for generated layers
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      var generatedLayers = [];

      // Match sublayers
      var error = this._matchSublayers({
        newLayers: newLayers, oldLayerMap: oldLayerMap, generatedLayers: generatedLayers
      });

      var error2 = this._finalizeOldLayers(oldLayers);
      var firstError = error || error2;
      return { error: firstError, generatedLayers: generatedLayers };
    }

    /* eslint-disable max-statements */

  }, {
    key: '_matchSublayers',
    value: function _matchSublayers(_ref10) {
      var _this = this;

      var newLayers = _ref10.newLayers,
          oldLayerMap = _ref10.oldLayerMap,
          generatedLayers = _ref10.generatedLayers;

      // Filter out any null layers
      newLayers = newLayers.filter(function (newLayer) {
        return newLayer !== null;
      });

      var error = null;
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        var _loop = function _loop() {
          var newLayer = _step4.value;

          newLayer.context = _this.context;

          try {
            // 1. given a new coming layer, find its matching layer
            var oldLayer = oldLayerMap[newLayer.id];
            oldLayerMap[newLayer.id] = null;

            if (oldLayer === null) {
              log.once(0, 'Multiple new layers with same id ' + layerName(newLayer));
            }

            // Only transfer state at this stage. We must not generate exceptions
            // until all layers' state have been transferred
            if (oldLayer) {
              _this._transferLayerState(oldLayer, newLayer);
              _this._updateLayer(newLayer);

              updateLayerInSeer(newLayer); // Initializes layer in seer chrome extension (if connected)
            } else {
              _this._initializeNewLayer(newLayer);

              initLayerInSeer(newLayer); // Initializes layer in seer chrome extension (if connected)
            }
            generatedLayers.push(newLayer);

            // Call layer lifecycle method: render sublayers
            var props = newLayer.props,
                oldProps = newLayer.oldProps;

            var sublayers = newLayer.isComposite ? newLayer._renderLayers({
              oldProps: oldProps,
              props: props,
              context: _this.context,
              oldContext: _this.oldContext,
              changeFlags: newLayer.diffProps(oldProps, props, _this.context)
            }) : null;
            // End layer lifecycle method: render sublayers

            if (sublayers) {
              // Flatten the returned array, removing any null, undefined or false
              // this allows layers to render sublayers conditionally
              // (see CompositeLayer.renderLayers docs)
              sublayers = flatten(sublayers, { filter: Boolean });

              // populate reference to parent layer
              sublayers.forEach(function (layer) {
                layer.parentLayer = newLayer;
              });

              _this._matchSublayers({
                newLayers: sublayers,
                oldLayerMap: oldLayerMap,
                generatedLayers: generatedLayers
              });
            }
          } catch (err) {
            log.once(0, 'deck.gl error during matching of ' + layerName(newLayer) + ' ' + err, err);
            // Save first error
            error = error || err;
          }
        };

        for (var _iterator4 = newLayers[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          _loop();
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      return error;
    }
  }, {
    key: '_transferLayerState',
    value: function _transferLayerState(oldLayer, newLayer) {
      var state = oldLayer.state,
          props = oldLayer.props;

      // sanity check

      assert(state, 'deck.gl sanity check - Matching layer has no state');
      if (newLayer !== oldLayer) {
        log(LOG_PRIORITY_LIFECYCLE_MINOR, 'matched ' + layerName(newLayer), oldLayer, '->', newLayer);

        // Move state
        state.layer = newLayer;
        newLayer.state = state;

        // Update model layer reference
        if (state.model) {
          state.model.userData.layer = newLayer;
        }
        // Keep a temporary ref to the old props, for prop comparison
        newLayer.oldProps = props;
        // oldLayer.state = null;

        newLayer.lifecycle = LIFECYCLE.MATCHED;
        oldLayer.lifecycle = LIFECYCLE.AWAITING_GC;
      } else {
        log.log(LOG_PRIORITY_LIFECYCLE_MINOR, 'Matching layer is unchanged ' + newLayer.id);
        newLayer.lifecycle = LIFECYCLE.MATCHED;
        newLayer.oldProps = newLayer.props;
        // TODO - we could avoid prop comparisons in this case
      }
    }

    // Update the old layers that were not matched

  }, {
    key: '_finalizeOldLayers',
    value: function _finalizeOldLayers(oldLayers) {
      var error = null;
      // Matched layers have lifecycle state "outdated"
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = oldLayers[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var layer = _step5.value;

          if (layer.lifecycle === LIFECYCLE.AWAITING_FINALIZATION) {
            error = error || this._finalizeLayer(layer);
          }
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      return error;
    }

    // Initializes a single layer, calling layer methods

  }, {
    key: '_initializeNewLayer',
    value: function _initializeNewLayer(layer) {
      var error = null;
      // Check if new layer, and initialize it's state
      if (!layer.state) {
        log(LOG_PRIORITY_LIFECYCLE, 'initializing ' + layerName(layer));
        try {

          layer.initializeLayer({
            oldProps: {},
            props: layer.props,
            oldContext: this.oldContext,
            context: this.context,
            changeFlags: layer.diffProps({}, layer.props, this.context)
          });

          layer.lifecycle = LIFECYCLE.INITIALIZED;
        } catch (err) {
          log.once(0, 'deck.gl error during initialization of ' + layerName(layer) + ' ' + err, err);
          // Save first error
          error = error || err;
        }
        // Set back pointer (used in picking)
        if (layer.state) {
          layer.state.layer = layer;
          // Save layer on model for picking purposes
          // TODO - store on model.userData rather than directly on model
        }
        if (layer.state && layer.state.model) {
          layer.state.model.userData.layer = layer;
        }
      }
      return error;
    }

    // Updates a single layer, calling layer methods

  }, {
    key: '_updateLayer',
    value: function _updateLayer(layer) {
      var oldProps = layer.oldProps,
          props = layer.props;

      var error = null;
      if (oldProps) {
        try {
          layer.updateLayer({
            oldProps: oldProps,
            props: props,
            context: this.context,
            oldContext: this.oldContext,
            changeFlags: layer.diffProps(oldProps, layer.props, this.context)
          });
        } catch (err) {
          log.once(0, 'deck.gl error during update of ' + layerName(layer), err);
          // Save first error
          error = err;
        }
        log(LOG_PRIORITY_LIFECYCLE_MINOR, 'updating ' + layerName(layer));
      }
      return error;
    }

    // Finalizes a single layer

  }, {
    key: '_finalizeLayer',
    value: function _finalizeLayer(layer) {
      var error = null;
      var state = layer.state;

      if (state) {
        try {
          layer.finalizeLayer();
        } catch (err) {
          log.once(0, 'deck.gl error during finalization of ' + layerName(layer), err);
          // Save first error
          error = err;
        }
        // layer.state = null;
        layer.lifecycle = LIFECYCLE.FINALIZED;
        log(LOG_PRIORITY_LIFECYCLE, 'finalizing ' + layerName(layer));
      }
      return error;
    }

    /**
     * Warn if a deck-level mouse event has been specified,
     * but no layers are `pickable`.
     */

  }, {
    key: '_validateEventHandling',
    value: function _validateEventHandling() {
      if (this.onLayerClick || this.onLayerHover) {
        if (this.layers.length && !this.layers.some(function (layer) {
          return layer.props.pickable;
        })) {
          log.once(1, 'You have supplied a top-level input event handler (e.g. `onLayerClick`), ' + 'but none of your layers have set the `pickable` flag.');
        }
      }
    }

    /**
     * Route click events to layers.
     * `pickLayer` will call the `onClick` prop of any picked layer,
     * and `onLayerClick` is called directly from here
     * with any picking info generated by `pickLayer`.
     * @param {Object} event  An object encapsulating an input event,
     *                        with the following shape:
     *                        {Object: {x, y}} offsetCenter: center of the event
     *                        {Object} srcEvent:             native JS Event object
     */

  }, {
    key: '_onClick',
    value: function _onClick(event) {
      var pos = event.offsetCenter;
      if (!pos) {
        return;
      }
      var selectedInfos = this.pickLayer({
        x: pos.x,
        y: pos.y,
        radius: this._pickingRadius,
        mode: 'click'
      });
      if (selectedInfos.length) {
        var firstInfo = selectedInfos.find(function (info) {
          return info.index >= 0;
        });
        if (this._onLayerClick) {
          this._onLayerClick(firstInfo, selectedInfos, event.srcEvent);
        }
      }
    }

    /**
     * Route click events to layers.
     * `pickLayer` will call the `onHover` prop of any picked layer,
     * and `onLayerHover` is called directly from here
     * with any picking info generated by `pickLayer`.
     * @param {Object} event  An object encapsulating an input event,
     *                        with the following shape:
     *                        {Object: {x, y}} offsetCenter: center of the event
     *                        {Object} srcEvent:             native JS Event object
     */

  }, {
    key: '_onPointerMove',
    value: function _onPointerMove(event) {
      if (event.isDown) {
        // Do not trigger onHover callbacks if mouse button is down
        return;
      }
      var pos = event.offsetCenter;
      // TODO: consider using this.eventManager.element size instead of layerManager.context
      // but do so in a way that doesn't cause reflow (e.g. `offsetWidth/Height`).
      // maybe the event object offers offsetCenter as a 0<>1 value as well?
      // since it's already doing size calculations...
      var _context$viewport = this.context.viewport,
          width = _context$viewport.width,
          height = _context$viewport.height;

      if (!pos || pos.x < 0 || pos.y < 0 || pos.x > width || pos.y > height) {
        // Check if pointer is inside the canvas
        return;
      }
      var selectedInfos = this.pickLayer({
        x: pos.x,
        y: pos.y,
        radius: this._pickingRadius,
        mode: 'hover'
      });
      if (selectedInfos.length) {
        var firstInfo = selectedInfos.find(function (info) {
          return info.index >= 0;
        });
        if (this._onLayerHover) {
          this._onLayerHover(firstInfo, selectedInfos, event.srcEvent);
        }
      }
    }

    // SEER INTEGRATION

    /**
     * Called upon Seer initialization, manually sends layers data.
     */

  }, {
    key: '_initSeer',
    value: function _initSeer() {
      this.layers.forEach(function (layer) {
        initLayerInSeer(layer);
        updateLayerInSeer(layer);
      });
    }

    /**
     * On Seer property edition, set override and update layers.
     */

  }, {
    key: '_editSeer',
    value: function _editSeer(payload) {
      if (payload.type !== 'edit' || payload.valuePath[0] !== 'props') {
        return;
      }

      setPropOverrides(payload.itemKey, payload.valuePath.slice(1), payload.value);
      var newLayers = this.layers.map(function (layer) {
        return new layer.constructor(layer.props);
      });
      this.updateLayers({ newLayers: newLayers });
    }
  }]);

  return LayerManager;
}();

export default LayerManager;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvbGF5ZXItbWFuYWdlci5qcyJdLCJuYW1lcyI6WyJhc3NlcnQiLCJGcmFtZWJ1ZmZlciIsIlNoYWRlckNhY2hlIiwic2VlciIsIkxheWVyIiwibG9nIiwiZmxhdHRlbiIsImRyYXdMYXllcnMiLCJwaWNrTGF5ZXJzIiwicXVlcnlMYXllcnMiLCJMSUZFQ1lDTEUiLCJWaWV3cG9ydCIsInNldFByb3BPdmVycmlkZXMiLCJsYXllckVkaXRMaXN0ZW5lciIsInNlZXJJbml0TGlzdGVuZXIiLCJpbml0TGF5ZXJJblNlZXIiLCJ1cGRhdGVMYXllckluU2VlciIsIkxPR19QUklPUklUWV9MSUZFQ1lDTEUiLCJMT0dfUFJJT1JJVFlfTElGRUNZQ0xFX01JTk9SIiwibGF5ZXJOYW1lIiwibGF5ZXIiLCJMYXllck1hbmFnZXIiLCJnbCIsImxhc3RSZW5kZXJlZExheWVycyIsInByZXZMYXllcnMiLCJsYXllcnMiLCJvbGRDb250ZXh0Iiwic2NyZWVuQ2xlYXJlZCIsIl9uZWVkc1JlZHJhdyIsIl9ldmVudE1hbmFnZXIiLCJfcGlja2luZ1JhZGl1cyIsIl9vbkxheWVyQ2xpY2siLCJfb25MYXllckhvdmVyIiwiX29uQ2xpY2siLCJiaW5kIiwiX29uUG9pbnRlck1vdmUiLCJfaW5pdFNlZXIiLCJfZWRpdFNlZXIiLCJjb250ZXh0IiwidW5pZm9ybXMiLCJ2aWV3cG9ydCIsInZpZXdwb3J0Q2hhbmdlZCIsInBpY2tpbmdGQk8iLCJsYXN0UGlja2VkSW5mbyIsImluZGV4IiwibGF5ZXJJZCIsInNoYWRlckNhY2hlIiwiT2JqZWN0Iiwic2VhbCIsImxheWVySWRzIiwiZmlsdGVyIiwiZmluZCIsImlkIiwiaW5kZXhPZiIsInJlbW92ZUxpc3RlbmVyIiwiYXNzaWduIiwiZXZlbnRNYW5hZ2VyIiwib24iLCJjbGljayIsInBvaW50ZXJtb3ZlIiwicGlja2luZ1JhZGl1cyIsIm9uTGF5ZXJDbGljayIsIm9uTGF5ZXJIb3ZlciIsImlzTmFOIiwiX3ZhbGlkYXRlRXZlbnRIYW5kbGluZyIsIm5ld0xheWVycyIsIm5ld0xheWVyIiwiX3VwZGF0ZUxheWVycyIsIm9sZExheWVycyIsImVycm9yIiwiZ2VuZXJhdGVkTGF5ZXJzIiwicGFzcyIsIngiLCJ5IiwibW9kZSIsInJhZGl1cyIsImdldExheWVycyIsIl9nZXRQaWNraW5nQnVmZmVyIiwid2lkdGgiLCJoZWlnaHQiLCJjbGVhclJlZHJhd0ZsYWdzIiwicmVkcmF3IiwibGVuZ3RoIiwiZ2V0TmVlZHNSZWRyYXciLCJjYW52YXMiLCJyZXNpemUiLCJvbGRMYXllck1hcCIsIm9sZExheWVyIiwib25jZSIsImxpZmVjeWNsZSIsIkFXQUlUSU5HX0ZJTkFMSVpBVElPTiIsIl9tYXRjaFN1YmxheWVycyIsImVycm9yMiIsIl9maW5hbGl6ZU9sZExheWVycyIsImZpcnN0RXJyb3IiLCJfdHJhbnNmZXJMYXllclN0YXRlIiwiX3VwZGF0ZUxheWVyIiwiX2luaXRpYWxpemVOZXdMYXllciIsInB1c2giLCJwcm9wcyIsIm9sZFByb3BzIiwic3VibGF5ZXJzIiwiaXNDb21wb3NpdGUiLCJfcmVuZGVyTGF5ZXJzIiwiY2hhbmdlRmxhZ3MiLCJkaWZmUHJvcHMiLCJCb29sZWFuIiwiZm9yRWFjaCIsInBhcmVudExheWVyIiwiZXJyIiwic3RhdGUiLCJtb2RlbCIsInVzZXJEYXRhIiwiTUFUQ0hFRCIsIkFXQUlUSU5HX0dDIiwiX2ZpbmFsaXplTGF5ZXIiLCJpbml0aWFsaXplTGF5ZXIiLCJJTklUSUFMSVpFRCIsInVwZGF0ZUxheWVyIiwiZmluYWxpemVMYXllciIsIkZJTkFMSVpFRCIsInNvbWUiLCJwaWNrYWJsZSIsImV2ZW50IiwicG9zIiwib2Zmc2V0Q2VudGVyIiwic2VsZWN0ZWRJbmZvcyIsInBpY2tMYXllciIsImZpcnN0SW5mbyIsImluZm8iLCJzcmNFdmVudCIsImlzRG93biIsInBheWxvYWQiLCJ0eXBlIiwidmFsdWVQYXRoIiwiaXRlbUtleSIsInNsaWNlIiwidmFsdWUiLCJtYXAiLCJjb25zdHJ1Y3RvciIs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LGlCQUFROEUsS0FBS3JGLEtBQUwsSUFBYyxDQUF0QjtBQUFBLFNBQW5CLENBQWxCO0FBQ0EsWUFBSSxLQUFLWixhQUFULEVBQXdCO0FBQ3RCLGVBQUtBLGFBQUwsQ0FBbUJnRyxTQUFuQixFQUE4QkYsYUFBOUIsRUFBNkNILE1BQU1PLFFBQW5EO0FBQ0Q7QUFDRjtBQUNGOztBQUVEOztBQUVBOzs7Ozs7Z0NBR1k7QUFDVixXQUFLekcsTUFBTCxDQUFZa0YsT0FBWixDQUFvQixpQkFBUztBQUMzQjVGLHdCQUFnQkssS0FBaEI7QUFDQUosMEJBQWtCSSxLQUFsQjtBQUNELE9BSEQ7QUFJRDs7QUFFRDs7Ozs7OzhCQUdVZ0gsTyxFQUFTO0FBQ2pCLFVBQUlBLFFBQVFDLElBQVIsS0FBaUIsTUFBakIsSUFBMkJELFFBQVFFLFNBQVIsQ0FBa0IsQ0FBbEIsTUFBeUIsT0FBeEQsRUFBaUU7QUFDL0Q7QUFDRDs7QUFFRDFILHVCQUFpQndILFFBQVFHLE9BQXpCLEVBQWtDSCxRQUFRRSxTQUFSLENBQWtCRSxLQUFsQixDQUF3QixDQUF4QixDQUFsQyxFQUE4REosUUFBUUssS0FBdEU7QUFDQSxVQUFNeEUsWUFBWSxLQUFLeEMsTUFBTCxDQUFZaUgsR0FBWixDQUFnQjtBQUFBLGVBQVMsSUFBSXRILE1BQU11SCxXQUFWLENBQXNCdkgsTUFBTStFLEtBQTVCLENBQVQ7QUFBQSxPQUFoQixDQUFsQjtBQUNBLFdBQUt5QyxZQUFMLENBQWtCLEVBQUMzRSxvQkFBRCxFQUFsQjtBQUNEOzs7Ozs7ZUFya0JrQjVDLFkiLCJmaWxlIjoibGF5ZXItbWFuYWdlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5pbXBvcnQge0ZyYW1lYnVmZmVyLCBTaGFkZXJDYWNoZX0gZnJvbSAnbHVtYS5nbCc7XG5pbXBvcnQgc2VlciBmcm9tICdzZWVyJztcbmltcG9ydCBMYXllciBmcm9tICcuL2xheWVyJztcbmltcG9ydCB7bG9nfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7ZmxhdHRlbn0gZnJvbSAnLi91dGlscy9mbGF0dGVuJztcbmltcG9ydCB7ZHJhd0xheWVycywgcGlja0xheWVycywgcXVlcnlMYXllcnN9IGZyb20gJy4vZHJhdy1hbmQtcGljayc7XG5pbXBvcnQge0xJRkVDWUNMRX0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHtWaWV3cG9ydH0gZnJvbSAnLi92aWV3cG9ydHMnO1xuaW1wb3J0IHtcbiAgc2V0UHJvcE92ZXJyaWRlcyxcbiAgbGF5ZXJFZGl0TGlzdGVuZXIsXG4gIHNlZXJJbml0TGlzdGVuZXIsXG4gIGluaXRMYXllckluU2VlcixcbiAgdXBkYXRlTGF5ZXJJblNlZXJcbn0gZnJvbSAnLi4vZGVidWcvc2Vlci1pbnRlZ3JhdGlvbic7XG5cbmNvbnN0IExPR19QUklPUklUWV9MSUZFQ1lDTEUgPSAyO1xuY29uc3QgTE9HX1BSSU9SSVRZX0xJRkVDWUNMRV9NSU5PUiA9IDQ7XG5cbmNvbnN0IGxheWVyTmFtZSA9IGxheWVyID0+IGxheWVyIGluc3RhbmNlb2YgTGF5ZXIgP1xuICBgJHtsYXllcn1gIDpcbiAgKCFsYXllciA/ICdudWxsIGxheWVyJyA6ICdpbnZhbGlkIGxheWVyJyk7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExheWVyTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKHtnbH0pIHtcbiAgICAvKiBDdXJyZW50bHkgZGVjay5nbCBleHBlY3RzIHRoZSBEZWNrR0wubGF5ZXJzIHRvIGJlIGRpZmZlcmVudFxuICAgICB3aGVuZXZlciBSZWFjdCByZXJlbmRlcnMuIElmIHRoZSBzYW1lIGxheWVycyBhcnJheSBpcyB1c2VkLCB0aGVcbiAgICAgTGF5ZXJNYW5hZ2VyJ3MgZGlmZmluZyBhbGdvcml0aG0gd2lsbCBnZW5lcmF0ZSBhIGZhdGFsIGVycm9yIGFuZFxuICAgICBicmVhayB0aGUgcmVuZGVyaW5nLlxuXG4gICAgIGB0aGlzLmxhc3RSZW5kZXJlZExheWVyc2Agc3RvcmVzIHRoZSBVTkZJTFRFUkVEIGxheWVycyBzZW50XG4gICAgIGRvd24gdG8gTGF5ZXJNYW5hZ2VyLCBzbyB0aGF0IGBsYXllcnNgIHJlZmVyZW5jZSBjYW4gYmUgY29tcGFyZWQuXG4gICAgIElmIGl0J3MgdGhlIHNhbWUgYWNyb3NzIHR3byBSZWFjdCByZW5kZXIgY2FsbHMsIHRoZSBkaWZmaW5nIGxvZ2ljXG4gICAgIHdpbGwgYmUgc2tpcHBlZC5cbiAgICAqL1xuXG4gICAgdGhpcy5sYXN0UmVuZGVyZWRMYXllcnMgPSBbXTtcblxuICAgIHRoaXMucHJldkxheWVycyA9IFtdO1xuICAgIHRoaXMubGF5ZXJzID0gW107XG4gICAgdGhpcy5vbGRDb250ZXh0ID0ge307XG4gICAgdGhpcy5zY3JlZW5DbGVhcmVkID0gZmFsc2U7XG4gICAgdGhpcy5fbmVlZHNSZWRyYXcgPSB0cnVlO1xuXG4gICAgdGhpcy5fZXZlbnRNYW5hZ2VyID0gbnVsbDtcbiAgICB0aGlzLl9waWNraW5nUmFkaXVzID0gMDtcbiAgICB0aGlzLl9vbkxheWVyQ2xpY2sgPSBudWxsO1xuICAgIHRoaXMuX29uTGF5ZXJIb3ZlciA9IG51bGw7XG4gICAgdGhpcy5fb25DbGljayA9IHRoaXMuX29uQ2xpY2suYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vblBvaW50ZXJNb3ZlID0gdGhpcy5fb25Qb2ludGVyTW92ZS5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5faW5pdFNlZXIgPSB0aGlzLl9pbml0U2Vlci5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2VkaXRTZWVyID0gdGhpcy5fZWRpdFNlZXIuYmluZCh0aGlzKTtcblxuICAgIHRoaXMuY29udGV4dCA9IHtcbiAgICAgIGdsLFxuICAgICAgdW5pZm9ybXM6IHt9LFxuICAgICAgdmlld3BvcnQ6IG51bGwsXG4gICAgICB2aWV3cG9ydENoYW5nZWQ6IHRydWUsXG4gICAgICBwaWNraW5nRkJPOiBudWxsLFxuICAgICAgbGFzdFBpY2tlZEluZm86IHtcbiAgICAgICAgaW5kZXg6IC0xLFxuICAgICAgICBsYXllcklkOiBudWxsXG4gICAgICB9LFxuICAgICAgc2hhZGVyQ2FjaGU6IG5ldyBTaGFkZXJDYWNoZSh7Z2x9KVxuICAgIH07XG5cbiAgICBzZWVySW5pdExpc3RlbmVyKHRoaXMuX2luaXRTZWVyKTtcbiAgICBsYXllckVkaXRMaXN0ZW5lcih0aGlzLl9lZGl0U2Vlcik7XG5cbiAgICBPYmplY3Quc2VhbCh0aGlzLmNvbnRleHQpO1xuICAgIE9iamVjdC5zZWFsKHRoaXMpO1xuICB9XG5cbiAgLy8gR2V0cyBhbiAob3B0aW9uYWxseSkgZmlsdGVyZWQgbGlzdCBvZiBsYXllcnNcbiAgZ2V0TGF5ZXJzKHtsYXllcklkcyA9IG51bGx9ID0ge30pIHtcbiAgICAvLyBGaWx0ZXJpbmcgYnkgbGF5ZXJJZCBjb21wYXJlcyBiZWdpbm5pbmcgb2Ygc3RyaW5ncywgc28gdGhhdCBzdWJsYXllcnMgd2lsbCBiZSBpbmNsdWRlZFxuICAgIC8vIERlcGVuZGVzIG9uIHRoZSBjb252ZW50aW9uIG9mIGFkZGluZyBzdWZmaXhlcyB0byB0aGUgcGFyZW50J3MgbGF5ZXIgbmFtZVxuICAgIHJldHVybiBsYXllcklkcyA/XG4gICAgICB0aGlzLmxheWVycy5maWx0ZXIobGF5ZXIgPT4gbGF5ZXJJZHMuZmluZChsYXllcklkID0+IGxheWVyLmlkLmluZGV4T2YobGF5ZXJJZCkgPT09IDApKSA6XG4gICAgICB0aGlzLmxheWVycztcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgdG8gY2FsbCB3aGVuIHRoZSBsYXllciBtYW5hZ2VyIGlzIG5vdCBuZWVkZWQgYW55bW9yZS5cbiAgICpcbiAgICogQ3VycmVudGx5IHVzZWQgaW4gdGhlIDxEZWNrR0w+IGNvbXBvbmVudFdpbGxVbm1vdW50IGxpZmVjeWNsZSB0byB1bmJpbmQgU2VlciBsaXN0ZW5lcnMuXG4gICAqL1xuICBmaW5hbGl6ZSgpIHtcbiAgICBzZWVyLnJlbW92ZUxpc3RlbmVyKHRoaXMuX2luaXRTZWVyKTtcbiAgICBzZWVyLnJlbW92ZUxpc3RlbmVyKHRoaXMuX2VkaXRTZWVyKTtcbiAgfVxuXG4gIHNldFZpZXdwb3J0KHZpZXdwb3J0KSB7XG4gICAgYXNzZXJ0KHZpZXdwb3J0IGluc3RhbmNlb2YgVmlld3BvcnQsICdJbnZhbGlkIHZpZXdwb3J0Jyk7XG5cbiAgICAvLyBUT0RPIC0gdmlld3BvcnQgY2hhbmdlIGRldGVjdGlvbiBicmVha3MgTUVURVJfT0ZGU0VUUyBtb2RlXG4gICAgLy8gY29uc3Qgb2xkVmlld3BvcnQgPSB0aGlzLmNvbnRleHQudmlld3BvcnQ7XG4gICAgLy8gY29uc3Qgdmlld3BvcnRDaGFuZ2VkID0gIW9sZFZpZXdwb3J0IHx8ICF2aWV3cG9ydC5lcXVhbHMob2xkVmlld3BvcnQpO1xuXG4gICAgdGhpcy5fbmVlZHNSZWRyYXcgPSB0cnVlO1xuXG4gICAgY29uc3Qgdmlld3BvcnRDaGFuZ2VkID0gdHJ1ZTtcblxuICAgIGlmICh2aWV3cG9ydENoYW5nZWQpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5vbGRDb250ZXh0LCB0aGlzLmNvbnRleHQpO1xuICAgICAgdGhpcy5jb250ZXh0LnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgICB0aGlzLmNvbnRleHQudmlld3BvcnRDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIHRoaXMuY29udGV4dC51bmlmb3JtcyA9IHt9O1xuICAgICAgbG9nKDQsIHZpZXdwb3J0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRNYW5hZ2VyICAgQSBzb3VyY2Ugb2YgRE9NIGlucHV0IGV2ZW50c1xuICAgKi9cbiAgaW5pdEV2ZW50SGFuZGxpbmcoZXZlbnRNYW5hZ2VyKSB7XG4gICAgdGhpcy5fZXZlbnRNYW5hZ2VyID0gZXZlbnRNYW5hZ2VyO1xuXG4gICAgLy8gVE9ETzogYWRkL3JlbW92ZSBoYW5kbGVycyBvbiBkZW1hbmQgYXQgcnVudGltZSwgbm90IGFsbCBhdCBvbmNlIG9uIGluaXQuXG4gICAgLy8gQ29uc2lkZXIgYm90aCB0b3AtbGV2ZWwgaGFuZGxlcnMgbGlrZSBvbkxheWVyQ2xpY2svSG92ZXJcbiAgICAvLyBhbmQgcGVyLWxheWVyIGhhbmRsZXJzIGF0dGFjaGVkIHRvIGluZGl2aWR1YWwgbGF5ZXJzLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS91YmVyL2RlY2suZ2wvaXNzdWVzLzYzNFxuICAgIHRoaXMuX2V2ZW50TWFuYWdlci5vbih7XG4gICAgICBjbGljazogdGhpcy5fb25DbGljayxcbiAgICAgIHBvaW50ZXJtb3ZlOiB0aGlzLl9vblBvaW50ZXJNb3ZlXG4gICAgfSk7XG4gIH1cblxuICAvLyBTZXQgcGFyYW1ldGVycyBmb3IgaW5wdXQgZXZlbnQgaGFuZGxpbmcuXG4gIHNldEV2ZW50SGFuZGxpbmdQYXJhbWV0ZXJzKHtcbiAgICBwaWNraW5nUmFkaXVzLFxuICAgIG9uTGF5ZXJDbGljayxcbiAgICBvbkxheWVySG92ZXJcbiAgfSkge1xuICAgIGlmICghaXNOYU4ocGlja2luZ1JhZGl1cykpIHtcbiAgICAgIHRoaXMuX3BpY2tpbmdSYWRpdXMgPSBwaWNraW5nUmFkaXVzO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9uTGF5ZXJDbGljayAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMuX29uTGF5ZXJDbGljayA9IG9uTGF5ZXJDbGljaztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvbkxheWVySG92ZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLl9vbkxheWVySG92ZXIgPSBvbkxheWVySG92ZXI7XG4gICAgfVxuICAgIHRoaXMuX3ZhbGlkYXRlRXZlbnRIYW5kbGluZygpO1xuICB9XG5cbiAgdXBkYXRlTGF5ZXJzKHtuZXdMYXllcnN9KSB7XG4gICAgLy8gVE9ETyAtIHNvbWV0aGluZyBpcyBnZW5lcmF0aW5nIHN0YXRlIHVwZGF0ZXMgdGhhdCBjYXVzZSByZXJlbmRlciBvZiB0aGUgc2FtZVxuICAgIGlmIChuZXdMYXllcnMgPT09IHRoaXMubGFzdFJlbmRlcmVkTGF5ZXJzKSB7XG4gICAgICBsb2cubG9nKDMsICdJZ25vcmluZyBsYXllciB1cGRhdGUgZHVlIHRvIGxheWVyIGFycmF5IG5vdCBjaGFuZ2VkJyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdGhpcy5sYXN0UmVuZGVyZWRMYXllcnMgPSBuZXdMYXllcnM7XG5cbiAgICBhc3NlcnQodGhpcy5jb250ZXh0LnZpZXdwb3J0LCAnTGF5ZXJNYW5hZ2VyLnVwZGF0ZUxheWVyczogdmlld3BvcnQgbm90IHNldCcpO1xuXG4gICAgLy8gRmlsdGVyIG91dCBhbnkgbnVsbCBsYXllcnNcbiAgICBuZXdMYXllcnMgPSBuZXdMYXllcnMuZmlsdGVyKG5ld0xheWVyID0+IG5ld0xheWVyICE9PSBudWxsKTtcblxuICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgbmV3TGF5ZXJzKSB7XG4gICAgICBsYXllci5jb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuICAgIH1cblxuICAgIHRoaXMucHJldkxheWVycyA9IHRoaXMubGF5ZXJzO1xuICAgIGNvbnN0IHtlcnJvciwgZ2VuZXJhdGVkTGF5ZXJzfSA9IHRoaXMuX3VwZGF0ZUxheWVycyh7XG4gICAgICBvbGRMYXllcnM6IHRoaXMucHJldkxheWVycyxcbiAgICAgIG5ld0xheWVyc1xuICAgIH0pO1xuXG4gICAgdGhpcy5sYXllcnMgPSBnZW5lcmF0ZWRMYXllcnM7XG4gICAgLy8gVGhyb3cgZmlyc3QgZXJyb3IgZm91bmQsIGlmIGFueVxuICAgIGlmIChlcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZHJhd0xheWVycyh7cGFzc30pIHtcbiAgICBhc3NlcnQodGhpcy5jb250ZXh0LnZpZXdwb3J0LCAnTGF5ZXJNYW5hZ2VyLmRyYXdMYXllcnM6IHZpZXdwb3J0IG5vdCBzZXQnKTtcblxuICAgIGRyYXdMYXllcnMoe2xheWVyczogdGhpcy5sYXllcnMsIHBhc3N9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gUGljayB0aGUgY2xvc2VzdCBpbmZvIGF0IGdpdmVuIGNvb3JkaW5hdGVcbiAgcGlja0xheWVyKHt4LCB5LCBtb2RlLCByYWRpdXMgPSAwLCBsYXllcklkc30pIHtcbiAgICBjb25zdCB7Z2x9ID0gdGhpcy5jb250ZXh0O1xuXG4gICAgY29uc3QgbGF5ZXJzID0gdGhpcy5nZXRMYXllcnMoe2xheWVySWRzfSk7XG5cbiAgICByZXR1cm4gcGlja0xheWVycyhnbCwge1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICByYWRpdXMsXG4gICAgICBsYXllcnMsXG4gICAgICBtb2RlLFxuICAgICAgdmlld3BvcnQ6IHRoaXMuY29udGV4dC52aWV3cG9ydCxcbiAgICAgIHBpY2tpbmdGQk86IHRoaXMuX2dldFBpY2tpbmdCdWZmZXIoKSxcbiAgICAgIGxhc3RQaWNrZWRJbmZvOiB0aGlzLmNvbnRleHQubGFzdFBpY2tlZEluZm9cbiAgICB9KTtcbiAgfVxuXG4gIC8vIEdldCBhbGwgdW5pcXVlIGluZm9zIHdpdGhpbiBhIGJvdW5kaW5nIGJveFxuICBxdWVyeUxheWVyKHt4LCB5LCB3aWR0aCwgaGVpZ2h0LCBsYXllcklkc30pIHtcbiAgICBjb25zdCB7Z2x9ID0gdGhpcy5jb250ZXh0O1xuICAgIGNvbnN0IGxheWVycyA9IGxheWVySWRzID9cbiAgICAgIHRoaXMubGF5ZXJzLmZpbHRlcihsYXllciA9PiBsYXllcklkcy5pbmRleE9mKGxheWVyLmlkKSA+PSAwKSA6XG4gICAgICB0aGlzLmxheWVycztcblxuICAgIHJldHVybiBxdWVyeUxheWVycyhnbCwge1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIGxheWVycyxcbiAgICAgIG1vZGU6ICdxdWVyeScsXG4gICAgICB2aWV3cG9ydDogdGhpcy5jb250ZXh0LnZpZXdwb3J0LFxuICAgICAgcGlja2luZ0ZCTzogdGhpcy5fZ2V0UGlja2luZ0J1ZmZlcigpXG4gICAgfSk7XG4gIH1cblxuICBuZWVkc1JlZHJhdyh7Y2xlYXJSZWRyYXdGbGFncyA9IGZhbHNlfSA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmNvbnRleHQudmlld3BvcnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgcmVkcmF3ID0gdGhpcy5fbmVlZHNSZWRyYXc7XG4gICAgaWYgKGNsZWFyUmVkcmF3RmxhZ3MpIHtcbiAgICAgIHRoaXMuX25lZWRzUmVkcmF3ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gTWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzIGNsZWFyZWQgb25jZSB3aGVuIGxheWVyIGxpc3QgYmVjb21lcyBlbXB0eVxuICAgIGlmICh0aGlzLmxheWVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmICh0aGlzLnNjcmVlbkNsZWFyZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHJlZHJhdyA9IHRydWU7XG4gICAgICAgIHRoaXMuc2NyZWVuQ2xlYXJlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5zY3JlZW5DbGVhcmVkID09PSB0cnVlKSB7XG4gICAgICB0aGlzLnNjcmVlbkNsZWFyZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMubGF5ZXJzKSB7XG4gICAgICByZWRyYXcgPSByZWRyYXcgfHwgbGF5ZXIuZ2V0TmVlZHNSZWRyYXcoe2NsZWFyUmVkcmF3RmxhZ3N9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVkcmF3O1xuICB9XG5cbiAgLy9cbiAgLy8gUFJJVkFURSBNRVRIT0RTXG4gIC8vXG5cbiAgX2dldFBpY2tpbmdCdWZmZXIoKSB7XG4gICAgY29uc3Qge2dsfSA9IHRoaXMuY29udGV4dDtcblxuICAgIC8vIENyZWF0ZSBhIGZyYW1lIGJ1ZmZlciBpZiBub3QgYWxyZWFkeSBhdmFpbGFibGVcbiAgICB0aGlzLmNvbnRleHQucGlja2luZ0ZCTyA9IHRoaXMuY29udGV4dC5waWNraW5nRkJPIHx8IG5ldyBGcmFtZWJ1ZmZlcihnbCwge1xuICAgICAgd2lkdGg6IGdsLmNhbnZhcy53aWR0aCxcbiAgICAgIGhlaWdodDogZ2wuY2FudmFzLmhlaWdodFxuICAgIH0pO1xuXG4gICAgLy8gUmVzaXplIGl0IHRvIGN1cnJlbnQgY2FudmFzIHNpemUgKHRoaXMgaXMgYSBub29wIGlmIHNpemUgaGFzbid0IGNoYW5nZWQpXG4gICAgdGhpcy5jb250ZXh0LnBpY2tpbmdGQk8ucmVzaXplKHtcbiAgICAgIHdpZHRoOiBnbC5jYW52YXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IGdsLmNhbnZhcy5oZWlnaHRcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzLmNvbnRleHQucGlja2luZ0ZCTztcbiAgfVxuXG4gIC8vIE1hdGNoIGFsbCBsYXllcnMsIGNoZWNraW5nIGZvciBjYXVnaHQgZXJyb3JzXG4gIC8vIFRvIGF2b2lkIGhhdmluZyBhbiBleGNlcHRpb24gaW4gb25lIGxheWVyIGRpc3J1cHQgb3RoZXIgbGF5ZXJzXG4gIF91cGRhdGVMYXllcnMoe29sZExheWVycywgbmV3TGF5ZXJzfSkge1xuICAgIC8vIENyZWF0ZSBvbGQgbGF5ZXIgbWFwXG4gICAgY29uc3Qgb2xkTGF5ZXJNYXAgPSB7fTtcbiAgICBmb3IgKGNvbnN0IG9sZExheWVyIG9mIG9sZExheWVycykge1xuICAgICAgaWYgKG9sZExheWVyTWFwW29sZExheWVyLmlkXSkge1xuICAgICAgICBsb2cub25jZSgwLCBgTXVsdGlwbGUgb2xkIGxheWVycyB3aXRoIHNhbWUgaWQgJHtsYXllck5hbWUob2xkTGF5ZXIpfWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2xkTGF5ZXJNYXBbb2xkTGF5ZXIuaWRdID0gb2xkTGF5ZXI7XG4gICAgICAgIG9sZExheWVyLmxpZmVjeWNsZSA9IExJRkVDWUNMRS5BV0FJVElOR19GSU5BTElaQVRJT047XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWxsb2NhdGUgYXJyYXkgZm9yIGdlbmVyYXRlZCBsYXllcnNcbiAgICBjb25zdCBnZW5lcmF0ZWRMYXllcnMgPSBbXTtcblxuICAgIC8vIE1hdGNoIHN1YmxheWVyc1xuICAgIGNvbnN0IGVycm9yID0gdGhpcy5fbWF0Y2hTdWJsYXllcnMoe1xuICAgICAgbmV3TGF5ZXJzLCBvbGRMYXllck1hcCwgZ2VuZXJhdGVkTGF5ZXJzXG4gICAgfSk7XG5cbiAgICBjb25zdCBlcnJvcjIgPSB0aGlzLl9maW5hbGl6ZU9sZExheWVycyhvbGRMYXllcnMpO1xuICAgIGNvbnN0IGZpcnN0RXJyb3IgPSBlcnJvciB8fCBlcnJvcjI7XG4gICAgcmV0dXJuIHtlcnJvcjogZmlyc3RFcnJvciwgZ2VuZXJhdGVkTGF5ZXJzfTtcbiAgfVxuXG4gIC8qIGVzbGludC1kaXNhYmxlIG1heC1zdGF0ZW1lbnRzICovXG5cbiAgX21hdGNoU3VibGF5ZXJzKHtuZXdMYXllcnMsIG9sZExheWVyTWFwLCBnZW5lcmF0ZWRMYXllcnN9KSB7XG4gICAgLy8gRmlsdGVyIG91dCBhbnkgbnVsbCBsYXllcnNcbiAgICBuZXdMYXllcnMgPSBuZXdMYXllcnMuZmlsdGVyKG5ld0xheWVyID0+IG5ld0xheWVyICE9PSBudWxsKTtcblxuICAgIGxldCBlcnJvciA9IG51bGw7XG4gICAgZm9yIChjb25zdCBuZXdMYXllciBvZiBuZXdMYXllcnMpIHtcbiAgICAgIG5ld0xheWVyLmNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIDEuIGdpdmVuIGEgbmV3IGNvbWluZyBsYXllciwgZmluZCBpdHMgbWF0Y2hpbmcgbGF5ZXJcbiAgICAgICAgY29uc3Qgb2xkTGF5ZXIgPSBvbGRMYXllck1hcFtuZXdMYXllci5pZF07XG4gICAgICAgIG9sZExheWVyTWFwW25ld0xheWVyLmlkXSA9IG51bGw7XG5cbiAgICAgICAgaWYgKG9sZExheWVyID09PSBudWxsKSB7XG4gICAgICAgICAgbG9nLm9uY2UoMCwgYE11bHRpcGxlIG5ldyBsYXllcnMgd2l0aCBzYW1lIGlkICR7bGF5ZXJOYW1lKG5ld0xheWVyKX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE9ubHkgdHJhbnNmZXIgc3RhdGUgYXQgdGhpcyBzdGFnZS4gV2UgbXVzdCBub3QgZ2VuZXJhdGUgZXhjZXB0aW9uc1xuICAgICAgICAvLyB1bnRpbCBhbGwgbGF5ZXJzJyBzdGF0ZSBoYXZlIGJlZW4gdHJhbnNmZXJyZWRcbiAgICAgICAgaWYgKG9sZExheWVyKSB7XG4gICAgICAgICAgdGhpcy5fdHJhbnNmZXJMYXllclN0YXRlKG9sZExheWVyLCBuZXdMYXllcik7XG4gICAgICAgICAgdGhpcy5fdXBkYXRlTGF5ZXIobmV3TGF5ZXIpO1xuXG4gICAgICAgICAgdXBkYXRlTGF5ZXJJblNlZXIobmV3TGF5ZXIpOyAvLyBJbml0aWFsaXplcyBsYXllciBpbiBzZWVyIGNocm9tZSBleHRlbnNpb24gKGlmIGNvbm5lY3RlZClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9pbml0aWFsaXplTmV3TGF5ZXIobmV3TGF5ZXIpO1xuXG4gICAgICAgICAgaW5pdExheWVySW5TZWVyKG5ld0xheWVyKTsgLy8gSW5pdGlhbGl6ZXMgbGF5ZXIgaW4gc2VlciBjaHJvbWUgZXh0ZW5zaW9uIChpZiBjb25uZWN0ZWQpXG4gICAgICAgIH1cbiAgICAgICAgZ2VuZXJhdGVkTGF5ZXJzLnB1c2gobmV3TGF5ZXIpO1xuXG4gICAgICAgIC8vIENhbGwgbGF5ZXIgbGlmZWN5Y2xlIG1ldGhvZDogcmVuZGVyIHN1YmxheWVyc1xuICAgICAgICBjb25zdCB7cHJvcHMsIG9sZFByb3BzfSA9IG5ld0xheWVyO1xuICAgICAgICBsZXQgc3VibGF5ZXJzID0gbmV3TGF5ZXIuaXNDb21wb3NpdGUgPyBuZXdMYXllci5fcmVuZGVyTGF5ZXJzKHtcbiAgICAgICAgICBvbGRQcm9wcyxcbiAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICBjb250ZXh0OiB0aGlzLmNvbnRleHQsXG4gICAgICAgICAgb2xkQ29udGV4dDogdGhpcy5vbGRDb250ZXh0LFxuICAgICAgICAgIGNoYW5nZUZsYWdzOiBuZXdMYXllci5kaWZmUHJvcHMob2xkUHJvcHMsIHByb3BzLCB0aGlzLmNvbnRleHQpXG4gICAgICAgIH0pIDogbnVsbDtcbiAgICAgICAgLy8gRW5kIGxheWVyIGxpZmVjeWNsZSBtZXRob2Q6IHJlbmRlciBzdWJsYXllcnNcblxuICAgICAgICBpZiAoc3VibGF5ZXJzKSB7XG4gICAgICAgICAgLy8gRmxhdHRlbiB0aGUgcmV0dXJuZWQgYXJyYXksIHJlbW92aW5nIGFueSBudWxsLCB1bmRlZmluZWQgb3IgZmFsc2VcbiAgICAgICAgICAvLyB0aGlzIGFsbG93cyBsYXllcnMgdG8gcmVuZGVyIHN1YmxheWVycyBjb25kaXRpb25hbGx5XG4gICAgICAgICAgLy8gKHNlZSBDb21wb3NpdGVMYXllci5yZW5kZXJMYXllcnMgZG9jcylcbiAgICAgICAgICBzdWJsYXllcnMgPSBmbGF0dGVuKHN1YmxheWVycywge2ZpbHRlcjogQm9vbGVhbn0pO1xuXG4gICAgICAgICAgLy8gcG9wdWxhdGUgcmVmZXJlbmNlIHRvIHBhcmVudCBsYXllclxuICAgICAgICAgIHN1YmxheWVycy5mb3JFYWNoKGxheWVyID0+IHtcbiAgICAgICAgICAgIGxheWVyLnBhcmVudExheWVyID0gbmV3TGF5ZXI7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB0aGlzLl9tYXRjaFN1YmxheWVycyh7XG4gICAgICAgICAgICBuZXdMYXllcnM6IHN1YmxheWVycyxcbiAgICAgICAgICAgIG9sZExheWVyTWFwLFxuICAgICAgICAgICAgZ2VuZXJhdGVkTGF5ZXJzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBsb2cub25jZSgwLFxuICAgICAgICAgIGBkZWNrLmdsIGVycm9yIGR1cmluZyBtYXRjaGluZyBvZiAke2xheWVyTmFtZShuZXdMYXllcil9ICR7ZXJyfWAsIGVycik7XG4gICAgICAgIC8vIFNhdmUgZmlyc3QgZXJyb3JcbiAgICAgICAgZXJyb3IgPSBlcnJvciB8fCBlcnI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuXG4gIF90cmFuc2ZlckxheWVyU3RhdGUob2xkTGF5ZXIsIG5ld0xheWVyKSB7XG4gICAgY29uc3Qge3N0YXRlLCBwcm9wc30gPSBvbGRMYXllcjtcblxuICAgIC8vIHNhbml0eSBjaGVja1xuICAgIGFzc2VydChzdGF0ZSwgJ2RlY2suZ2wgc2FuaXR5IGNoZWNrIC0gTWF0Y2hpbmcgbGF5ZXIgaGFzIG5vIHN0YXRlJyk7XG4gICAgaWYgKG5ld0xheWVyICE9PSBvbGRMYXllcikge1xuICAgICAgbG9nKExPR19QUklPUklUWV9MSUZFQ1lDTEVfTUlOT1IsXG4gICAgICAgIGBtYXRjaGVkICR7bGF5ZXJOYW1lKG5ld0xheWVyKX1gLCBvbGRMYXllciwgJy0+JywgbmV3TGF5ZXIpO1xuXG4gICAgICAvLyBNb3ZlIHN0YXRlXG4gICAgICBzdGF0ZS5sYXllciA9IG5ld0xheWVyO1xuICAgICAgbmV3TGF5ZXIuc3RhdGUgPSBzdGF0ZTtcblxuICAgICAgLy8gVXBkYXRlIG1vZGVsIGxheWVyIHJlZmVyZW5jZVxuICAgICAgaWYgKHN0YXRlLm1vZGVsKSB7XG4gICAgICAgIHN0YXRlLm1vZGVsLnVzZXJEYXRhLmxheWVyID0gbmV3TGF5ZXI7XG4gICAgICB9XG4gICAgICAvLyBLZWVwIGEgdGVtcG9yYXJ5IHJlZiB0byB0aGUgb2xkIHByb3BzLCBmb3IgcHJvcCBjb21wYXJpc29uXG4gICAgICBuZXdMYXllci5vbGRQcm9wcyA9IHByb3BzO1xuICAgICAgLy8gb2xkTGF5ZXIuc3RhdGUgPSBudWxsO1xuXG4gICAgICBuZXdMYXllci5saWZlY3ljbGUgPSBMSUZFQ1lDTEUuTUFUQ0hFRDtcbiAgICAgIG9sZExheWVyLmxpZmVjeWNsZSA9IExJRkVDWUNMRS5BV0FJVElOR19HQztcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nLmxvZyhMT0dfUFJJT1JJVFlfTElGRUNZQ0xFX01JTk9SLCBgTWF0Y2hpbmcgbGF5ZXIgaXMgdW5jaGFuZ2VkICR7bmV3TGF5ZXIuaWR9YCk7XG4gICAgICBuZXdMYXllci5saWZlY3ljbGUgPSBMSUZFQ1lDTEUuTUFUQ0hFRDtcbiAgICAgIG5ld0xheWVyLm9sZFByb3BzID0gbmV3TGF5ZXIucHJvcHM7XG4gICAgICAvLyBUT0RPIC0gd2UgY291bGQgYXZvaWQgcHJvcCBjb21wYXJpc29ucyBpbiB0aGlzIGNhc2VcbiAgICB9XG4gIH1cblxuICAvLyBVcGRhdGUgdGhlIG9sZCBsYXllcnMgdGhhdCB3ZXJlIG5vdCBtYXRjaGVkXG4gIF9maW5hbGl6ZU9sZExheWVycyhvbGRMYXllcnMpIHtcbiAgICBsZXQgZXJyb3IgPSBudWxsO1xuICAgIC8vIE1hdGNoZWQgbGF5ZXJzIGhhdmUgbGlmZWN5Y2xlIHN0YXRlIFwib3V0ZGF0ZWRcIlxuICAgIGZvciAoY29uc3QgbGF5ZXIgb2Ygb2xkTGF5ZXJzKSB7XG4gICAgICBpZiAobGF5ZXIubGlmZWN5Y2xlID09PSBMSUZFQ1lDTEUuQVdBSVRJTkdfRklOQUxJWkFUSU9OKSB7XG4gICAgICAgIGVycm9yID0gZXJyb3IgfHwgdGhpcy5fZmluYWxpemVMYXllcihsYXllcik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuXG4gIC8vIEluaXRpYWxpemVzIGEgc2luZ2xlIGxheWVyLCBjYWxsaW5nIGxheWVyIG1ldGhvZHNcbiAgX2luaXRpYWxpemVOZXdMYXllcihsYXllcikge1xuICAgIGxldCBlcnJvciA9IG51bGw7XG4gICAgLy8gQ2hlY2sgaWYgbmV3IGxheWVyLCBhbmQgaW5pdGlhbGl6ZSBpdCdzIHN0YXRlXG4gICAgaWYgKCFsYXllci5zdGF0ZSkge1xuICAgICAgbG9nKExPR19QUklPUklUWV9MSUZFQ1lDTEUsIGBpbml0aWFsaXppbmcgJHtsYXllck5hbWUobGF5ZXIpfWApO1xuICAgICAgdHJ5IHtcblxuICAgICAgICBsYXllci5pbml0aWFsaXplTGF5ZXIoe1xuICAgICAgICAgIG9sZFByb3BzOiB7fSxcbiAgICAgICAgICBwcm9wczogbGF5ZXIucHJvcHMsXG4gICAgICAgICAgb2xkQ29udGV4dDogdGhpcy5vbGRDb250ZXh0LFxuICAgICAgICAgIGNvbnRleHQ6IHRoaXMuY29udGV4dCxcbiAgICAgICAgICBjaGFuZ2VGbGFnczogbGF5ZXIuZGlmZlByb3BzKHt9LCBsYXllci5wcm9wcywgdGhpcy5jb250ZXh0KVxuICAgICAgICB9KTtcblxuICAgICAgICBsYXllci5saWZlY3ljbGUgPSBMSUZFQ1lDTEUuSU5JVElBTElaRUQ7XG5cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBsb2cub25jZSgwLCBgZGVjay5nbCBlcnJvciBkdXJpbmcgaW5pdGlhbGl6YXRpb24gb2YgJHtsYXllck5hbWUobGF5ZXIpfSAke2Vycn1gLCBlcnIpO1xuICAgICAgICAvLyBTYXZlIGZpcnN0IGVycm9yXG4gICAgICAgIGVycm9yID0gZXJyb3IgfHwgZXJyO1xuICAgICAgfVxuICAgICAgLy8gU2V0IGJhY2sgcG9pbnRlciAodXNlZCBpbiBwaWNraW5nKVxuICAgICAgaWYgKGxheWVyLnN0YXRlKSB7XG4gICAgICAgIGxheWVyLnN0YXRlLmxheWVyID0gbGF5ZXI7XG4gICAgICAgIC8vIFNhdmUgbGF5ZXIgb24gbW9kZWwgZm9yIHBpY2tpbmcgcHVycG9zZXNcbiAgICAgICAgLy8gVE9ETyAtIHN0b3JlIG9uIG1vZGVsLnVzZXJEYXRhIHJhdGhlciB0aGFuIGRpcmVjdGx5IG9uIG1vZGVsXG4gICAgICB9XG4gICAgICBpZiAobGF5ZXIuc3RhdGUgJiYgbGF5ZXIuc3RhdGUubW9kZWwpIHtcbiAgICAgICAgbGF5ZXIuc3RhdGUubW9kZWwudXNlckRhdGEubGF5ZXIgPSBsYXllcjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG5cbiAgLy8gVXBkYXRlcyBhIHNpbmdsZSBsYXllciwgY2FsbGluZyBsYXllciBtZXRob2RzXG4gIF91cGRhdGVMYXllcihsYXllcikge1xuICAgIGNvbnN0IHtvbGRQcm9wcywgcHJvcHN9ID0gbGF5ZXI7XG4gICAgbGV0IGVycm9yID0gbnVsbDtcbiAgICBpZiAob2xkUHJvcHMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxheWVyLnVwZGF0ZUxheWVyKHtcbiAgICAgICAgICBvbGRQcm9wcyxcbiAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICBjb250ZXh0OiB0aGlzLmNvbnRleHQsXG4gICAgICAgICAgb2xkQ29udGV4dDogdGhpcy5vbGRDb250ZXh0LFxuICAgICAgICAgIGNoYW5nZUZsYWdzOiBsYXllci5kaWZmUHJvcHMob2xkUHJvcHMsIGxheWVyLnByb3BzLCB0aGlzLmNvbnRleHQpXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZy5vbmNlKDAsIGBkZWNrLmdsIGVycm9yIGR1cmluZyB1cGRhdGUgb2YgJHtsYXllck5hbWUobGF5ZXIpfWAsIGVycik7XG4gICAgICAgIC8vIFNhdmUgZmlyc3QgZXJyb3JcbiAgICAgICAgZXJyb3IgPSBlcnI7XG4gICAgICB9XG4gICAgICBsb2coTE9HX1BSSU9SSVRZX0xJRkVDWUNMRV9NSU5PUiwgYHVwZGF0aW5nICR7bGF5ZXJOYW1lKGxheWVyKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG5cbiAgLy8gRmluYWxpemVzIGEgc2luZ2xlIGxheWVyXG4gIF9maW5hbGl6ZUxheWVyKGxheWVyKSB7XG4gICAgbGV0IGVycm9yID0gbnVsbDtcbiAgICBjb25zdCB7c3RhdGV9ID0gbGF5ZXI7XG4gICAgaWYgKHN0YXRlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBsYXllci5maW5hbGl6ZUxheWVyKCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgbG9nLm9uY2UoMCxcbiAgICAgICAgICBgZGVjay5nbCBlcnJvciBkdXJpbmcgZmluYWxpemF0aW9uIG9mICR7bGF5ZXJOYW1lKGxheWVyKX1gLCBlcnIpO1xuICAgICAgICAvLyBTYXZlIGZpcnN0IGVycm9yXG4gICAgICAgIGVycm9yID0gZXJyO1xuICAgICAgfVxuICAgICAgLy8gbGF5ZXIuc3RhdGUgPSBudWxsO1xuICAgICAgbGF5ZXIubGlmZWN5Y2xlID0gTElGRUNZQ0xFLkZJTkFMSVpFRDtcbiAgICAgIGxvZyhMT0dfUFJJT1JJVFlfTElGRUNZQ0xFLCBgZmluYWxpemluZyAke2xheWVyTmFtZShsYXllcil9YCk7XG4gICAgfVxuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBXYXJuIGlmIGEgZGVjay1sZXZlbCBtb3VzZSBldmVudCBoYXMgYmVlbiBzcGVjaWZpZWQsXG4gICAqIGJ1dCBubyBsYXllcnMgYXJlIGBwaWNrYWJsZWAuXG4gICAqL1xuICBfdmFsaWRhdGVFdmVudEhhbmRsaW5nKCkge1xuICAgIGlmIChcbiAgICAgIHRoaXMub25MYXllckNsaWNrIHx8XG4gICAgICB0aGlzLm9uTGF5ZXJIb3ZlclxuICAgICkge1xuICAgICAgaWYgKHRoaXMubGF5ZXJzLmxlbmd0aCAmJiAhdGhpcy5sYXllcnMuc29tZShsYXllciA9PiBsYXllci5wcm9wcy5waWNrYWJsZSkpIHtcbiAgICAgICAgbG9nLm9uY2UoMSxcbiAgICAgICAgICAnWW91IGhhdmUgc3VwcGxpZWQgYSB0b3AtbGV2ZWwgaW5wdXQgZXZlbnQgaGFuZGxlciAoZS5nLiBgb25MYXllckNsaWNrYCksICcgK1xuICAgICAgICAgICdidXQgbm9uZSBvZiB5b3VyIGxheWVycyBoYXZlIHNldCB0aGUgYHBpY2thYmxlYCBmbGFnLidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUm91dGUgY2xpY2sgZXZlbnRzIHRvIGxheWVycy5cbiAgICogYHBpY2tMYXllcmAgd2lsbCBjYWxsIHRoZSBgb25DbGlja2AgcHJvcCBvZiBhbnkgcGlja2VkIGxheWVyLFxuICAgKiBhbmQgYG9uTGF5ZXJDbGlja2AgaXMgY2FsbGVkIGRpcmVjdGx5IGZyb20gaGVyZVxuICAgKiB3aXRoIGFueSBwaWNraW5nIGluZm8gZ2VuZXJhdGVkIGJ5IGBwaWNrTGF5ZXJgLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgIEFuIG9iamVjdCBlbmNhcHN1bGF0aW5nIGFuIGlucHV0IGV2ZW50LFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIHdpdGggdGhlIGZvbGxvd2luZyBzaGFwZTpcbiAgICogICAgICAgICAgICAgICAgICAgICAgICB7T2JqZWN0OiB7eCwgeX19IG9mZnNldENlbnRlcjogY2VudGVyIG9mIHRoZSBldmVudFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIHtPYmplY3R9IHNyY0V2ZW50OiAgICAgICAgICAgICBuYXRpdmUgSlMgRXZlbnQgb2JqZWN0XG4gICAqL1xuICBfb25DbGljayhldmVudCkge1xuICAgIGNvbnN0IHBvcyA9IGV2ZW50Lm9mZnNldENlbnRlcjtcbiAgICBpZiAoIXBvcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3RlZEluZm9zID0gdGhpcy5waWNrTGF5ZXIoe1xuICAgICAgeDogcG9zLngsXG4gICAgICB5OiBwb3MueSxcbiAgICAgIHJhZGl1czogdGhpcy5fcGlja2luZ1JhZGl1cyxcbiAgICAgIG1vZGU6ICdjbGljaydcbiAgICB9KTtcbiAgICBpZiAoc2VsZWN0ZWRJbmZvcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGZpcnN0SW5mbyA9IHNlbGVjdGVkSW5mb3MuZmluZChpbmZvID0+IGluZm8uaW5kZXggPj0gMCk7XG4gICAgICBpZiAodGhpcy5fb25MYXllckNsaWNrKSB7XG4gICAgICAgIHRoaXMuX29uTGF5ZXJDbGljayhmaXJzdEluZm8sIHNlbGVjdGVkSW5mb3MsIGV2ZW50LnNyY0V2ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUm91dGUgY2xpY2sgZXZlbnRzIHRvIGxheWVycy5cbiAgICogYHBpY2tMYXllcmAgd2lsbCBjYWxsIHRoZSBgb25Ib3ZlcmAgcHJvcCBvZiBhbnkgcGlja2VkIGxheWVyLFxuICAgKiBhbmQgYG9uTGF5ZXJIb3ZlcmAgaXMgY2FsbGVkIGRpcmVjdGx5IGZyb20gaGVyZVxuICAgKiB3aXRoIGFueSBwaWNraW5nIGluZm8gZ2VuZXJhdGVkIGJ5IGBwaWNrTGF5ZXJgLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgIEFuIG9iamVjdCBlbmNhcHN1bGF0aW5nIGFuIGlucHV0IGV2ZW50LFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIHdpdGggdGhlIGZvbGxvd2luZyBzaGFwZTpcbiAgICogICAgICAgICAgICAgICAgICAgICAgICB7T2JqZWN0OiB7eCwgeX19IG9mZnNldENlbnRlcjogY2VudGVyIG9mIHRoZSBldmVudFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIHtPYmplY3R9IHNyY0V2ZW50OiAgICAgICAgICAgICBuYXRpdmUgSlMgRXZlbnQgb2JqZWN0XG4gICAqL1xuICBfb25Qb2ludGVyTW92ZShldmVudCkge1xuICAgIGlmIChldmVudC5pc0Rvd24pIHtcbiAgICAgIC8vIERvIG5vdCB0cmlnZ2VyIG9uSG92ZXIgY2FsbGJhY2tzIGlmIG1vdXNlIGJ1dHRvbiBpcyBkb3duXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBvcyA9IGV2ZW50Lm9mZnNldENlbnRlcjtcbiAgICAvLyBUT0RPOiBjb25zaWRlciB1c2luZyB0aGlzLmV2ZW50TWFuYWdlci5lbGVtZW50IHNpemUgaW5zdGVhZCBvZiBsYXllck1hbmFnZXIuY29udGV4dFxuICAgIC8vIGJ1dCBkbyBzbyBpbiBhIHdheSB0aGF0IGRvZXNuJ3QgY2F1c2UgcmVmbG93IChlLmcuIGBvZmZzZXRXaWR0aC9IZWlnaHRgKS5cbiAgICAvLyBtYXliZSB0aGUgZXZlbnQgb2JqZWN0IG9mZmVycyBvZmZzZXRDZW50ZXIgYXMgYSAwPD4xIHZhbHVlIGFzIHdlbGw/XG4gICAgLy8gc2luY2UgaXQncyBhbHJlYWR5IGRvaW5nIHNpemUgY2FsY3VsYXRpb25zLi4uXG4gICAgY29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gdGhpcy5jb250ZXh0LnZpZXdwb3J0O1xuICAgIGlmICghcG9zIHx8IHBvcy54IDwgMCB8fCBwb3MueSA8IDAgfHwgcG9zLnggPiB3aWR0aCB8fCBwb3MueSA+IGhlaWdodCkge1xuICAgICAgLy8gQ2hlY2sgaWYgcG9pbnRlciBpcyBpbnNpZGUgdGhlIGNhbnZhc1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3RlZEluZm9zID0gdGhpcy5waWNrTGF5ZXIoe1xuICAgICAgeDogcG9zLngsXG4gICAgICB5OiBwb3MueSxcbiAgICAgIHJhZGl1czogdGhpcy5fcGlja2luZ1JhZGl1cyxcbiAgICAgIG1vZGU6ICdob3ZlcidcbiAgICB9KTtcbiAgICBpZiAoc2VsZWN0ZWRJbmZvcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGZpcnN0SW5mbyA9IHNlbGVjdGVkSW5mb3MuZmluZChpbmZvID0+IGluZm8uaW5kZXggPj0gMCk7XG4gICAgICBpZiAodGhpcy5fb25MYXllckhvdmVyKSB7XG4gICAgICAgIHRoaXMuX29uTGF5ZXJIb3ZlcihmaXJzdEluZm8sIHNlbGVjdGVkSW5mb3MsIGV2ZW50LnNyY0V2ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBTRUVSIElOVEVHUkFUSU9OXG5cbiAgLyoqXG4gICAqIENhbGxlZCB1cG9uIFNlZXIgaW5pdGlhbGl6YXRpb24sIG1hbnVhbGx5IHNlbmRzIGxheWVycyBkYXRhLlxuICAgKi9cbiAgX2luaXRTZWVyKCkge1xuICAgIHRoaXMubGF5ZXJzLmZvckVhY2gobGF5ZXIgPT4ge1xuICAgICAgaW5pdExheWVySW5TZWVyKGxheWVyKTtcbiAgICAgIHVwZGF0ZUxheWVySW5TZWVyKGxheWVyKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPbiBTZWVyIHByb3BlcnR5IGVkaXRpb24sIHNldCBvdmVycmlkZSBhbmQgdXBkYXRlIGxheWVycy5cbiAgICovXG4gIF9lZGl0U2VlcihwYXlsb2FkKSB7XG4gICAgaWYgKHBheWxvYWQudHlwZSAhPT0gJ2VkaXQnIHx8IHBheWxvYWQudmFsdWVQYXRoWzBdICE9PSAncHJvcHMnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2V0UHJvcE92ZXJyaWRlcyhwYXlsb2FkLml0ZW1LZXksIHBheWxvYWQudmFsdWVQYXRoLnNsaWNlKDEpLCBwYXlsb2FkLnZhbHVlKTtcbiAgICBjb25zdCBuZXdMYXllcnMgPSB0aGlzLmxheWVycy5tYXAobGF5ZXIgPT4gbmV3IGxheWVyLmNvbnN0cnVjdG9yKGxheWVyLnByb3BzKSk7XG4gICAgdGhpcy51cGRhdGVMYXllcnMoe25ld0xheWVyc30pO1xuICB9XG59XG4iXX0=