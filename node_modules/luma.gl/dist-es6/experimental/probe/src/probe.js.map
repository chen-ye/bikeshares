{"version":3,"sources":["../../../../src/experimental/probe/src/probe.js"],"names":["IS_NODE","logger","timestamp","formatSI","value","toFixed","formatTime","ms","formatted","DEFAULT_CONFIG","isEnabled","level","isLogEnabled","isPrintEnabled","isRunEnabled","noop","TO_DISABLE","Probe","config","_logStore","_sampleStore","_fpsStore","_startStore","_startTs","_deltaTs","_startEpochTs","Date","now","_iterationsTs","_config","ignoreEnvironment","Object","assign","_getConfigFromEnvironment","configure","disable","method","prototype","newConfig","key","slice","Boolean","total","delta","name","meta","times","_getElapsedTime","logRow","start","end","duration","push","debug","JSON","stringify","probeLevel","args","_probe","_shouldLog","_log","_sample","samples","probeData","timeSum","count","averageTime","_fps","opts","fpsLog","fpsData","time","fps","_externalProbe","timeStart","timeSpent","func","arg","customConfig","serialized","parse","iterations","context","startIiterations","i","call","elapsedMillis","iterationsPerSecond","testName","elapsedMs","getIterationsPerSecond","log","tail","table","rows"],"mappings":"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","file":"probe.js","sourcesContent":["/* eslint-disable no-console */\nimport {IS_NODE, logger, timestamp} from './env';\n\n// TODO - this used to use d3.format(.3s)\nfunction formatSI(value) {\n  return value.toFixed(3);\n}\n\n// TODO: Currently unused, keeping in case we want it later for log formatting\nexport function formatTime(ms) {\n  let formatted;\n  if (ms < 10) {\n    formatted = `${ms.toFixed(2)}ms`;\n  } else if (ms < 100) {\n    formatted = `${ms.toFixed(1)}ms`;\n  } else if (ms < 1000) {\n    formatted = `${(ms / 1000).toFixed(3)}s`;\n  } else {\n    formatted = `${(ms / 1000).toFixed(2)}s`;\n  }\n  return formatted;\n}\n\nconst DEFAULT_CONFIG = {\n  // off by default\n  isEnabled: false,\n  // logging level\n  level: 1,\n  // Whether logging is turned on\n  isLogEnabled: true,\n  // Whether logging prints to console\n  isPrintEnabled: true,\n  // Whether Probe#run executes code\n  isRunEnabled: true\n};\n\nfunction noop() {}\n\nconst TO_DISABLE = [\n  '_probe', '_fps', '_externalProbe', '_log', 'run', 'getOption',\n  'getIterationsPerSecond', 'logIterationsPerSecond'\n];\n\nexport default class Probe {\n\n  /**\n   * @constructor\n   * @param {Object} config Optional configuration args; see #configure\n   */\n  constructor(config = {}) {\n    // Data containers\n    this._logStore = [];\n    this._sampleStore = {};\n    this._fpsStore = {};\n    this._startStore = {};\n    // Timestamps - pegged to an arbitrary time in the past\n    this._startTs = timestamp();\n    this._deltaTs = timestamp();\n    // Other systems passing in epoch info require an epoch ts to convert\n    this._startEpochTs = Date.now();\n    this._iterationsTs = null;\n    // Configuration\n    this._config = config.ignoreEnvironment ?\n      Object.assign({}, DEFAULT_CONFIG) :\n      this._getConfigFromEnvironment();\n    // Override with new configuration, if any\n    this.configure(config);\n    // Disable methods if necessary\n    if (!this._config.isEnabled) {\n      this.disable();\n    }\n  }\n\n  /**\n   * Turn probe on\n   * @return {Probe} self, to support chaining\n   */\n  enable() {\n    // Swap in live methods\n    for (const method of TO_DISABLE) {\n      this[method] = Probe.prototype[method];\n    }\n    return this.configure({isEnabled: true});\n  }\n\n  /**\n   * Turn probe off\n   * @return {Probe} self, to support chaining\n   */\n  disable() {\n    // Swap in noops for live methods\n    for (const method of TO_DISABLE) {\n      this[method] = noop;\n    }\n    return this.configure({isEnabled: false});\n  }\n\n  /**\n   * Convenience function: Set probe level\n   * @param {Number} level Level to set\n   * @return {Probe} self, to support chaining\n   */\n  setLevel(level) {\n    return this.configure({level});\n  }\n\n  /**\n   * Configure probe with new values (can include custom key/value pairs).\n   * Configuration will be persisted across browser sessions\n   * @param {Object} config - named parameters\n   * @param {Boolean} config.isEnabled Whether probe is enabled\n   * @param {Number} config.level Logging level\n   * @param {Boolean} config.isLogEnabled Whether logging prints to console\n   * @param {Boolean} config.isRunEnabled Whether #run executes code\n   * @return {Probe} self, to support chaining\n   */\n  configure(config = {}) {\n    const newConfig = Object.assign({}, this._config, config);\n    this._config = newConfig;\n    // if (!IS_NODE) {\n    //   const serialized = JSON.stringify(newConfig);\n    //   cookie.set(COOKIE_NAME, serialized);\n    // }\n    // Support chaining\n    return this;\n  }\n\n  /**\n   * Get a single option from preset configuration. Useful when using Probe to\n   * set developer-only switches.\n   * @param  {String} key Key to get value for\n   * @return {mixed}     Option value, or undefined\n   */\n  getOption(key) {\n    return this._config[key];\n  }\n\n  /**\n   * Get current log, as an array of log row objects\n   * @return {Object[]} Log\n   */\n  getLog() {\n    return this._logStore.slice();\n  }\n\n  /**\n   * Whether Probe is currently enabled\n   * @return {Boolean} isEnabled\n   */\n  isEnabled() {\n    return Boolean(this._config.isEnabled);\n  }\n\n  /**\n   * Reset all internal stores, dropping logs\n   */\n  reset() {\n    // Data containers\n    this._logStore = [];\n    this._sampleStore = {};\n    this._fpsStore = {};\n    this._startStore = {};\n    // Timestamps\n    this._startTs = timestamp();\n    this._deltaTs = timestamp();\n    this._iterationsTs = null;\n  }\n\n  /**\n   * Reset the long timer\n   */\n  resetStart() {\n    this._startTs = this._deltaTs = timestamp();\n  }\n\n  /**\n   * Reset the time since last probe\n   */\n  resetDelta() {\n    this._deltaTs = timestamp();\n  }\n\n  /**\n   * @return {Number} milliseconds, with fractions\n   */\n  getTotal() {\n    return timestamp() - this._startTs;\n  }\n\n  /**\n   * @return {Number} milliseconds, with fractions\n   */\n  getDelta() {\n    return timestamp() - this._deltaTs;\n  }\n\n  _getElapsedTime() {\n    const total = timestamp() - this._startTs;\n    const delta = timestamp() - this._deltaTs;\n    // reset delta timer\n    this._deltaTs = timestamp();\n    return {total, delta};\n  }\n\n  _log(level, name, meta = {}) {\n    const times = this._getElapsedTime();\n    const logRow = Object.assign({level, name}, times, meta);\n    // duration handling\n    if (meta.start) {\n      this._startStore[name] = timestamp();\n    } else if (meta.end) {\n      // If start isn't found, take the full duration since initialization\n      const start = this._startStore[name] || this._startTs;\n      logRow.duration = timestamp() - start;\n    }\n    this._logStore.push(logRow);\n    // Log to console if enabled\n    if (this._config.isPrintEnabled) {\n      // TODO: Nicer console logging\n      logger.debug(JSON.stringify(logRow));\n    }\n  }\n\n  _shouldLog(probeLevel) {\n    const {isEnabled, isLogEnabled, level} = this._config;\n    return isEnabled && isLogEnabled && level >= probeLevel;\n  }\n\n  /**\n   * Displays a double timing (from \"start time\" and from last probe).\n   */\n  probe(...args) {\n    this._probe(1, ...args);\n  }\n\n  probe1(...args) {\n    this._probe(1, ...args);\n  }\n\n  probe2(...args) {\n    this._probe(2, ...args);\n  }\n\n  probe3(...args) {\n    this._probe(3, ...args);\n  }\n\n  _probe(level, name, meta) {\n    if (this._shouldLog(level)) {\n      this._log(level, name, meta);\n    }\n  }\n\n  /**\n   * Display an averaged value of the time since last probe.\n   * Keyed on the first string argument.\n   */\n  sample(...args) {\n    this._sample(1, ...args);\n  }\n\n  sample1(...args) {\n    this._sample(1, ...args);\n  }\n\n  sample2(...args) {\n    this._sample(2, ...args);\n  }\n\n  sample3(...args) {\n    this._sample(3, ...args);\n  }\n\n  _sample(level, name, meta) {\n    if (this._shouldLog(level)) {\n      const samples = this._sampleStore;\n\n      const probeData = samples[name] || (\n        samples[name] = {timeSum: 0, count: 0, averageTime: 0}\n      );\n      probeData.timeSum += timestamp() - this._deltaTs;\n      probeData.count += 1;\n      probeData.averageTime = probeData.timeSum / probeData.count;\n\n      this._log(level, name, Object.assign({}, meta, {averageTime: probeData.averageTime}));\n\n      // Weight more heavily on later samples. Otherwise it gets almost\n      // impossible to see outliers after a while.\n      if (probeData.count === 10) {\n        probeData.count = 5;\n        probeData.timeSum /= 2;\n      }\n    }\n  }\n\n  /**\n   * These functions will average the time between calls and log that value\n   * every couple of calls, in effect showing a times per second this\n   * function is called - sometimes representing a \"frames per second\" count.\n   */\n  fps(...args) {\n    this._fps(1, ...args);\n  }\n\n  fps1(...args) {\n    this._fps(1, ...args);\n  }\n\n  fps2(...args) {\n    this._fps(2, ...args);\n  }\n\n  fps3(...args) {\n    this._fps(3, ...args);\n  }\n\n  _fps(level, name = 'default', opts = {}) {\n    const {count = 10} = opts;\n    if (this._shouldLog(level)) {\n      const fpsLog = this._fpsStore;\n      const fpsData = fpsLog[name];\n      if (!fpsData) {\n        fpsLog[name] = {count: 1, time: timestamp()};\n      } else if (++fpsData.count >= count) {\n        const fps = fpsData.count / (timestamp() - fpsData.time);\n        fpsData.count = 0;\n        fpsData.time = timestamp();\n        this._log(level, name, Object.assign({fps}, opts));\n      }\n    }\n  }\n\n  /**\n   * Display a measurement from an external source, such as a server,\n   * inline with other local measurements in the style of Probe's output.\n   */\n  externalProbe(...args) {\n    this._externalProbe(1, ...args);\n  }\n\n  externalProbe1(...args) {\n    this._externalProbe(1, ...args);\n  }\n\n  externalProbe2(...args) {\n    this._externalProbe(2, ...args);\n  }\n\n  externalProbe3(...args) {\n    this._externalProbe(3, ...args);\n  }\n\n  _externalProbe(level, name, timeStart, timeSpent, meta) {\n    if (this._shouldLog(level)) {\n      // External probes are expected to provide epoch timestamps\n      const total = timeStart - this._startEpochTs;\n      const delta = timeSpent;\n      this._log(level, name, Object.assign({total, delta}, meta));\n    }\n  }\n\n  /* Conditionally run a function only when probe is enabled */\n  run(func, arg) {\n    const {isEnabled, isRunEnabled} = this._config;\n    if (isEnabled && isRunEnabled) {\n      func(arg);\n    }\n  }\n\n  startIiterations() {\n    this._iterationsTs = timestamp();\n  }\n\n  /**\n   * Get config from persistent store, if available\n   * @return {Object} config\n   */\n  _getConfigFromEnvironment() {\n    let customConfig = {};\n    if (!IS_NODE) {\n      const serialized = {}; // cookie.get(COOKIE_NAME);\n      if (serialized) {\n        customConfig = JSON.parse(serialized);\n      }\n    }\n    return Object.assign({}, DEFAULT_CONFIG, customConfig);\n  }\n\n  /* Count iterations per second. Runs the provided function a\n   * specified number of times and normalizes the result to represent\n   * iterations per second.\n   *\n   * TODO/ib Measure one iteration and auto adjust iteration count.\n   */\n  getIterationsPerSecond(iterations = 10000, func = null, context) {\n    if (func) {\n      Probe.startIiterations();\n      // Keep call overhead minimal, only use Function.call if context supplied\n      if (context) {\n        for (let i = 0; i < iterations; i++) {\n          func.call(context);\n        }\n      } else {\n        for (let i = 0; i < iterations; i++) {\n          func();\n        }\n      }\n    }\n    const elapsedMillis = timestamp() - this._iterationsTs;\n    const iterationsPerSecond = formatSI(iterations * 1000 / elapsedMillis);\n    return iterationsPerSecond;\n  }\n\n  /*\n   * Print the number of iterations per second measured using the provided\n   * function\n   */\n  logIterationsPerSecond(\n    testName, iterations = 10000, func = null, context = null\n  ) {\n    const elapsedMs = this.getIterationsPerSecond(iterations, func, context);\n    const iterationsPerSecond = formatSI(iterations * 1000 / elapsedMs);\n    logger.log(`${testName}: ${iterationsPerSecond} iterations/s`);\n  }\n\n  /**\n   * Show current log in a table, if supported by console\n   * @param {Number} tail If supplied, show only the last n entries\n   */\n  table(tail) {\n    if (typeof logger.table === 'function') {\n      const rows = tail ? this._logStore.slice(-tail) : this._logStore;\n      logger.table(rows);\n    }\n  }\n\n}\n"]}