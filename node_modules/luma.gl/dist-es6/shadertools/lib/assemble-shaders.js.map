{"version":3,"sources":["../../../src/shadertools/lib/assemble-shaders.js"],"names":["resolveModules","getShaderModule","getPlatformShaderDefines","getVersionDefines","MODULE_INJECTORS_VS","MODULE_INJECTORS_FS","assert","VERTEX_SHADER","FRAGMENT_SHADER","SHADER_TYPE","MODULE_INJECTORS","FRAGMENT_SHADER_PROLOGUE","getShaderName","id","source","type","injectShaderName","indexOf","getApplicationDefines","defines","count","sourceText","define","toUpperCase","getModuleSource","moduleName","shaderModule","moduleSource","vs","vertexShader","fs","fragmentShader","assembleShader","gl","modules","sourceLines","split","versionLine","coreSource","slice","join","assembledSource","inject","replace","assembleGetUniforms","getUniforms","opts","uniforms","moduleUniforms","Object","assign","assembleModuleMap","result","assembleShaders"],"mappings":"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","file":"assemble-shaders.js","sourcesContent":["import {resolveModules, getShaderModule} from './shader-modules';\nimport {getPlatformShaderDefines, getVersionDefines} from './platform-defines';\nimport {MODULE_INJECTORS_VS, MODULE_INJECTORS_FS} from '../modules/module-injectors';\nimport assert from 'assert';\n\nconst VERTEX_SHADER = 'vs';\nconst FRAGMENT_SHADER = 'fs';\n\nconst SHADER_TYPE = {\n  [VERTEX_SHADER]: 'vertex',\n  [FRAGMENT_SHADER]: 'fragment'\n};\n\nconst MODULE_INJECTORS = {\n  [VERTEX_SHADER]: MODULE_INJECTORS_VS,\n  [FRAGMENT_SHADER]: MODULE_INJECTORS_FS\n};\n\n// Precision prologue to inject before functions are injected in shader\n// TODO - extract any existing prologue in the fragment source and move it up...\nconst FRAGMENT_SHADER_PROLOGUE = `\\\n#ifdef GL_ES\nprecision highp float;\n#endif\n\n`;\n\n// Generate \"glslify-compatible\" SHADER_NAME defines\n// These are understood by the GLSL error parsing function\n// If id is provided and no SHADER_NAME constant is present in source, create one\nfunction getShaderName({id, source, type}) {\n  const injectShaderName = id && typeof id === 'string' && source.indexOf('SHADER_NAME') === -1;\n  return injectShaderName ? `\n#define SHADER_NAME ${id}_${SHADER_TYPE[type]}\n\n` : '';\n}\n\n// Generates application defines from an object\nfunction getApplicationDefines(defines = {}) {\n  let count = 0;\n  let sourceText = '';\n  for (const define in defines) {\n    if (count === 0) {\n      sourceText += '\\n// APPLICATION DEFINES\\n';\n    }\n    count++;\n    sourceText += `#define ${define.toUpperCase()} ${defines[define]}\\n`;\n  }\n  if (count === 0) {\n    sourceText += '\\n';\n  }\n  return sourceText;\n}\n\n// Extracts the source code chunk for the specified shader type from the named shader module\nfunction getModuleSource(moduleName, type) {\n  const shaderModule = getShaderModule(moduleName);\n  let moduleSource;\n  switch (type) {\n  case VERTEX_SHADER:\n    moduleSource = shaderModule.vs || shaderModule.vertexShader;\n    break;\n  case FRAGMENT_SHADER:\n    moduleSource = shaderModule.fs || shaderModule.fragmentShader;\n    break;\n  default:\n    assert(false);\n  }\n\n  if (typeof moduleSource !== 'string') {\n    return '';\n  }\n\n  return `\\\n#define MODULE_${moduleName.toUpperCase()}\n${moduleSource}\\\n// END MODULE_${moduleName}\n\n`;\n}\n\n// Pulls together complete source code for either a vertex or a fragment shader\n// adding prologues, requested module chunks, and any final injections.\nfunction assembleShader(gl, {\n  id,\n  source,\n  type,\n  modules = [],\n  defines = {}\n}) {\n  assert(typeof source === 'string', 'shader source must be a string');\n\n  const sourceLines = source.split('\\n');\n  let versionLine = '';\n  let coreSource = source;\n  // Extract any version directive string from source.\n  // TODO : keep all pre-processor statements at the begining of the shader.\n  if (sourceLines[0].indexOf('#version ') === 0) {\n    versionLine = sourceLines[0];\n    coreSource = sourceLines.slice(1).join('\\n');\n  }\n\n  // Add platform defines (use these to work around platform-specific bugs and limitations)\n  // Add common defines (GLSL version compatibility, feature detection)\n  // Add precision declaration for fragment shaders\n  let assembledSource = `\\\n${getShaderName({id, source, type})}\n${getPlatformShaderDefines(gl)}\n${getVersionDefines(gl)}\n${getApplicationDefines(defines)}\n${type === FRAGMENT_SHADER ? FRAGMENT_SHADER_PROLOGUE : ''}\n`;\n\n  // Add source of dependent modules in resolved order\n  let inject = false;\n  for (const moduleName of modules) {\n    switch (moduleName) {\n    case 'inject':\n      inject = true;\n      break;\n    default:\n      // Add the module source, and a #define that declares it presence\n      assembledSource += getModuleSource(moduleName, type);\n    }\n  }\n\n  // Add the version directive and actual source of this shader\n  assembledSource = versionLine + assembledSource + coreSource;\n\n  // Finally, if requested, insert an automatic module injector chunk\n  if (inject) {\n    assembledSource.replace('}\\s*$', MODULE_INJECTORS);\n  }\n\n  return assembledSource;\n}\n\n// Returns a combined `getUniforms` covering the options for all the modules,\n// the created function will pass on options to the inidividual `getUniforms`\n// function of each shader module and combine the results into one object that\n// can be passed to setUniforms.\nfunction assembleGetUniforms(modules) {\n\n  return function getUniforms(opts) {\n    const uniforms = {};\n    for (const moduleName of modules) {\n      const shaderModule = getShaderModule(moduleName);\n      const moduleUniforms = shaderModule.getUniforms ? shaderModule.getUniforms(opts) : {};\n      Object.assign(uniforms, moduleUniforms);\n    }\n    return uniforms;\n  };\n\n}\n\n// Returns a map with module names as keys, resolving to their module definitions\n// The presence of a key indicates that the module is available in this program,\n// whether directly included, or through a dependency of some other module\nfunction assembleModuleMap(modules) {\n  const result = {};\n  for (const moduleName of modules) {\n    const shaderModule = getShaderModule(moduleName);\n    result[moduleName] = shaderModule;\n  }\n  return result;\n}\n\n/**\n * Apply set of modules\n */\nexport function assembleShaders(gl, opts = {}) {\n  const {vs, fs} = opts;\n  const modules = resolveModules(opts.modules || []);\n  return {\n    gl,\n    vs: assembleShader(gl, Object.assign({}, opts, {source: vs, type: VERTEX_SHADER, modules})),\n    fs: assembleShader(gl, Object.assign({}, opts, {source: fs, type: FRAGMENT_SHADER, modules})),\n    getUniforms: assembleGetUniforms(modules),\n    modules: assembleModuleMap(modules)\n  };\n}\n"]}