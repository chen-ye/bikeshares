{"version":3,"sources":["../../src/webgl/functions.js"],"names":["GL","glGet","assertWebGLContext","assertWebGL2Context","withParameters","assert","readPixels","gl","x","y","width","height","data","dataOffset","type","UNSIGNED_BYTE","sourceHeight","format","RGBA","Uint8Array","readPixelsToBuffer","buffer","bindBuffer","PIXEL_PACK_BUFFER","handle","blitFramebuffer","source","sourceX","sourceY","sourceWidth","dest","destX","destY","destWidth","destHeight","mask","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","STENCIL_BUFFER_BIT","filter","LINEAR"],"mappings":"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","file":"functions.js","sourcesContent":["/* eslint-disable */\n// TODO - generic draw call\n// One of the good things about GL is that there are so many ways to draw things\nimport GL, {glGet} from './api';\nimport {assertWebGLContext, assertWebGL2Context} from './context';\nimport {withParameters} from './context';\nimport assert from 'assert';\n\n/**\n * Read pixels from a target\n *\n * Will read from the currently bound framebuffer, or the currently bound\n *  drawing buffer - if context has been created with\n *  preserveDrawingBuffers\n *\n * @param {WebGLRenderingContext} gl\n * @param {Object} opts\n * @param {Number} opts.x - leftmost coord to be read\n * @param {Number} opts.y - bottommost (or topmost if sourceHeight supplied)\n * @param {Number} opts.width=1 - width of area to be read\n * @param {Number} opts.height=1 - height of area to be read\n * @param {Number} opts.sourceHeight= - target height, implies top left coords\n * @param {Number} opts.dataOffset=0 - WebGL2 only - offset into data array\n * @param {Number} opts.format=GL.RBGA - Can be set to GL.RGB or GL.ALPHA\n *\n * @return {ArrayView} - types array, either passed in or autoallocated\n */\nexport function readPixels(gl, {\n  x,\n  y,\n  width = 1,\n  height = 1,\n  data,\n  dataOffset = 0,\n  type = GL.UNSIGNED_BYTE,\n  sourceHeight,\n  format = GL.RGBA\n}) {\n  // Read color in the central pixel, to be mapped with picking colors\n  data = data || new Uint8Array(4 * width * height);\n  // If source height is specified, a top left coordinate system is used\n  y = sourceHeight ? sourceHeight - y : y;\n  if (dataOffset) {\n    assertWebGL2Context(gl);\n    gl.readPixels(x, y, width, height, format, type, data, dataOffset);\n  } else {\n    gl.readPixels(x, y, width, height, format, type, data);\n  }\n  return data;\n}\n\n/**\n * Read pixels directly into webgl buffer\n * NOTE: WebGL2 only\n *\n * @param {WebGLRenderingContext} gl\n * @param {Object} options\n * @return {WebGLBuffer} the passed in buffer\n */\nexport function readPixelsToBuffer(gl, {\n  x,\n  y,\n  width = 1,\n  height = 1,\n  buffer,\n  dataOffset = 0,\n  type = GL.UNSIGNED_BYTE,\n  sourceHeight,\n  format = GL.RGBA\n}) {\n  assertWebGL2Context(gl);\n\n  // If source height is specified, a top left coordinate system is used\n  y = sourceHeight ? sourceHeight - y : y;\n\n  gl.bindBuffer(GL.PIXEL_PACK_BUFFER, buffer.handle);\n\n  gl.readPixels(x, y, width, height, format, type, dataOffset);\n\n  gl.bindBuffer(GL.PIXEL_PACK_BUFFER, null);\n\n  return buffer;\n}\n\n/*\n* @param {} opt.filter\n */\nexport function blitFramebuffer(gl, {\n  source: [sourceX, sourceY, sourceWidth, sourceHeight],\n  dest: [destX, destY, destWidth, destHeight],\n  mask = GL.COLOR_BUFFER_BIT | GL.DEPTH_BUFFER_BIT | GL.STENCIL_BUFFER_BIT,\n  filter = GL.LINEAR\n}) {\n}\n"]}