{"version":3,"sources":["../../src/core/pick-models.js"],"names":["clear","isWebGL","Group","assert","ILLEGAL_ARG","getDevicePixelRatio","window","devicePixelRatio","pickModels","gl","models","position","uniforms","parameters","settings","useDevicePixelRatio","framebuffer","x","y","resize","width","canvas","height","dpr","deviceX","deviceY","group","children","traverseReverse","model","isPickable","color","depth","setUniforms","picking_uActive","draw","readPixels","format","RGBA","type","UNSIGNED_BYTE","isPicked"],"mappings":";;AAAA;AACA,SAAQA,KAAR,EAAeC,OAAf,QAA6B,UAA7B;AACA,OAAOC,KAAP,MAAkB,SAAlB;AACA,OAAOC,MAAP,MAAmB,QAAnB;;AAEA,IAAMC,cAAc,0BAApB;;AAEA,SAASC,mBAAT,GAA+B;AAC7B,SAAO,OAAOC,MAAP,KAAkB,WAAlB,GAAgCA,OAAOC,gBAAvC,GAA0D,CAAjE;AACD;;AAED,eAAe,SAASC,UAAT,CAAoBC,EAApB,QAQZ;AAAA,MAPDC,MAOC,QAPDA,MAOC;AAAA,MANDC,QAMC,QANDA,QAMC;AAAA,2BALDC,QAKC;AAAA,MALDA,QAKC,iCALU,EAKV;AAAA,6BAJDC,UAIC;AAAA,MAJDA,UAIC,mCAJY,EAIZ;AAAA,MAHDC,QAGC,QAHDA,QAGC;AAAA,mCAFDC,mBAEC;AAAA,MAFDA,mBAEC,yCAFqB,IAErB;AAAA,MADDC,WACC,QADDA,WACC;;AACDb,SAAOF,QAAQQ,EAAR,CAAP,EAAoBL,WAApB;AACAD,SAAOa,WAAP,EAAoBZ,WAApB;AACAD,SAAOQ,QAAP,EAAiBP,WAAjB;;AAHC,iCAKcO,QALd;AAAA,MAKMM,CALN;AAAA,MAKSC,CALT;;AAOD;;;AACAF,cAAYG,MAAZ,CAAmB,EAACC,OAAOX,GAAGY,MAAH,CAAUD,KAAlB,EAAyBE,QAAQb,GAAGY,MAAH,CAAUC,MAA3C,EAAnB;;AAEA;AACA;AACA,MAAMC,MAAMR,sBAAsBV,qBAAtB,GAA8C,CAA1D;AACA;AACA,MAAMmB,UAAUP,IAAIM,GAApB;AACA,MAAME,UAAUhB,GAAGY,MAAH,CAAUC,MAAV,GAAmBJ,IAAIK,GAAvC;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAMG,QAAQ,IAAIxB,KAAJ,CAAU,EAACyB,UAAUjB,MAAX,EAAV,CAAd;AACA,SAAOgB,MAAME,eAAN,CAAsB,iBAAS;;AAEpC,QAAIC,MAAMC,UAAN,EAAJ,EAAwB;AACtB;AACA9B,YAAMS,EAAN,EAAU,EAACO,wBAAD,EAAce,OAAO,IAArB,EAA2BC,OAAO,IAAlC,EAAV;;AAEA;AACA;AACAH,YAAMI,WAAN,CAAkB,EAACC,iBAAiB,CAAlB,EAAlB;AACAL,YAAMM,IAAN,CAAW,EAACvB,kBAAD,EAAWC,sBAAX,EAAuBC,kBAAvB,EAAiCE,wBAAjC,EAAX;AACAa,YAAMI,WAAN,CAAkB,EAACC,iBAAiB,CAAlB,EAAlB;;AAEA;AACA,UAAMH,QAAQf,YAAYoB,UAAZ,CAAuB;AACnCnB,WAAGO,OADgC;AAEnCN,WAAGO,OAFgC;AAGnCL,eAAO,CAH4B;AAInCE,gBAAQ,CAJ2B;AAKnCe,gBAAQ5B,GAAG6B,IALwB;AAMnCC,cAAM9B,GAAG+B,aAN0B,EAAvB,CAAd;;AAQA,UAAMC,WAAWV,MAAM,CAAN,MAAa,CAAb,IAAkBA,MAAM,CAAN,MAAa,CAA/B,IAAoCA,MAAM,CAAN,MAAa,CAAlE;;AAEA;AACA,UAAIU,QAAJ,EAAc;AACZ,eAAO;AACLZ,sBADK;AAELE,sBAFK;AAGLd,cAHK;AAILC,cAJK;AAKLM,0BALK;AAMLC;AANK,SAAP;AAQD;AACF;;AAED,WAAO,IAAP;AACD,GArCM,CAAP;AAsCA;AACD","file":"pick-models.js","sourcesContent":["/* global window */\nimport {clear, isWebGL} from '../webgl';\nimport Group from './group';\nimport assert from 'assert';\n\nconst ILLEGAL_ARG = 'Illegal argument to pick';\n\nfunction getDevicePixelRatio() {\n  return typeof window !== 'undefined' ? window.devicePixelRatio : 1;\n}\n\nexport default function pickModels(gl, {\n  models,\n  position,\n  uniforms = {}, // eslint-disable-line\n  parameters = {},\n  settings,\n  useDevicePixelRatio = true,\n  framebuffer\n}) {\n  assert(isWebGL(gl), ILLEGAL_ARG);\n  assert(framebuffer, ILLEGAL_ARG);\n  assert(position, ILLEGAL_ARG);\n\n  const [x, y] = position;\n\n  // Match our picking framebuffer with the size of the canvas drawing buffer\n  framebuffer.resize({width: gl.canvas.width, height: gl.canvas.height});\n\n  // Compensate for devicePixelRatio\n  // Note: this assumes the canvas framebuffer has been matched\n  const dpr = useDevicePixelRatio ? getDevicePixelRatio() : 1;\n  // Reverse the y coordinate\n  const deviceX = x * dpr;\n  const deviceY = gl.canvas.height - y * dpr;\n\n  // return withParameters(gl, {\n  //   // framebuffer,\n  //   // // We are only interested in one pixel, no need to render anything else\n  //   // scissorTest: {x: deviceX, y: deviceY, w: 1, h: 1}\n  // }, () => {\n  const group = new Group({children: models});\n  return group.traverseReverse(model => {\n\n    if (model.isPickable()) {\n      // Clear the frame buffer\n      clear(gl, {framebuffer, color: true, depth: true});\n\n      // Render picking colors\n      /* eslint-disable camelcase */\n      model.setUniforms({picking_uActive: 1});\n      model.draw({uniforms, parameters, settings, framebuffer});\n      model.setUniforms({picking_uActive: 0});\n\n      // Sample Read color in the central pixel, to be mapped as a picking color\n      const color = framebuffer.readPixels({\n        x: deviceX,\n        y: deviceY,\n        width: 1,\n        height: 1,\n        format: gl.RGBA,\n        type: gl.UNSIGNED_BYTE});\n\n      const isPicked = color[0] !== 0 || color[1] !== 0 || color[2] !== 0;\n\n      // Add the information to the stack\n      if (isPicked) {\n        return {\n          model,\n          color,\n          x,\n          y,\n          deviceX,\n          deviceY\n        };\n      }\n    }\n\n    return null;\n  });\n  // });\n}\n"]}