{"version":3,"sources":["../../src/webgl-utils/create-canvas.js"],"names":["isBrowser","window","isPageLoaded","pageLoadPromise","Promise","resolve","reject","onload","document","getPageLoadPromise","createCanvas","width","height","id","insert","canvas","createElement","style","Number","isFinite","then","body","insertBefore","firstChild","getCanvas","Error","getElementById","getCSSSize","clientWidth","clientHeight","getDrawingBufferSize","calculateDrawingBufferSize","useDevicePixelRatio","cssToDevicePixels","devicePixelRatio","cssSize","Math","floor","resizeCanvas","resizeDrawingBuffer","newBufferSize"],"mappings":"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","file":"create-canvas.js","sourcesContent":["// Resizing a webgl canvas\n\n/* global window, document */\n\nconst isBrowser = typeof window !== 'undefined';\n\nlet isPageLoaded = false;\n\nconst pageLoadPromise = isBrowser ?\n  new Promise((resolve, reject) => {\n    window.onload = () => {\n      isPageLoaded = true;\n      resolve(document);\n    };\n  }) :\n  Promise.resolve({});\n\n/**\n * Returns a promise that resolves when the page is loaded\n * at this point the DOM can be manipulated, and e.g. a new canvas can be inserted\n * @return {Promise} - resolves when the page is loaded\n */\nexport function getPageLoadPromise() {\n  return pageLoadPromise;\n}\n\n/**\n * Create a canvas\n * @param {Number} width - set to 100%\n * @param {Number} height - set to 100%\n */\nexport function createCanvas({width = 800, height = 600, id = 'gl-canvas', insert = true}) {\n  const canvas = document.createElement('canvas');\n  canvas.id = id;\n  canvas.style.width = Number.isFinite(width) ? `${width}px` : '100%';\n  canvas.style.height = Number.isFinite(height) ? `${height}px` : '100%';\n  // add the canvas to the body element once the page has loaded\n  if (insert) {\n    getPageLoadPromise().then(document => {\n      const body = document.body;\n      body.insertBefore(canvas, body.firstChild);\n    });\n  }\n  return canvas;\n}\n\n/**\n * Gets an already created canvas from the DOM\n * @param {Number} id - DOM element id\n */\nexport function getCanvas({id}) {\n  if (!isPageLoaded) {\n    throw new Error(`createGLContext called on canvas '${id}' before page was loaded`);\n  }\n  return document.getElementById(id);\n}\n\n// Gets current size of canvas in css (logical/window) coordinates\nexport function getCSSSize(canvas) {\n  return {\n    width: canvas.clientWidth,\n    height: canvas.clientHeight\n  };\n}\n\n// Gets current size of canvas drawing buffer in actual pixels\n// This is needed for the gl.viewport call\nexport function getDrawingBufferSize(canvas) {\n  return {\n    width: canvas.width,\n    height: canvas.height\n  };\n}\n\n// Calculate the drawing buffer size that would cover current canvas size and device pixel ratio\n// Intention is that every pixel in the drawing buffer will have a 1-to-1 mapping with\n// actual device pixels in the hardware framebuffer, allowing us to render at the full\n// resolution of the device.\nexport function calculateDrawingBufferSize(canvas, {useDevicePixelRatio = true}) {\n  const cssToDevicePixels = useDevicePixelRatio ? window.devicePixelRatio || 1 : 1;\n\n  // Lookup the size the browser is displaying the canvas in CSS pixels\n  // and compute a size needed to make our drawingbuffer match it in\n  // device pixels.\n  const cssSize = getCSSSize(canvas);\n  return {\n    width: Math.floor(cssSize.width * cssToDevicePixels),\n    height: Math.floor(cssSize.height * cssToDevicePixels),\n    devicePixelRatio: cssToDevicePixels\n  };\n}\n\n/**\n * Resizes canvas in \"CSS coordinates\" (note these can be very different from device coords,\n * depending on devicePixelRatio/retina screens and size of drawing buffer)\n * and can be changed separately from drawing buffer size.\n * Therefore, normally `resizeDrawingBuffer` should be called after calling `resizeCanvas`.\n *\n * See http://webgl2fundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html\n *\n * @param {Number} width, height - new width and height of canvas in CSS coordinates\n */\nexport function resizeCanvas(canvas, {\n  width,\n  height,\n  useDevicePixelRatio = true\n}) {\n  canvas.style.width = `${width}px`;\n  canvas.style.height = `${height}px`;\n}\n\n/**\n * Resize the canvas' drawing buffer to match the canvas CSS size,\n * and by default to also consider devicePixelRatio\n * detects if anything has changed, can be called every frame\n * for best visual results, usually set to either:\n *  canvas CSS width x canvas CSS height\n *  canvas CSS width * devicePixelRatio x canvas CSS height * devicePixelRatio\n *\n * NOTE: Regardless of size, the drawing buffer will always be scaled to the viewport\n * See http://webgl2fundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html\n *\n * @param {Number} width - new width of canvas in CSS coordinates\n * @param {Number} height - new height of canvas in CSS coordinates\n */\nexport function resizeDrawingBuffer(canvas, {useDevicePixelRatio = true}) {\n  // Resize the render buffer of the canvas to match canvas client size\n  // multiplying with dpr (Optionally can be turned off)\n  const newBufferSize = calculateDrawingBufferSize(canvas, {useDevicePixelRatio});\n  // Only update if the canvas size has not changed\n  if (newBufferSize.width !== canvas.width || newBufferSize.height !== canvas.height) {\n    // Make the canvas render buffer the same size as\n    canvas.width = newBufferSize.width;\n    canvas.height = newBufferSize.height;\n    // Always reset CSS size after setting drawing buffer size\n    // canvas.style.width = `${cssSize.width}px`;\n    // canvas.style.height = `${cssSize.height}px`;\n  }\n}\n"]}