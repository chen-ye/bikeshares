{"version":3,"sources":["../../src/webgl-utils/format-glsl-error.js"],"names":["getShaderName","getShaderTypeName","parseGLSLCompilerError","errLog","src","shaderType","errorStrings","split","errors","warnings","i","length","errorString","segments","type","line","parseInt","isNaN","Error","lines","addLineNumbers","name","shaderName","formatErrors","formatGLSLCompilerError","message","error","column","err","substr","join","trim","padLeft","string","start","delim","maxDigits","String","map","lineNumber","digits","prefix","result"],"mappings":"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","file":"format-glsl-error.js","sourcesContent":["// TODO - formatGLSLCompilerError should not depend on this\nimport getShaderName, {getShaderTypeName} from './get-shader-name';\n\n/**\n * Parse a GLSL compiler error log into a string showing the source code around each error.\n * Based on https://github.com/wwwtyro/gl-format-compiler-error (public domain)\n */\n/* eslint-disable no-continue, max-statements */\nexport function parseGLSLCompilerError(errLog, src, shaderType) {\n  const errorStrings = errLog.split(/\\r?\\n/);\n  const errors = {};\n  const warnings = {};\n\n  // Parse the error - note: browser and driver dependent\n  for (let i = 0; i < errorStrings.length; i++) {\n    const errorString = errorStrings[i];\n    if (errorString.length <= 1) {\n      continue;\n    }\n    const segments = errorString.split(':');\n    const type = segments[0];\n    const line = parseInt(segments[2], 10);\n    if (isNaN(line)) {\n      throw new Error(`Could not parse GLSL compiler error: ${errLog}`);\n    }\n    if (type !== 'WARNING') {\n      errors[line] = errorString;\n    } else {\n      warnings[line] = errorString;\n    }\n  }\n\n  // Format the error inline with the code\n  const lines = addLineNumbers(src);\n  const name = getShaderName(src) || 'unknown name';\n  const type = getShaderTypeName(shaderType);\n\n  return {\n    shaderName: `${type} shader ${name}\\n`,\n    errors: formatErrors(errors, lines),\n    warnings: formatErrors(warnings, lines)\n  };\n}\n\n// Formats GLSL compiler error log into single string\nexport default function formatGLSLCompilerError(errLog, src, shaderType) {\n  const {shaderName, errors, warnings} = parseGLSLCompilerError(errLog, src, shaderType);\n  return `GLSL compilation error in ${shaderName}\\n${errors}\\n${warnings}`;\n}\n\n// helper function, outputs annotated errors or warnings\nfunction formatErrors(errors, lines) {\n  let message = '';\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    if (!errors[i + 3] && !errors[i + 2] && !errors[i + 1]) {\n      continue;\n    }\n    message += `${line}\\n`;\n    if (errors[i + 1]) {\n      const error = errors[i + 1];\n      const segments = error.split(':', 3);\n      const type = segments[0];\n      const column = parseInt(segments[1], 10) || 0;\n      const err = error.substr(segments.join(':').length + 1).trim();\n      message += padLeft(`^^^ ${type}: ${err}\\n\\n`, column);\n    }\n  }\n  return message;\n}\n\n/**\n * Prepends line numbers to each line of a string.\n * The line numbers will be left-padded with spaces to ensure an\n * aligned layout when rendered using monospace fonts.\n * @param {String} string - multi-line string to add line numbers to\n * @param {Number} start=1 - number of spaces to add\n * @param {String} delim =': ' - injected between line number and original line\n * @return {String[]} strings - array of string, one per line, with line numbers added\n */\nfunction addLineNumbers(string, start = 1, delim = ': ') {\n  const lines = string.split(/\\r?\\n/);\n  const maxDigits = String(lines.length + start - 1).length;\n  return lines.map((line, i) => {\n    const lineNumber = i + start;\n    const digits = String(lineNumber).length;\n    const prefix = padLeft(lineNumber, maxDigits - digits);\n    return prefix + delim + line;\n  });\n}\n\n/**\n * Pads a string with a number of spaces (space characters) to the left\n * @param {String} string - string to pad\n * @param {Number} digits - number of spaces to add\n * @return {String} string - The padded string\n */\nfunction padLeft(string, digits) {\n  let result = '';\n  for (let i = 0; i < digits; ++i) {\n    result += ' ';\n  }\n  return `${result}${string}`;\n}\n"]}