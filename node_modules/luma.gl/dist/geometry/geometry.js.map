{"version":3,"sources":["../../src/geometry/geometry.js"],"names":["getDrawMode","DRAW_MODE","POINTS","LINES","LINE_LOOP","LINE_STRIP","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","drawMode","mode","Geometry","opts","id","vertexCount","undefined","attributes","constructor","name","needsRedraw","userData","Object","seal","setAttributes","deprecated","redraw","clearRedrawFlags","indices","value","length","vertices","positions","attributeName","Boolean","attribute","ArrayBuffer","isView","_print","_autoDetectAttribute","assign","instanced","setNeedsRedraw","category","size","isIndexed","Uint16Array","Uint32Array"],"mappings":"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","file":"geometry.js","sourcesContent":["import {uid} from '../utils';\nimport {log} from '../utils';\nimport assert from 'assert';\n\n// Rendering primitives - specify how to extract primitives from vertices.\n// NOTE: These are numerically identical to the corresponding WebGL/OpenGL constants\nexport const DRAW_MODE = {\n  POINTS: 0x0000, // draw single points.\n  LINES: 0x0001, // draw lines. Each vertex connects to the one after it.\n  LINE_LOOP: 0x0002, // draw lines. Each set of two vertices is treated as a separate line segment.\n  LINE_STRIP: 0x0003, // draw a connected group of line segments from the first vertex to the last\n  TRIANGLES: 0x0004, // draw triangles. Each set of three vertices creates a separate triangle.\n  TRIANGLE_STRIP: 0x0005, // draw a connected group of triangles.\n  TRIANGLE_FAN: 0x0006 // draw a connected group of triangles.\n                       // Each vertex connects to the previous and the first vertex in the fan.\n};\n\n// Helper function to handle string draw modes - when using this library without WebGL constants\nexport function getDrawMode(drawMode) {\n  const mode = typeof drawMode === 'string' ?\n    DRAW_MODE[drawMode] || DRAW_MODE.TRIANGLES :\n    drawMode;\n  assert(mode >= 0 && mode <= DRAW_MODE.TRIANGLE_FAN, 'Illegal drawMode');\n  return mode;\n}\n\nexport default class Geometry {\n\n  constructor(opts = {}) {\n    const {\n      id,\n      drawMode = DRAW_MODE.TRIANGLES,\n      vertexCount = undefined,\n      attributes\n    } = opts;\n\n    this.id = id || uid(this.constructor.name);\n    this.drawMode = getDrawMode(drawMode);\n    this.vertexCount = vertexCount;\n    this.attributes = {};\n    this.needsRedraw = true;\n    this.userData = {};\n    Object.seal(this);\n\n    if (attributes) {\n      this.setAttributes(attributes);\n    } else {\n      log.deprecated('inline attributes', 'attributes parameter');\n      // TODO this is deprecated\n      delete opts.id;\n      delete opts.drawMode;\n      delete opts.vertexCount;\n      delete opts.attributes;\n      this.setAttributes(opts);\n    }\n  }\n\n  setNeedsRedraw(redraw = true) {\n    this.needsRedraw = redraw;\n    return this;\n  }\n\n  getNeedsRedraw({clearRedrawFlags = false} = {}) {\n    let redraw = false;\n    redraw = redraw || this.needsRedraw;\n    this.needsRedraw = this.needsRedraw && !clearRedrawFlags;\n    return redraw;\n  }\n\n  setVertexCount(vertexCount) {\n    this.vertexCount = vertexCount;\n  }\n\n  getVertexCount() {\n    if (this.vertexCount !== undefined) {\n      return this.vertexCount;\n    } else if (this.attributes.indices) {\n      return this.attributes.indices.value.length;\n    } else if (this.attributes.vertices) {\n      return this.attributes.vertices.value.length / 3;\n    } else if (this.attributes.positions) {\n      return this.attributes.positions.value.length / 3;\n    }\n    return false;\n  }\n\n  hasAttribute(attributeName) {\n    return Boolean(this.attributes[attributeName]);\n  }\n\n  getAttribute(attributeName) {\n    const attribute = this.attributes[attributeName];\n    assert(attribute);\n    return attribute.value;\n  }\n\n  getArray(attributeName) {\n    const attribute = this.attributes[attributeName];\n    assert(attribute);\n    return attribute.value;\n  }\n\n  getAttributes() {\n    return this.attributes;\n  }\n\n  // Attribute\n  // value: typed array\n  // type: indices, vertices, uvs\n  // size: elements per vertex\n  // target: WebGL buffer type (string or constant)\n  setAttributes(attributes) {\n    for (const attributeName in attributes) {\n      let attribute = attributes[attributeName];\n\n      // Wrap \"unwrapped\" arrays and try to autodetect their type\n      attribute = ArrayBuffer.isView(attribute) ? {value: attribute} : attribute;\n\n      assert(ArrayBuffer.isView(attribute.value),\n        `${this._print(attributeName)}: must be typed array or object with value as typed array`);\n\n      this._autoDetectAttribute(attributeName, attribute);\n\n      this.attributes[attributeName] = Object.assign({}, attribute, {\n        instanced: attribute.instanced || 0\n      });\n    }\n    this.setNeedsRedraw();\n    return this;\n  }\n\n  // Check for well known attribute names\n  /* eslint-disable default-case, complexity */\n  _autoDetectAttribute(attributeName, attribute) {\n    let category;\n    switch (attributeName) {\n    case 'indices':\n      category = category || 'indices';\n      break;\n    case 'texCoords':\n    case 'texCoord1':\n    case 'texCoord2':\n    case 'texCoord3':\n      category = 'uvs';\n      break;\n    case 'vertices':\n    case 'positions':\n    case 'normals':\n    case 'pickingColors':\n      category = 'vectors';\n      break;\n    }\n\n    // Check for categorys\n    switch (category) {\n    case 'vectors':\n      attribute.size = attribute.size || 3;\n      break;\n    case 'uvs':\n      attribute.size = attribute.size || 2;\n      break;\n    case 'indices':\n      attribute.size = attribute.size || 1;\n      attribute.isIndexed = attribute.isIndexed || true;\n      assert(\n        attribute.value instanceof Uint16Array ||\n        attribute.value instanceof Uint32Array,\n        'attribute array for \"indices\" must be of integer type'\n      );\n      break;\n    }\n\n    assert(attribute.size, `attribute ${attributeName} needs size`);\n  }\n  /* eslint-enable default-case, complexity */\n\n  _print(attributeName) {\n    return `Geometry ${this.id} attribute ${attributeName}`;\n  }\n}\n"]}