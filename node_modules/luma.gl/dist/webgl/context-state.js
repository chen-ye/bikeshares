'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resetParameters = exports.getParameters = exports.getParameter = exports.LUMA_SETTERS = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); /* eslint-disable no-inline-comments, max-len */


var _setParameters = require('../webgl-utils/set-parameters');

Object.defineProperty(exports, 'getParameter', {
  enumerable: true,
  get: function get() {
    return _setParameters.getParameter;
  }
});
Object.defineProperty(exports, 'getParameters', {
  enumerable: true,
  get: function get() {
    return _setParameters.getParameters;
  }
});
Object.defineProperty(exports, 'resetParameters', {
  enumerable: true,
  get: function get() {
    return _setParameters.resetParameters;
  }
});
exports.setParameters = setParameters;
exports.withParameters = withParameters;
exports.withState = withState;
exports.glContextWithState = glContextWithState;

var _constants = require('../webgl-utils/constants');

var _constants2 = _interopRequireDefault(_constants);

var _trackContextState = require('../webgl-utils/track-context-state');

var _utils = require('../utils');

var _context = require('./context');

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

// map of parameter setter function names, parameter constants, default values and types
// - Uses gl function names, except when setter function exist that are named differently
// - When the WebGL api offers <setter> and <setter>Separate (e.g. blendEquation and
//   blendEquationSeparate, we use non-separate name, but accept both non-separate and
//   separate arguments. Thus, a `getParameter` call will always return all the separate values
//   in an array, in a form that can be accepted by the setter.
var LUMA_SETTERS = exports.LUMA_SETTERS = {
  bindFramebuffer: function bindFramebuffer(gl, args) {
    (0, _assert2.default)(args.length === 2, 'bindFramebuffer needs two arguments, target and handle');

    var _args = _slicedToArray(args, 2),
        target = _args[0],
        handle = _args[1];

    if (target === _constants2.default.FRAMEBUFFER) {
      if ((0, _context.isWebGL2)(gl)) {
        // NOTE: https://www.khronos.org/registry/OpenGL/extensions/EXT/EXT_framebuffer_blit.txt
        // As per above spec, under WebGL2, FRAMEBUFFER binding updates both READ_FRAMEBUFFER and DRAW_FRAMEBUFFER
        // This generates two bindFramebuffer calls so that our cache is correct
        gl.bindFramebuffer(_constants2.default.DRAW_FRAMEBUFFER, handle);
        gl.bindFramebuffer(_constants2.default.READ_FRAMEBUFFER, handle);
      } else {
        gl.bindFramebuffer(_constants2.default.FRAMEBUFFER, handle);
      }
    } else {
      // handle GL.DRAW_FRAMEBUFFER and GL.READ_FRAMEBUFFER
      gl.bindFramebuffer(target, handle);
    }
  },
  blend: function blend(gl, value) {
    return value ? gl.enable(_constants2.default.BLEND) : gl.disable(_constants2.default.BLEND);
  },
  blendColor: function blendColor(gl, value) {
    return gl.blendColor.apply(gl, _toConsumableArray(value));
  },
  blendEquation: function blendEquation(gl, args) {
    args = isArray(args) ? args : [args, args];
    gl.blendEquationSeparate.apply(gl, _toConsumableArray(args));
  },
  blendFunc: function blendFunc(gl, args) {
    args = isArray(args) && args.length === 2 ? [].concat(_toConsumableArray(args), _toConsumableArray(args)) : args;
    gl.blendFuncSeparate.apply(gl, _toConsumableArray(args));
  },

  clearColor: function clearColor(gl, value) {
    return gl.clearColor.apply(gl, _toConsumableArray(value));
  },
  clearDepth: function clearDepth(gl, value) {
    return gl.clearDepth(value);
  },
  clearStencil: function clearStencil(gl, value) {
    return gl.clearStencil(value);
  },

  colorMask: function colorMask(gl, value) {
    return gl.colorMask.apply(gl, _toConsumableArray(value));
  },

  cull: function cull(gl, value) {
    return value ? gl.enable(_constants2.default.CULL_FACE) : gl.disable(_constants2.default.CULL_FACE);
  },
  cullFace: function cullFace(gl, value) {
    return gl.cullFace(value);
  },

  depthTest: function depthTest(gl, value) {
    return value ? gl.enable(_constants2.default.DEPTH_TEST) : gl.disable(_constants2.default.DEPTH_TEST);
  },
  depthFunc: function depthFunc(gl, value) {
    return gl.depthFunc(value);
  },
  depthMask: function depthMask(gl, value) {
    return gl.depthMask(value);
  },
  depthRange: function depthRange(gl, value) {
    return gl.depthRange.apply(gl, _toConsumableArray(value));
  },

  dither: function dither(gl, value) {
    return value ? gl.enable(_constants2.default.DITHER) : gl.disable(_constants2.default.DITHER);
  },

  derivativeHint: function derivativeHint(gl, value) {
    // gl1: 'OES_standard_derivatives'
    gl.hint(_constants2.default.FRAGMENT_SHADER_DERIVATIVE_HINT, value);
  },

  frontFace: function frontFace(gl, value) {
    return gl.frontFace(value);
  },

  mipmapHint: function mipmapHint(gl, value) {
    return gl.hint(_constants2.default.GENERATE_MIPMAP_HINT, value);
  },

  lineWidth: function lineWidth(gl, value) {
    return gl.lineWidth(value);
  },

  polygonOffsetFill: function polygonOffsetFill(gl, value) {
    return value ? gl.enable(_constants2.default.POLYGON_OFFSET_FILL) : gl.disable(_constants2.default.POLYGON_OFFSET_FILL);
  },
  polygonOffset: function polygonOffset(gl, value) {
    return gl.polygonOffset.apply(gl, _toConsumableArray(value));
  },

  sampleCoverage: function sampleCoverage(gl, value) {
    return gl.sampleCoverage.apply(gl, _toConsumableArray(value));
  },

  scissorTest: function scissorTest(gl, value) {
    return value ? gl.enable(_constants2.default.SCISSOR_TEST) : gl.disable(_constants2.default.SCISSOR_TEST);
  },
  scissor: function scissor(gl, value) {
    return gl.scissor.apply(gl, _toConsumableArray(value));
  },

  stencilTest: function stencilTest(gl, value) {
    return value ? gl.enable(_constants2.default.STENCIL_TEST) : gl.disable(_constants2.default.STENCIL_TEST);
  },
  stencilMask: function stencilMask(gl, value) {
    value = isArray(value) ? value : [value, value];

    var _value = value,
        _value2 = _slicedToArray(_value, 2),
        mask = _value2[0],
        backMask = _value2[1];

    gl.stencilMaskSeparate(_constants2.default.FRONT, mask);
    gl.stencilMaskSeparate(_constants2.default.BACK, backMask);
  },
  stencilFunc: function stencilFunc(gl, args) {
    args = isArray(args) && args.length === 3 ? [].concat(_toConsumableArray(args), _toConsumableArray(args)) : args;

    var _args2 = args,
        _args3 = _slicedToArray(_args2, 6),
        func = _args3[0],
        ref = _args3[1],
        mask = _args3[2],
        backFunc = _args3[3],
        backRef = _args3[4],
        backMask = _args3[5];

    gl.stencilFuncSeparate(_constants2.default.FRONT, func, ref, mask);
    gl.stencilFuncSeparate(_constants2.default.BACK, backFunc, backRef, backMask);
  },
  stencilOp: function stencilOp(gl, args) {
    args = isArray(args) && args.length === 3 ? [].concat(_toConsumableArray(args), _toConsumableArray(args)) : args;

    var _args4 = args,
        _args5 = _slicedToArray(_args4, 6),
        sfail = _args5[0],
        dpfail = _args5[1],
        dppass = _args5[2],
        backSfail = _args5[3],
        backDpfail = _args5[4],
        backDppass = _args5[5];

    gl.stencilOpSeparate(_constants2.default.FRONT, sfail, dpfail, dppass);
    gl.stencilOpSeparate(_constants2.default.BACK, backSfail, backDpfail, backDppass);
  },

  viewport: function viewport(gl, value) {
    return gl.viewport.apply(gl, _toConsumableArray(value));
  }
};

// HELPERS

function isArray(array) {
  return Array.isArray(array) || ArrayBuffer.isView(array);
}

// GETTERS AND SETTERS

// Get the parameter value(s) from the context


// Get the parameter value(s) from the context


// Set the parameter value(s) by key to the context
// Sets value with key to context.
// Value may be "normalized" (in case a short form is supported). In that case
// the normalized value is retured.
function setParameters(gl, parameters) {
  (0, _setParameters.setParameters)(gl, parameters);
  for (var key in parameters) {
    var setter = LUMA_SETTERS[key];
    if (setter) {
      setter(gl, parameters[key], key);
    }
  }
}

// VERY LIMITED / BASIC GL STATE MANAGEMENT
// Executes a function with gl states temporarily set, exception safe
// Currently support pixelStorage, scissor test and framebuffer binding
function withParameters(gl, parameters, func) {
  // assertWebGLContext(gl);

  var frameBuffer = parameters.frameBuffer,
      _parameters$nocatch = parameters.nocatch,
      nocatch = _parameters$nocatch === undefined ? true : _parameters$nocatch;
  var framebuffer = parameters.framebuffer;

  if (frameBuffer) {
    _utils.log.deprecated('withParameters({frameBuffer})', 'withParameters({framebuffer})');
    framebuffer = frameBuffer;
  }

  // Define a helper function that will reset state after the function call
  function resetStateAfterCall() {
    (0, _trackContextState.popContextState)(gl);
  }

  (0, _trackContextState.pushContextState)(gl);

  setParameters(gl, parameters);

  if (framebuffer) {
    framebuffer.bind();
  }

  // Setup is done, call the function
  var value = void 0;

  if (nocatch) {
    // Avoid try catch to minimize debugging impact for safe execution paths
    value = func(gl);
    resetStateAfterCall();
  } else {
    // Wrap in a try-catch to ensure that parameters are restored on exceptions
    try {
      value = func(gl);
    } finally {
      resetStateAfterCall();
    }
  }
  return value;
}

// DEPRECATED

function withState() {
  _utils.log.deprecated('withState', 'withParameters');
  return withParameters.apply(undefined, arguments);
}

function glContextWithState() {
  _utils.log.deprecated('glContextWithState', 'withParameters');
  return withParameters.apply(undefined, arguments);
}
//# sourceMappingURL=context-state.js.map